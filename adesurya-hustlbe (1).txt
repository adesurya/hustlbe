Directory structure:
└── adesurya-hustlbe/
    ├── package.json
    ├── server.js
    └── src/
        ├── app.js
        ├── config/
        │   ├── database.js
        │   ├── passport.js
        │   └── security.js
        ├── controllers/
        │   ├── authController.js
        │   ├── categoryController.js
        │   ├── leaderboardController.js
        │   ├── pointController.js
        │   ├── productController.js
        │   └── userController.js
        ├── middleware/
        │   ├── auth.js
        │   ├── enhancedErrorHandler.js
        │   ├── errorHandler.js
        │   ├── leaderboardValidation.js
        │   ├── rateLimiter.js
        │   ├── security.js
        │   ├── upload.js
        │   └── validation.js
        ├── models/
        │   ├── Category.js
        │   ├── index.js
        │   ├── PointActivity.js
        │   ├── PointRedemption.js
        │   ├── PointTransaction.js
        │   ├── Product.js
        │   ├── ProductImage.js
        │   └── User.js
        ├── routes/
        │   ├── auth.js
        │   ├── category.js
        │   ├── index.js
        │   ├── leaderboard.js
        │   ├── point.js
        │   ├── product.js
        │   └── user.js
        ├── services/
        │   ├── authService.js
        │   ├── categoryService.js
        │   ├── emailService.js
        │   ├── googleAuthService.js
        │   ├── leaderboardService.js
        │   ├── pointService.js
        │   ├── productService.js
        │   └── userService.js
        └── utils/
            ├── email.js
            ├── encryption.js
            ├── logger.js
            ├── response.js
            └── validation.js

================================================
FILE: package.json
================================================
{
  "name": "secure-nodejs-backend",
  "version": "1.0.0",
  "description": "Secure Node.js Backend API with MVC Architecture",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "migrate": "node migrations/migrate.js",
    "db:setup": "node setup-database.js",
    "db:reset": "node setup-database.js --force",
    "db:seed": "node seeds/index.js",
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    "format": "prettier --write src/**/*.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "connect-session-sequelize": "^7.1.7",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.1.5",
    "express-session": "^1.18.0",
    "express-slow-down": "^2.0.3",
    "express-validator": "^7.0.1",
    "helmet": "^7.1.0",
    "joi": "^17.12.1",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "mysql2": "^3.9.1",
    "node-mailjet": "^6.0.9",
    "nodemailer": "^7.0.5",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-jwt": "^4.0.1",
    "sequelize": "^6.37.1",
    "winston": "^3.11.0",
    "xss": "^1.0.14"
  },
  "devDependencies": {
    "@types/jest": "^29.5.11",
    "eslint": "^8.57.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-plugin-import": "^2.29.1",
    "jest": "^29.7.0",
    "nodemon": "^3.0.3",
    "prettier": "^3.2.5",
    "supertest": "^6.3.4"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "keywords": [
    "nodejs",
    "express",
    "mvc",
    "mysql",
    "jwt",
    "oauth",
    "security",
    "owasp"
  ],
  "author": "Your Name",
  "license": "MIT",
  "jest": {
    "testEnvironment": "node",
    "collectCoverageFrom": [
      "src/**/*.js",
      "!src/**/*.test.js"
    ],
    "testMatch": [
      "**/tests/**/*.test.js"
    ]
  }
}



================================================
FILE: server.js
================================================
#!/usr/bin/env node

/**
 * Secure Node.js Backend Server
 * Entry point for the application
 */

// Add error handling at the very beginning
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

console.log('🚀 Starting server...');

try {
  require('dotenv').config();
  console.log('✅ Environment variables loaded');
} catch (error) {
  console.error('❌ Failed to load environment variables:', error);
  process.exit(1);
}

let app;
try {
  app = require('./src/app');
  console.log('✅ App module loaded');
} catch (error) {
  console.error('❌ Failed to load app module:', error);
  process.exit(1);
}

let testConnection;
try {
  ({ testConnection } = require('./src/config/database'));
  console.log('✅ Database config loaded');
} catch (error) {
  console.error('❌ Failed to load database config:', error);
  process.exit(1);
}

let logger;
try {
  ({ logger } = require('./src/utils/logger'));
  console.log('✅ Logger loaded');
} catch (error) {
  console.error('❌ Failed to load logger:', error);
  // Fallback to console if logger fails
  logger = console;
}

// Configuration
const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || 'localhost';
const NODE_ENV = process.env.NODE_ENV || 'development';

console.log(`📋 Configuration:`);
console.log(`   NODE_ENV: ${NODE_ENV}`);
console.log(`   HOST: ${HOST}`);
console.log(`   PORT: ${PORT}`);

/**
 * Start the server
 */
const startServer = async () => {
  try {
    console.log('🔍 Testing database connection...');
    
    // Test database connection
    const dbConnected = await testConnection();
    
    if (!dbConnected) {
      logger.error('Failed to connect to database. Exiting...');
      process.exit(1);
    }

    console.log('🎯 Starting HTTP server...');

    // Start HTTP server
    const server = app.listen(PORT, HOST, () => {
      logger.info(`🚀 Server running in ${NODE_ENV} mode`);
      logger.info(`🌐 Server URL: http://${HOST}:${PORT}`);
      logger.info(`📚 API Documentation: http://${HOST}:${PORT}/docs`);
      logger.info(`❤️  Health Check: http://${HOST}:${PORT}/health`);
      logger.info(`🔐 API Endpoints: http://${HOST}:${PORT}${process.env.API_PREFIX || '/api/v1'}`);
      
      if (NODE_ENV === 'development') {
        logger.info('📋 Available routes:');
        logger.info('   Authentication:');
        logger.info(`     POST ${process.env.API_PREFIX || '/api/v1'}/auth/register`);
        logger.info(`     POST ${process.env.API_PREFIX || '/api/v1'}/auth/login`);
        logger.info(`     GET  ${process.env.API_PREFIX || '/api/v1'}/products/search`);
        logger.info(`     POST ${process.env.API_PREFIX || '/api/v1'}/products (Admin)`);
        logger.info('   Points:');
        logger.info(`     GET  ${process.env.API_PREFIX || '/api/v1'}/points/my-points`);
        logger.info(`     POST ${process.env.API_PREFIX || '/api/v1'}/points/redeem`);
        logger.info('   File Access:');
        logger.info(`     GET  /uploads/categories/:filename`);
        logger.info(`     GET  /uploads/products/:filename`);
        logger.info('');
        logger.info('🔧 Admin Features:');
        logger.info('   • Complete user CRUD operations');
        logger.info('   • User ban/unban management with email notifications');
        logger.info('   • User statistics and analytics (including banned users)');
        logger.info('   • Account management (lock/unlock, activate/deactivate)');
        logger.info('   • Password reset for users');
        logger.info('   • User restoration from soft delete');
        logger.info('   • Enhanced security logging and audit trail');
        logger.info('');
        logger.info('👤 User Features:');
        logger.info('   • Enhanced profile management');
        logger.info('   • Public profile viewing');
        logger.info('   • Account metrics and status');
        logger.info('   • Email change with re-verification');
      }
    });

    // Store server instance for graceful shutdown
    app.set('server', server);

    // Server error handling
    server.on('error', (error) => {
      if (error.syscall !== 'listen') {
        throw error;
      }

      const bind = typeof PORT === 'string' ? `Pipe ${PORT}` : `Port ${PORT}`;

      switch (error.code) {
        case 'EACCES':
          logger.error(`${bind} requires elevated privileges`);
          process.exit(1);
          break;
        case 'EADDRINUSE':
          logger.error(`${bind} is already in use`);
          process.exit(1);
          break;
        default:
          throw error;
      }
    });

    // Handle server startup
    server.on('listening', () => {
      const addr = server.address();
      const bind = typeof addr === 'string' ? `pipe ${addr}` : `port ${addr.port}`;
      logger.info(`Server listening on ${bind}`);
    });

    // Handle server close
    server.on('close', () => {
      logger.info('Server closed');
    });

  } catch (error) {
    logger.error('Failed to start server:', error);
    console.error('❌ Server startup failed:', error);
    process.exit(1);
  }
};

/**
 * Handle SIGTERM signal
 */
process.on('SIGTERM', () => {
  logger.info('SIGTERM received. Shutting down gracefully...');
  const server = app.get('server');
  
  if (server) {
    server.close(() => {
      logger.info('Process terminated');
      process.exit(0);
    });
  } else {
    process.exit(0);
  }
});

/**
 * Handle SIGINT signal (Ctrl+C)
 */
process.on('SIGINT', () => {
  logger.info('SIGINT received. Shutting down gracefully...');
  const server = app.get('server');
  
  if (server) {
    server.close(() => {
      logger.info('Process terminated');
      process.exit(0);
    });
  } else {
    process.exit(0);
  }
});

// Start the server
console.log('🎬 Calling startServer...');
startServer().catch((error) => {
  console.error('❌ Fatal error during startup:', error);
  process.exit(1);
});

module.exports = app;


================================================
FILE: src/app.js
================================================
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const session = require('express-session');
const SequelizeStore = require('connect-session-sequelize')(session.Store);
const cookieParser = require('cookie-parser');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss');


require('dotenv').config();

// Import configurations
const { sequelize } = require('./config/database');

// Import security configurations with fallbacks
let corsOptions, helmetOptions, generalLimiter;
try {
  const securityConfig = require('./config/security');
  corsOptions = securityConfig.corsOptions || {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
  };
  helmetOptions = securityConfig.helmetOptions || {};
  generalLimiter = securityConfig.generalLimiter || ((req, res, next) => next());
} catch (error) {
  console.warn('⚠️ Security config not found, using fallback configurations');
  corsOptions = {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
  };
  helmetOptions = {};
  generalLimiter = (req, res, next) => next();
}

// Import passport configuration with error handling
let passport;
try {
  passport = require('./config/passport');
} catch (error) {
  console.warn('⚠️ Passport config not found, authentication may not work properly');
  passport = require('passport');
}

// Import middleware
let requestLogger, errorLogger;
try {
  const loggerUtils = require('./utils/logger');
  requestLogger = loggerUtils.requestLogger || ((req, res, next) => next());
  errorLogger = loggerUtils.errorLogger || ((req, res, next) => next());
} catch (error) {
  console.warn('⚠️ Logger utils not found, using fallback loggers');
  requestLogger = (req, res, next) => next();
  errorLogger = (req, res, next) => next();
}

let errorHandler, notFoundHandler;
try {
  const errorMiddleware = require('./middleware/errorHandler');
  errorHandler = errorMiddleware.errorHandler;
  notFoundHandler = errorMiddleware.notFoundHandler;
} catch (error) {
  console.warn('⚠️ Error handler middleware not found, using fallback');
  errorHandler = (err, req, res, next) => {
    res.status(500).json({ success: false, message: 'Internal server error' });
  };
  notFoundHandler = (req, res) => {
    res.status(404).json({ success: false, message: 'Route not found' });
  };
}

// Import routes
let authRoutes, categoryRoutes, productRoutes, pointRoutes, leaderboardRoutes, userRoutes;

try {
  authRoutes = require('./routes/auth');
} catch (error) {
  console.warn('⚠️ Auth routes not found');
  authRoutes = null;
}

try {
  categoryRoutes = require('./routes/category');
} catch (error) {
  console.warn('⚠️ Category routes not found');
  categoryRoutes = null;
}

try {
  productRoutes = require('./routes/product');
} catch (error) {
  console.warn('⚠️ Product routes not found');
  productRoutes = null;
}

try {
  pointRoutes = require('./routes/point');
} catch (error) {
  console.warn('⚠️ Point routes not found');
  pointRoutes = null;
}

try {
  userRoutes = require('./routes/user');
  console.log('✅ User routes loaded successfully');
} catch (error) {
  console.log('⚠️ User routes not found, skipping user management endpoints');
  console.log('   Error:', error.message);
  userRoutes = null;
}

try {
  leaderboardRoutes = require('./routes/leaderboard');
  console.log('✅ Leaderboard routes loaded successfully');
} catch (error) {
  console.log('⚠️ Leaderboard routes not found, skipping leaderboard endpoints');
  console.log('   Error:', error.message);
  leaderboardRoutes = null;
}

// Create Express app
const app = express();

// Trust proxy (important for rate limiting and IP detection)
app.set('trust proxy', 1);

// Security middleware
app.use(helmet(helmetOptions));
app.use(cors(corsOptions));

// Rate limiting
app.use(generalLimiter);

// Serve static files for uploads
app.use('/uploads', express.static('uploads', {
  maxAge: '1d', // Cache for 1 day
  etag: true,
  lastModified: true
}));

// Body parsing middleware
app.use(express.json({ 
  limit: '10mb',
  verify: (req, res, buf) => {
    // Store raw body for webhook verification if needed
    req.rawBody = buf;
  }
}));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cookieParser());

// Data sanitization middleware
app.use(mongoSanitize()); // Remove NoSQL injection attempts
app.use((req, res, next) => {
  // XSS protection for request body
  if (req.body) {
    req.body = JSON.parse(xss(JSON.stringify(req.body)));
  }
  next();
});

// Session configuration
const sessionStore = new SequelizeStore({
  db: sequelize,
  checkExpirationInterval: 15 * 60 * 1000, // Clean up expired sessions every 15 minutes
  expiration: 24 * 60 * 60 * 1000 // Session expires after 24 hours
});

app.use(session({
  secret: process.env.SESSION_SECRET || 'fallback-secret-key',
  store: sessionStore,
  resave: false,
  saveUninitialized: false,
  name: 'sessionId', // Don't use default session name
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: parseInt(process.env.SESSION_MAX_AGE) || 24 * 60 * 60 * 1000, // 24 hours
    sameSite: 'strict'
  }
}));

// Initialize Passport
app.use(passport.initialize());
app.use(passport.session());

// Request logging middleware
app.use(requestLogger);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({
    success: true,
    message: 'Server is running',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    version: process.env.npm_package_version || '1.0.0'
  });
});

// API routes
const API_PREFIX = process.env.API_PREFIX || '/api/v1';

// Mount routes with error handling
if (authRoutes) {
  app.use(`${API_PREFIX}/auth`, authRoutes);
  console.log(`✅ Auth routes mounted at ${API_PREFIX}/auth`);
} else {
  console.log('❌ Auth routes not available');
}

if (userRoutes) {
  app.use(`${API_PREFIX}/users`, userRoutes);
  console.log(`✅ User routes mounted at ${API_PREFIX}/users`);
} else {
  console.log('❌ User routes not available');
  // Create a fallback route that explains the issue
  app.use(`${API_PREFIX}/users`, (req, res) => {
    res.status(501).json({
      success: false,
      message: 'User management endpoints are not available',
      error: 'User routes could not be loaded',
      suggestion: 'Please check if routes/user.js exists and is properly configured'
    });
  });
}

if (categoryRoutes) {
  app.use(`${API_PREFIX}/categories`, categoryRoutes);
  console.log(`✅ Category routes mounted at ${API_PREFIX}/categories`);
}

if (productRoutes) {
  app.use(`${API_PREFIX}/products`, productRoutes);
  console.log(`✅ Product routes mounted at ${API_PREFIX}/products`);
}

if (pointRoutes) {
  app.use(`${API_PREFIX}/points`, pointRoutes);
  console.log(`✅ Point routes mounted at ${API_PREFIX}/points`);
}

if (leaderboardRoutes) {
  app.use(`${API_PREFIX}/leaderboard`, leaderboardRoutes);
  console.log(`✅ Leaderboard routes mounted at ${API_PREFIX}/leaderboard`);
} else {
  console.log('❌ Leaderboard routes not available');
}

// Root endpoint
app.get('/', (req, res) => {
  const endpoints = {
    health: '/health'
  };

  if (authRoutes) endpoints.auth = `${API_PREFIX}/auth`;
  if (userRoutes) endpoints.users = `${API_PREFIX}/users`;
  if (categoryRoutes) endpoints.categories = `${API_PREFIX}/categories`;
  if (productRoutes) endpoints.products = `${API_PREFIX}/products`;
  if (pointRoutes) endpoints.points = `${API_PREFIX}/points`;
  if (leaderboardRoutes) endpoints.leaderboard = `${API_PREFIX}/leaderboard`; 

  endpoints.uploads = '/uploads';

  res.status(200).json({
    success: true,
    message: 'Secure Node.js Backend API',
    version: '1.0.0',
    documentation: `${req.protocol}://${req.get('host')}/docs`,
    endpoints,
    status: {
      authRoutes: !!authRoutes,
      userRoutes: !!userRoutes,
      categoryRoutes: !!categoryRoutes,
      productRoutes: !!productRoutes,
      pointRoutes: !!pointRoutes,
      leaderboardRoutes: !!leaderboardRoutes
    }
  });
});

// Error logging middleware
app.use(errorLogger);

// Handle 404 errors
app.use(notFoundHandler);

// Global error handler
app.use(errorHandler);

// Graceful shutdown handler
const gracefulShutdown = (signal) => {
  console.log(`Received ${signal}. Starting graceful shutdown...`);
  
  // Close server
  const server = app.get('server');
  if (server) {
    server.close(() => {
      console.log('HTTP server closed.');
      
      // Close database connection
      sequelize.close().then(() => {
        console.log('Database connection closed.');
        process.exit(0);
      }).catch((err) => {
        console.error('Error closing database connection:', err);
        process.exit(1);
      });
    });
  } else {
    process.exit(0);
  }
};

// Handle graceful shutdown
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

module.exports = app;


================================================
FILE: src/config/database.js
================================================
const { Sequelize } = require('sequelize');
const winston = require('winston');
require('dotenv').config();

// Database configuration with security best practices
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 3306,
  database: process.env.DB_NAME || 'secure_app_db',
  username: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD,
  dialect: process.env.DB_DIALECT || 'mysql',
  logging: process.env.NODE_ENV === 'development' ? console.log : false,
  pool: {
    max: 10,
    min: 0,
    acquire: 30000,
    idle: 10000
  },
  dialectOptions: {
    // Only valid MySQL2 options
    supportBigNumbers: true,
    bigNumberStrings: true,
    dateStrings: true,
    typeCast: true,
    
    // SSL configuration for production (fixed format)
    ...(process.env.NODE_ENV === 'production' && {
      ssl: {
        require: true,
        rejectUnauthorized: false
      }
    }),
    
    // Prevent SQL injection
    multipleStatements: false
  },
  define: {
    timestamps: true,
    underscored: true,
    paranoid: true, // Soft deletes
    freezeTableName: true,
    // Move charset/collate to define section
    charset: 'utf8mb4',
    collate: 'utf8mb4_unicode_ci'
  },
  // Timezone
  timezone: '+07:00'
};

// Create Sequelize instance
const sequelize = new Sequelize(
  dbConfig.database,
  dbConfig.username,
  dbConfig.password,
  dbConfig
);

// Test database connection
const testConnection = async () => {
  try {
    await sequelize.authenticate();
    winston.info('Database connection established successfully');
    return true;
  } catch (error) {
    winston.error('Unable to connect to the database:', error.message);
    return false;
  }
};

// Sync database and create tables
const syncDatabase = async (force = false) => {
  try {
    // Sync all models (create tables if they don't exist)
    await sequelize.sync({ 
      force, // Set to true to drop and recreate tables
      alter: !force // Alter existing tables to match models if force is false
    });
    
    winston.info('Database synchronized successfully');
    return true;
  } catch (error) {
    winston.error('Error synchronizing database:', error.message);
    return false;
  }
};

// Initialize database (create tables if they don't exist)
const initializeDatabase = async () => {
  try {
    // Test connection first
    const connected = await testConnection();
    if (!connected) {
      throw new Error('Cannot connect to database');
    }

    // Check if we need to create tables
    const shouldSync = process.env.DB_SYNC === 'true' || process.env.NODE_ENV === 'development';
    
    if (shouldSync) {
      await syncDatabase(process.env.DB_FORCE_SYNC === 'true');
    }
    
    return true;
  } catch (error) {
    winston.error('Database initialization failed:', error.message);
    return false;
  }
};

// Graceful shutdown
const gracefulShutdown = async () => {
  try {
    await sequelize.close();
    winston.info('Database connection closed successfully');
  } catch (error) {
    winston.error('Error closing database connection:', error.message);
  }
};

// Handle process termination
process.on('SIGINT', gracefulShutdown);
process.on('SIGTERM', gracefulShutdown);

module.exports = {
  sequelize,
  testConnection,
  syncDatabase,
  initializeDatabase,
  gracefulShutdown
};


================================================
FILE: src/config/passport.js
================================================
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const JwtStrategy = require('passport-jwt').Strategy;
const ExtractJwt = require('passport-jwt').ExtractJwt;
const User = require('../models/User');
const { logAuthAttempt, logSecurityEvent } = require('../utils/logger');

// JWT Strategy with token version validation
passport.use(new JwtStrategy({
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: process.env.JWT_SECRET,
  algorithms: ['HS256']
}, async (payload, done) => {
  try {
    const user = await User.findByPk(payload.userId);
    
    if (!user) {
      logAuthAttempt('jwt_validation', false, { 
        userId: payload.userId, 
        reason: 'User not found' 
      });
      return done(null, false);
    }

    if (!user.isActive) {
      logAuthAttempt('jwt_validation', false, { 
        userId: user.id, 
        reason: 'User inactive' 
      });
      return done(null, false);
    }

    // Check token version - NEW: Add token version validation
    const userTokenVersion = user.tokenVersion || 0;
    const decodedTokenVersion = payload.tokenVersion || 0;
    
    if (decodedTokenVersion !== userTokenVersion) {
      logAuthAttempt('jwt_validation', false, { 
        userId: user.id, 
        reason: 'Token version mismatch',
        decodedVersion: decodedTokenVersion,
        currentVersion: userTokenVersion
      });
      return done(null, false);
    }

    // Check if password was changed after token was issued - FIXED: Handle date properly
    if (user.passwordChangedAt && payload.iat) {
      let passwordChangedTimestamp;
      
      // Handle both Date object and string
      if (user.passwordChangedAt instanceof Date) {
        passwordChangedTimestamp = parseInt(user.passwordChangedAt.getTime() / 1000, 10);
      } else if (typeof user.passwordChangedAt === 'string') {
        passwordChangedTimestamp = parseInt(new Date(user.passwordChangedAt).getTime() / 1000, 10);
      } else {
        passwordChangedTimestamp = parseInt(user.passwordChangedAt, 10);
      }
      
      if (payload.iat < passwordChangedTimestamp) {
        logAuthAttempt('jwt_validation', false, { 
          userId: user.id, 
          reason: 'Password changed after token issued',
          tokenIat: payload.iat,
          passwordChangedAt: passwordChangedTimestamp
        });
        return done(null, false);
      }
    }

    logAuthAttempt('jwt_validation', true, { 
      userId: user.id,
      tokenVersion: userTokenVersion
    });

    return done(null, user);
  } catch (error) {
    logSecurityEvent('jwt_strategy_error', { 
      error: error.message,
      stack: error.stack
    });
    return done(error, false);
  }
}));

// Google OAuth Strategy - UPDATED: Initialize tokenVersion for new users
passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: process.env.GOOGLE_CALLBACK_URL,
  scope: ['profile', 'email']
}, async (accessToken, refreshToken, profile, done) => {
  try {
    // Check if user already exists with this Google ID
    let user = await User.findByGoogleId(profile.id);
    
    if (user) {
      // User exists, update profile info if needed
      await user.update({
        profilePicture: profile.photos?.[0]?.value || user.profilePicture,
        lastLogin: new Date()
      });
      
      logAuthAttempt('google_oauth', true, { 
        userId: user.id, 
        googleId: profile.id,
        tokenVersion: user.tokenVersion
      });
      
      return done(null, user);
    }

    // Check if user exists with same email
    user = await User.findOne({ where: { email: profile.emails[0].value } });
    
    if (user) {
      // Link Google account to existing user
      await user.update({
        googleId: profile.id,
        isVerified: true,
        emailVerifiedAt: new Date(),
        profilePicture: profile.photos?.[0]?.value || user.profilePicture,
        lastLogin: new Date()
      });
      
      logAuthAttempt('google_oauth_link', true, { 
        userId: user.id, 
        googleId: profile.id,
        tokenVersion: user.tokenVersion
      });
      
      return done(null, user);
    }

    // Create new user - UPDATED: Include tokenVersion initialization
    const newUser = await User.create({
      username: profile.displayName.replace(/\s+/g, '').toLowerCase() + Date.now(),
      email: profile.emails[0].value,
      googleId: profile.id,
      profilePicture: profile.photos?.[0]?.value,
      isVerified: true,
      emailVerifiedAt: new Date(),
      role: 'user',
      lastLogin: new Date(),
      tokenVersion: 0 // Initialize token version for new OAuth users
    });

    logAuthAttempt('google_oauth_signup', true, { 
      userId: newUser.id, 
      googleId: profile.id,
      email: profile.emails[0].value,
      tokenVersion: newUser.tokenVersion
    });

    return done(null, newUser);
  } catch (error) {
    logSecurityEvent('google_oauth_error', { 
      error: error.message,
      stack: error.stack,
      googleId: profile.id 
    });
    return done(error, null);
  }
}));

// Serialize user for session
passport.serializeUser((user, done) => {
  done(null, user.id);
});

// Deserialize user from session - UPDATED: Handle potential errors better
passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findByPk(id);
    
    if (!user) {
      logSecurityEvent('session_deserialize_failed', {
        userId: id,
        reason: 'User not found'
      });
      return done(null, false);
    }

    if (!user.isActive) {
      logSecurityEvent('session_deserialize_failed', {
        userId: id,
        reason: 'User inactive'
      });
      return done(null, false);
    }

    done(null, user);
  } catch (error) {
    logSecurityEvent('session_deserialize_error', {
      userId: id,
      error: error.message,
      stack: error.stack
    });
    done(error, null);
  }
});

module.exports = passport;


================================================
FILE: src/config/security.js
================================================
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const slowDown = require('express-slow-down');

// CORS configuration
const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests from specific origins or no origin (for mobile apps)
    const allowedOrigins = [
      process.env.FRONTEND_URL,
      'http://localhost:3000',
      'http://localhost:3001',
      'http://127.0.0.1:3000',
      'http://127.0.0.1:3001'
    ].filter(Boolean);

    // Allow requests with no origin (mobile apps, etc.)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};

// Helmet configuration for security headers
const helmetOptions = {
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false,
  hsts: {
    maxAge: parseInt(process.env.HELMET_HSTS_MAX_AGE) || 31536000,
    includeSubDomains: true,
    preload: true
  }
};

// Rate limiting configuration
const createRateLimit = (windowMs, max, message) => {
  return rateLimit({
    windowMs,
    max,
    message: {
      error: message || 'Too many requests, please try again later.',
      retryAfter: Math.ceil(windowMs / 1000)
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      res.status(429).json({
        success: false,
        error: 'Too many requests',
        message: 'Rate limit exceeded',
        retryAfter: Math.ceil(windowMs / 1000)
      });
    }
  });
};

// General rate limiting
const generalLimiter = createRateLimit(
  parseInt(process.env.RATE_LIMIT_WINDOW) || 15 * 60 * 1000, // 15 minutes
  parseInt(process.env.RATE_LIMIT_MAX) || 100, // limit each IP to 100 requests per windowMs
  'Too many requests from this IP, please try again later.'
);

// Auth endpoints rate limiting (more restrictive)
const authLimiter = createRateLimit(
  15 * 60 * 1000, // 15 minutes
  10, // limit each IP to 10 requests per windowMs
  'Too many authentication attempts, please try again later.'
);

// Login rate limiting (very restrictive)
const loginLimiter = createRateLimit(
  15 * 60 * 1000, // 15 minutes
  5, // limit each IP to 5 login attempts per windowMs
  'Too many login attempts, please try again later.'
);

// Speed limiter for auth endpoints
const authSpeedLimiter = slowDown({
  windowMs: 15 * 60 * 1000, // 15 minutes
  delayAfter: 3, // allow 3 requests per windowMs without delay
  delayMs: () => 500, // add 500ms delay per request after delayAfter
  maxDelayMs: 10000, // maximum delay of 10 seconds
  validate: {
    delayMs: false // disable the warning message
  }
});

// Password validation rules
const passwordRules = {
  minLength: 8,
  maxLength: 128,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
  specialChars: '!@#$%^&*()_+-=[]{}|;:,.<>?',
  blacklistedPasswords: [
    'password', 'password123', '123456', '123456789', 'qwerty',
    'abc123', 'password1', 'admin', 'admin123', 'root', 'user'
  ]
};

// Input sanitization patterns
const sanitizationPatterns = {
  // Remove potentially dangerous characters
  dangerous: /[<>\"'%;()&+]/g,
  // SQL injection patterns
  sqlInjection: /(\b(union|select|insert|update|delete|drop|create|alter|exec|execute)\b)|(-{2})|\/\*|\*\//gi,
  // XSS patterns
  xss: /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
  // NoSQL injection patterns
  nosqlInjection: /(\$where|\$ne|\$in|\$nin|\$gt|\$lt|\$gte|\$lte|\$exists|\$regex)/gi
};

// Validation helpers
const validatePassword = (password) => {
  const errors = [];
  
  if (password.length < passwordRules.minLength) {
    errors.push(`Password must be at least ${passwordRules.minLength} characters long`);
  }
  
  if (password.length > passwordRules.maxLength) {
    errors.push(`Password must be no more than ${passwordRules.maxLength} characters long`);
  }
  
  if (passwordRules.requireUppercase && !/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  if (passwordRules.requireLowercase && !/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  if (passwordRules.requireNumbers && !/\d/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  if (passwordRules.requireSpecialChars && !new RegExp(`[${passwordRules.specialChars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}]`).test(password)) {
    errors.push('Password must contain at least one special character');
  }
  
  if (passwordRules.blacklistedPasswords.includes(password.toLowerCase())) {
    errors.push('Password is too common and not allowed');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Input sanitization function
const sanitizeInput = (input) => {
  if (typeof input !== 'string') return input;
  
  return input
    .replace(sanitizationPatterns.dangerous, '')
    .replace(sanitizationPatterns.sqlInjection, '')
    .replace(sanitizationPatterns.xss, '')
    .replace(sanitizationPatterns.nosqlInjection, '')
    .trim();
};

// Additional security functions
const generateSecureToken = (length = 32) => {
  const crypto = require('crypto');
  return crypto.randomBytes(length).toString('hex');
};

const hashSensitiveData = (data, algorithm = 'sha256') => {
  const crypto = require('crypto');
  return crypto.createHash(algorithm).update(data).digest('hex');
};

const isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const isValidPhoneNumber = (phone) => {
  const phoneRegex = /^[+]?[\d\s\-()]+$/;
  return phoneRegex.test(phone);
};

const isValidUrl = (url) => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};

// IP whitelist/blacklist functions
const isIPWhitelisted = (ip) => {
  const whitelist = process.env.IP_WHITELIST ? process.env.IP_WHITELIST.split(',') : [];
  return whitelist.length === 0 || whitelist.includes(ip);
};

const isIPBlacklisted = (ip) => {
  const blacklist = process.env.IP_BLACKLIST ? process.env.IP_BLACKLIST.split(',') : [];
  return blacklist.includes(ip);
};

// File upload security
const allowedFileTypes = {
  images: ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'],
  documents: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
  archives: ['application/zip', 'application/x-rar-compressed', 'application/x-7z-compressed']
};

const isAllowedFileType = (mimetype, category = 'images') => {
  return allowedFileTypes[category] && allowedFileTypes[category].includes(mimetype.toLowerCase());
};

const getFileSizeLimit = (category = 'images') => {
  const limits = {
    images: 5 * 1024 * 1024, // 5MB
    documents: 10 * 1024 * 1024, // 10MB
    archives: 50 * 1024 * 1024 // 50MB
  };
  return limits[category] || limits.images;
};

// Security headers middleware
const securityHeaders = (req, res, next) => {
  // Additional security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  
  // Remove server signature
  res.removeHeader('X-Powered-By');
  
  next();
};

// Request logging for security monitoring
const securityLogger = (req, res, next) => {
  const startTime = Date.now();
  const originalEnd = res.end;
  
  res.end = function(...args) {
    const duration = Date.now() - startTime;
    const logData = {
      method: req.method,
      url: req.url,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      statusCode: res.statusCode,
      duration,
      timestamp: new Date().toISOString()
    };
    
    // Log suspicious activities
    if (res.statusCode === 401 || res.statusCode === 403 || res.statusCode === 429) {
      console.warn('Security Alert:', logData);
    }
    
    originalEnd.apply(this, args);
  };
  
  next();
};

module.exports = {
  corsOptions,
  helmetOptions,
  generalLimiter,
  authLimiter,
  loginLimiter,
  authSpeedLimiter,
  passwordRules,
  validatePassword,
  sanitizeInput,
  sanitizationPatterns,
  generateSecureToken,
  hashSensitiveData,
  isValidEmail,
  isValidPhoneNumber,
  isValidUrl,
  isIPWhitelisted,
  isIPBlacklisted,
  allowedFileTypes,
  isAllowedFileType,
  getFileSizeLimit,
  securityHeaders,
  securityLogger
};


================================================
FILE: src/controllers/authController.js
================================================
const authService = require('../services/authService');
const { 
  successResponse, 
  errorResponse, 
  asyncHandler,
  HTTP_STATUS,
  SUCCESS_CODES,
  ERROR_CODES 
} = require('../utils/response');
const { logSecurityEvent } = require('../utils/logger');

class AuthController {
  /**
   * Register new user
   */
  register = asyncHandler(async (req, res) => {
    const { username, email, phoneNumber, password } = req.body;
    const ipAddress = req.ip || req.connection.remoteAddress;

    try {
      const result = await authService.register({
        username,
        email,
        phoneNumber,
        password
      });

      logSecurityEvent('user_registration_success', {
        userId: result.user.id,
        username: result.user.username,
        email: result.user.email,
        ipAddress,
        requiresVerification: true
      });

      res.status(HTTP_STATUS.CREATED.code).json(
        successResponse(
          result.message,
          {
            user: result.user,
            requiresEmailVerification: true
          },
          null,
          SUCCESS_CODES.USER_CREATED
        )
      );
    } catch (error) {
      logSecurityEvent('user_registration_failed', {
        username,
        email,
        error: error.message,
        ipAddress
      });

      if (error.message.includes('already exists')) {
        return res.status(HTTP_STATUS.CONFLICT.code).json(
          errorResponse(error.message, ERROR_CODES.RESOURCE_ALREADY_EXISTS)
        );
      }

      res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse(error.message, ERROR_CODES.VALIDATION_ERROR)
      );
    }
  });

  /**
   * Login user
   */
  login = asyncHandler(async (req, res) => {
    const { identifier, password } = req.body;
    const ipAddress = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('User-Agent');

    try {
      const result = await authService.login(identifier, password, ipAddress);

      // Set secure HTTP-only cookie for refresh token
      res.cookie('refreshToken', result.tokens.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Login successful',
          {
            user: result.user,
            accessToken: result.tokens.accessToken,
            dailyLoginBonus: result.dailyLoginBonus || null
          },
          null,
          SUCCESS_CODES.LOGIN_SUCCESS
        )
      );
    } catch (error) {
      logSecurityEvent('login_failed', {
        identifier,
        error: error.message,
        ipAddress,
        userAgent
      });

      if (error.message.includes('locked')) {
        return res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
          errorResponse(error.message, ERROR_CODES.ACCOUNT_LOCKED)
        );
      }

      if (error.message.includes('verify your email')) {
        return res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
          errorResponse(error.message, ERROR_CODES.EMAIL_NOT_VERIFIED)
        );
      }

      if (error.message.includes('deactivated')) {
        return res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
          errorResponse(
            'Your account has been deactivated. For more information about your account status, please contact: support@sijago.ai', 
            ERROR_CODES.ACCOUNT_DISABLED,
            { 
              supportContact: 'support@sijago.ai',
              contactReason: 'Account deactivated - requires support assistance'
            }
          )
        );
      }

      res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
        errorResponse('Invalid credentials', ERROR_CODES.INVALID_CREDENTIALS)
      );
    }
  });

  /**
   * Refresh access token
   */
  refreshToken = asyncHandler(async (req, res) => {
    const { refreshToken } = req.body;
    const cookieRefreshToken = req.cookies?.refreshToken;
    const tokenToUse = refreshToken || cookieRefreshToken;

    if (!tokenToUse) {
      return res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
        errorResponse('Refresh token required', ERROR_CODES.MISSING_TOKEN)
      );
    }

    try {
      const result = await authService.refreshToken(tokenToUse);

      // Update refresh token cookie
      res.cookie('refreshToken', result.tokens.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Token refreshed successfully',
          {
            user: result.user,
            accessToken: result.tokens.accessToken
          },
          null,
          SUCCESS_CODES.TOKEN_REFRESHED
        )
      );
    } catch (error) {
      // Clear invalid refresh token cookie
      res.clearCookie('refreshToken');

      res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
        errorResponse('Invalid refresh token', ERROR_CODES.INVALID_TOKEN)
      );
    }
  });

  /**
   * Logout user
   */
  logout = asyncHandler(async (req, res) => {
    try {
      console.log('🚪 Logout request for user:', req.user.id);
      
      // authService.logout now handles token version increment internally
      await authService.logout(req.user);

      // Clear refresh token cookie
      res.clearCookie('refreshToken');

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Logout successful. All tokens have been invalidated.',
          null,
          null,
          SUCCESS_CODES.LOGOUT_SUCCESS
        )
      );
    } catch (error) {
      console.log('❌ Logout failed:', error.message);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Logout failed', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Change password
   */
  changePassword = asyncHandler(async (req, res) => {
    const { currentPassword, newPassword } = req.body;

    try {
      await authService.changePassword(req.user, currentPassword, newPassword);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Password changed successfully',
          null,
          null,
          SUCCESS_CODES.PASSWORD_CHANGED
        )
      );
    } catch (error) {
      if (error.message.includes('incorrect')) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse(error.message, ERROR_CODES.INVALID_CREDENTIALS)
        );
      }

      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Password change failed', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get current user profile (Enhanced)
   */
  getProfile = asyncHandler(async (req, res) => {
    try {
      // Get user with additional computed fields
      const user = req.user;
      
      // Create enhanced profile data
      const profileData = {
        ...user.toSafeJSON(),
        // Add computed fields
        isLocked: user.isLocked(),
        canEarnPoints: user.canEarnPoints(),
        accountAge: Math.floor((new Date() - user.createdAt) / (1000 * 60 * 60 * 24)), // days
        // Add verification status
        verificationStatus: {
          email: user.isVerified,
          twoFactor: user.twoFactorEnabled
        },
        // Add account metrics
        metrics: {
          totalPoints: user.currentPoints,
          lastLogin: user.lastLogin,
          memberSince: user.createdAt
        }
      };

      logSecurityEvent('profile_accessed', {
        userId: user.id,
        accessTime: new Date()
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Profile retrieved successfully',
          { user: profileData }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve profile', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Update user profile (Enhanced)
   */
  updateProfile = asyncHandler(async (req, res) => {
    const { username, email, phoneNumber, profilePicture } = req.body;
    const updateData = {};

    // Only include fields that are provided
    if (username) updateData.username = username.toLowerCase();
    if (email) updateData.email = email.toLowerCase();
    if (phoneNumber !== undefined) updateData.phoneNumber = phoneNumber;
    if (profilePicture !== undefined) updateData.profilePicture = profilePicture;

    try {
      // Check for duplicate username/email if they're being updated
      if (updateData.username || updateData.email) {
        const User = require('../models/User');
        const existingUser = await User.findOne({
          where: {
            [User.sequelize.Sequelize.Op.and]: [
              { id: { [User.sequelize.Sequelize.Op.ne]: req.user.id } },
              {
                [User.sequelize.Sequelize.Op.or]: [
                  updateData.username ? { username: updateData.username } : null,
                  updateData.email ? { email: updateData.email } : null
                ].filter(Boolean)
              }
            ]
          }
        });

        if (existingUser) {
          const field = existingUser.username === updateData.username ? 'username' : 'email';
          return res.status(HTTP_STATUS.CONFLICT.code).json(
            errorResponse(`This ${field} is already taken`, ERROR_CODES.RESOURCE_ALREADY_EXISTS)
          );
        }
      }

      // If email is being updated, mark as unverified and send verification
      if (updateData.email && updateData.email !== req.user.email) {
        updateData.isVerified = false;
        updateData.emailVerifiedAt = null;
        
        // Generate new verification token
        const verificationToken = req.user.generateEmailVerificationToken();
        updateData.emailVerificationToken = req.user.emailVerificationToken;
        updateData.emailVerificationExpires = req.user.emailVerificationExpires;
        updateData.emailVerificationSentAt = req.user.emailVerificationSentAt;
        
        // Send verification email to new address
        try {
          const emailService = require('../services/emailService');
          const tempUser = { ...req.user.toJSON(), ...updateData };
          await emailService.sendEmailVerification(tempUser, verificationToken);
        } catch (emailError) {
          logSecurityEvent('email_verification_send_failed', {
            userId: req.user.id,
            newEmail: updateData.email,
            error: emailError.message
          });
        }
      }

      await req.user.update(updateData);

      // Create enhanced response data
      const responseData = {
        ...req.user.toSafeJSON(),
        isLocked: req.user.isLocked(),
        canEarnPoints: req.user.canEarnPoints(),
        accountAge: Math.floor((new Date() - req.user.createdAt) / (1000 * 60 * 60 * 24))
      };

      logSecurityEvent('profile_updated', {
        userId: req.user.id,
        updatedFields: Object.keys(updateData),
        emailChanged: !!updateData.email
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          updateData.email ? 
            'Profile updated successfully. Please verify your new email address.' : 
            'Profile updated successfully',
          { 
            user: responseData,
            emailVerificationRequired: !!updateData.email
          },
          null,
          SUCCESS_CODES.PROFILE_UPDATED
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse(error.message, ERROR_CODES.VALIDATION_ERROR)
      );
    }
  });

  /**
   * Google OAuth callback
   */
  googleCallback = asyncHandler(async (req, res) => {
    const user = req.user;
    
    if (!user) {
      return res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);
    }

    try {
      // Generate tokens for the authenticated user
      const tokens = authService.generateTokens(user);
      
      // Save refresh token
      await user.setRefreshToken(tokens.refreshToken);

      // Set secure cookie
      res.cookie('refreshToken', tokens.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      // Redirect to frontend with access token
      res.redirect(`${process.env.FRONTEND_URL}/oauth/success?token=${tokens.accessToken}`);
    } catch (error) {
      logSecurityEvent('google_oauth_callback_error', {
        userId: user.id,
        error: error.message
      });
      
      res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_callback_failed`);
    }
  });

  /**
   * Verify email address
   */
  verifyEmail = asyncHandler(async (req, res) => {
    const { token, email } = req.query;

    if (!token || !email) {
      return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse('Token and email are required', ERROR_CODES.MISSING_REQUIRED_FIELD)
      );
    }

    try {
      const result = await authService.verifyEmail(token, email);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          result.message,
          {
            user: result.user,
            alreadyVerified: result.alreadyVerified || false,
            pointsAwarded: result.pointsAwarded || null
          },
          null,
          SUCCESS_CODES.EMAIL_VERIFIED
        )
      );
    } catch (error) {
      if (error.message.includes('expired')) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse(error.message, ERROR_CODES.TOKEN_EXPIRED)
        );
      }

      if (error.message.includes('Invalid')) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse(error.message, ERROR_CODES.INVALID_TOKEN)
        );
      }

      res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse(error.message, ERROR_CODES.VALIDATION_ERROR)
      );
    }
  });

  /**
   * Resend email verification
   */
  resendEmailVerification = asyncHandler(async (req, res) => {
    const { email } = req.body;

    if (!email) {
      return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse('Email is required', ERROR_CODES.MISSING_REQUIRED_FIELD)
      );
    }

    try {
      const result = await authService.resendEmailVerification(email);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          result.message,
          null,
          null,
          SUCCESS_CODES.EMAIL_VERIFICATION_SENT
        )
      );
    } catch (error) {
      if (error.message.includes('wait')) {
        return res.status(HTTP_STATUS.TOO_MANY_REQUESTS.code).json(
          errorResponse(error.message, ERROR_CODES.RATE_LIMIT_EXCEEDED)
        );
      }

      res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse(error.message, ERROR_CODES.VALIDATION_ERROR)
      );
    }
  });

  /**
   * Get user profile by ID (Own profile or Admin access)
   */
  getUserProfileById = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const requestingUserId = req.user.id;
    const isAdmin = req.user.role === 'admin';

    // Check if user is accessing their own profile or is admin
    if (!isAdmin && parseInt(id) !== requestingUserId) {
      logSecurityEvent('unauthorized_profile_access_attempt', {
        requestingUserId,
        targetUserId: id,
        ipAddress: req.ip
      });
      
      return res.status(HTTP_STATUS.FORBIDDEN.code).json(
        errorResponse('Access denied. You can only view your own profile.', ERROR_CODES.ACCESS_DENIED)
      );
    }

    try {
      const User = require('../models/User');
      const user = await User.findByPk(id, {
        attributes: { exclude: ['passwordHash', 'refreshTokenHash', 'twoFactorSecret', 'emailVerificationToken'] },
        paranoid: false // Include soft deleted users for admin
      });

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // For regular users viewing their own profile, ensure account is active
      if (!isAdmin && !user.isActive) {
        return res.status(HTTP_STATUS.FORBIDDEN.code).json(
          errorResponse('Account is deactivated', ERROR_CODES.ACCOUNT_DISABLED)
        );
      }

      // Create profile data based on access level
      let profileData = user.toJSON();
      
      // For non-admin users viewing their own profile, hide admin-only fields
      if (!isAdmin) {
        delete profileData.loginAttempts;
        delete profileData.lockedUntil;
        delete profileData.tokenVersion;
        delete profileData.deletedAt;
        delete profileData.emailVerificationToken;
        delete profileData.emailVerificationExpires;
        delete profileData.emailVerificationSentAt;
      }

      // Add computed fields
      profileData.isLocked = user.isLocked();
      profileData.canEarnPoints = user.canEarnPoints();
      profileData.accountAge = Math.floor((new Date() - user.createdAt) / (1000 * 60 * 60 * 24));

      // Add verification status
      profileData.verificationStatus = {
        email: user.isVerified,
        twoFactor: user.twoFactorEnabled
      };

      // Add account metrics
      profileData.metrics = {
        totalPoints: user.currentPoints,
        lastLogin: user.lastLogin,
        memberSince: user.createdAt
      };

      logSecurityEvent('profile_accessed_by_id', {
        targetUserId: id,
        accessedBy: requestingUserId,
        isAdminAccess: isAdmin,
        isOwnProfile: parseInt(id) === requestingUserId
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          isAdmin && parseInt(id) !== requestingUserId ? 
            'User profile retrieved successfully (Admin access)' : 
            'Your profile retrieved successfully',
          { user: profileData }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve profile', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get public user profile by ID (Limited public information)
   */
  getPublicProfile = asyncHandler(async (req, res) => {
    const { id } = req.params;

    try {
      const User = require('../models/User');
      const user = await User.findByPk(id, {
        attributes: [
          'id', 
          'username', 
          'profilePicture', 
          'createdAt',
          'isActive',
          'isVerified'
        ]
      });

      if (!user || !user.isActive || !user.isVerified) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found or profile not public', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // Create limited public profile data (no sensitive information)
      const publicProfile = {
        id: user.id,
        username: user.username,
        profilePicture: user.profilePicture,
        memberSince: user.createdAt,
        isVerified: user.isVerified,
        accountAge: Math.floor((new Date() - user.createdAt) / (1000 * 60 * 60 * 24)) // days
      };

      // Log public profile access (optional, for analytics)
      logSecurityEvent('public_profile_accessed', {
        targetUserId: id,
        accessorIp: req.ip,
        userAgent: req.get('User-Agent')
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Public profile retrieved successfully',
          { user: publicProfile }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve public profile', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });
}

module.exports = new AuthController();


================================================
FILE: src/controllers/categoryController.js
================================================
const categoryService = require('../services/categoryService');
const { 
  successResponse, 
  errorResponse, 
  asyncHandler,
  HTTP_STATUS,
  SUCCESS_CODES,
  ERROR_CODES,
  createPaginationMeta
} = require('../utils/response');
const { getFileUrl } = require('../middleware/upload');

class CategoryController {
  /**
   * Get all categories (Admin only)
   */
  getAllCategories = asyncHandler(async (req, res) => {
    const {
      page = 1,
      limit = 10,
      search = '',
      isActive,
      sortBy = 'sortOrder',
      sortOrder = 'ASC',
      includeProductCount = false
    } = req.query;

    const result = await categoryService.getAllCategories({
      page: parseInt(page),
      limit: parseInt(limit),
      search,
      isActive: isActive !== undefined ? isActive === 'true' : undefined,
      sortBy,
      sortOrder,
      includeProductCount: includeProductCount === 'true'
    });

    // Add image URLs
    result.categories = result.categories.map(category => ({
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    }));

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Categories retrieved successfully',
        result.categories,
        createPaginationMeta(
          result.pagination.currentPage,
          result.pagination.itemsPerPage,
          result.pagination.totalItems,
          result.pagination.totalPages
        )
      )
    );
  });

  /**
   * Get active categories (Public)
   */
  getActiveCategories = asyncHandler(async (req, res) => {
    const categories = await categoryService.getActiveCategories();

    const categoriesWithImageUrl = categories.map(category => ({
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    }));

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Active categories retrieved successfully',
        categoriesWithImageUrl
      )
    );
  });

  /**
   * Get category by ID
   */
  getCategoryById = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { includeProducts = false } = req.query;

    const category = await categoryService.getCategoryById(
      parseInt(id),
      includeProducts === 'true'
    );

    const categoryData = {
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    };

    // Add image URLs to products if included
    if (categoryData.products) {
      categoryData.products = categoryData.products.map(product => ({
        ...product,
        imageUrl: product.image ? getFileUrl(product.image, 'products') : null
      }));
    }

    res.status(HTTP_STATUS.OK.code).json(
      successResponse('Category retrieved successfully', categoryData)
    );
  });

  /**
   * Get category by slug (Public)
   */
  getCategoryBySlug = asyncHandler(async (req, res) => {
    const { slug } = req.params;
    const { includeProducts = false } = req.query;

    const category = await categoryService.getCategoryBySlug(
      slug,
      includeProducts === 'true'
    );

    const categoryData = {
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    };

    // Add image URLs to products if included
    if (categoryData.products) {
      categoryData.products = categoryData.products.map(product => ({
        ...product,
        imageUrl: product.image ? getFileUrl(product.image, 'products') : null
      }));
    }

    res.status(HTTP_STATUS.OK.code).json(
      successResponse('Category retrieved successfully', categoryData)
    );
  });

  /**
   * Create new category (Admin only)
   */
  createCategory = asyncHandler(async (req, res) => {
    const categoryData = req.body;
    const userId = req.user.id;

    const category = await categoryService.createCategory(categoryData, userId);

    const categoryWithImageUrl = {
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    };

    res.status(HTTP_STATUS.CREATED.code).json(
      successResponse(
        'Category created successfully',
        categoryWithImageUrl,
        null,
        SUCCESS_CODES.RESOURCE_CREATED
      )
    );
  });

  /**
   * Update category (Admin only)
   */
  updateCategory = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const updateData = req.body;
    const userId = req.user.id;

    const category = await categoryService.updateCategory(
      parseInt(id),
      updateData,
      userId
    );

    const categoryWithImageUrl = {
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Category updated successfully',
        categoryWithImageUrl,
        null,
        SUCCESS_CODES.RESOURCE_UPDATED
      )
    );
  });

  /**
   * Soft delete category (Admin only)
   */
  deleteCategory = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    await categoryService.deleteCategory(parseInt(id), userId);

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Category deleted successfully',
        null,
        null,
        SUCCESS_CODES.RESOURCE_DELETED
      )
    );
  });

  /**
   * Force delete category (Admin only) - Permanent deletion
   */
  forceDeleteCategory = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    await categoryService.forceDeleteCategory(parseInt(id), userId);

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Category permanently deleted successfully',
        null,
        null,
        SUCCESS_CODES.RESOURCE_DELETED
      )
    );
  });

  /**
   * Restore soft deleted category (Admin only)
   */
  restoreCategory = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    const category = await categoryService.restoreCategory(parseInt(id), userId);

    const categoryWithImageUrl = {
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Category restored successfully',
        categoryWithImageUrl,
        null,
        SUCCESS_CODES.RESOURCE_UPDATED
      )
    );
  });

  /**
   * Upload category image (Admin only)
   */
  uploadCategoryImage = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    if (!req.file) {
      return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse('No image file provided', ERROR_CODES.MISSING_REQUIRED_FIELD)
      );
    }

    try {
      const category = await categoryService.uploadCategoryImage(
        parseInt(id),
        req.file.filename,
        userId
      );

      const categoryWithImageUrl = {
        ...category.toJSON(),
        imageUrl: getFileUrl(category.image, 'categories')
      };

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Category image uploaded successfully',
          categoryWithImageUrl,
          null,
          SUCCESS_CODES.FILE_UPLOADED
        )
      );
    } catch (error) {
      // Delete uploaded file if database operation fails
      const fs = require('fs');
      if (fs.existsSync(`uploads/categories/${req.file.filename}`)) {
        fs.unlinkSync(`uploads/categories/${req.file.filename}`);
      }
      throw error;
    }
  });

  /**
   * Toggle category status (Admin only)
   */
  toggleCategoryStatus = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    const category = await categoryService.toggleCategoryStatus(
      parseInt(id),
      userId
    );

    const categoryWithImageUrl = {
      ...category.toJSON(),
      imageUrl: category.image ? getFileUrl(category.image, 'categories') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        `Category ${category.isActive ? 'activated' : 'deactivated'} successfully`,
        categoryWithImageUrl,
        null,
        SUCCESS_CODES.STATUS_UPDATED
      )
    );
  });
}

module.exports = new CategoryController();


================================================
FILE: src/controllers/leaderboardController.js
================================================
const leaderboardService = require('../services/leaderboardService');
const { 
  successResponse, 
  errorResponse, 
  asyncHandler,
  HTTP_STATUS,
  SUCCESS_CODES,
  ERROR_CODES 
} = require('../utils/response');

class LeaderboardController {
  /**
   * Get daily leaderboard (top 10)
   * @route GET /api/v1/leaderboard/daily
   * @access Public/Private
   */
  getDailyLeaderboard = asyncHandler(async (req, res) => {
    try {
      const { date } = req.query;
      const targetDate = date ? new Date(date) : new Date();

      const leaderboard = await leaderboardService.getDailyLeaderboard(targetDate);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Daily leaderboard retrieved successfully',
          leaderboard
        )
      );
    } catch (error) {
      console.error('Error getting daily leaderboard:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve daily leaderboard', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get monthly leaderboard (top 10)
   * @route GET /api/v1/leaderboard/monthly
   * @access Public/Private
   */
  getMonthlyLeaderboard = asyncHandler(async (req, res) => {
    try {
      const { year, month } = req.query;
      const targetDate = new Date();
      
      if (year && month) {
        targetDate.setFullYear(parseInt(year));
        targetDate.setMonth(parseInt(month) - 1); // month is 0-indexed
      }

      const leaderboard = await leaderboardService.getMonthlyLeaderboard(
        targetDate.getFullYear(),
        targetDate.getMonth() + 1
      );

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Monthly leaderboard retrieved successfully',
          leaderboard
        )
      );
    } catch (error) {
      console.error('Error getting monthly leaderboard:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve monthly leaderboard', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get all-time leaderboard (top 10)
   * @route GET /api/v1/leaderboard/all-time
   * @access Public/Private
   */
  getAllTimeLeaderboard = asyncHandler(async (req, res) => {
    try {
      const leaderboard = await leaderboardService.getAllTimeLeaderboard();

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'All-time leaderboard retrieved successfully',
          leaderboard
        )
      );
    } catch (error) {
      console.error('Error getting all-time leaderboard:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve all-time leaderboard', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get user's ranking in daily leaderboard
   * @route GET /api/v1/leaderboard/my-rank/daily
   * @access Private
   */
  getMyDailyRank = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { date } = req.query;
      const targetDate = date ? new Date(date) : new Date();

      const ranking = await leaderboardService.getUserDailyRanking(userId, targetDate);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User daily ranking retrieved successfully',
          ranking
        )
      );
    } catch (error) {
      console.error('Error getting user daily ranking:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve user daily ranking', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get user's ranking in monthly leaderboard
   * @route GET /api/v1/leaderboard/my-rank/monthly
   * @access Private
   */
  getMyMonthlyRank = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { year, month } = req.query;
      const targetDate = new Date();
      
      if (year && month) {
        targetDate.setFullYear(parseInt(year));
        targetDate.setMonth(parseInt(month) - 1);
      }

      const ranking = await leaderboardService.getUserMonthlyRanking(
        userId,
        targetDate.getFullYear(),
        targetDate.getMonth() + 1
      );

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User monthly ranking retrieved successfully',
          ranking
        )
      );
    } catch (error) {
      console.error('Error getting user monthly ranking:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve user monthly ranking', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get user's ranking in all-time leaderboard
   * @route GET /api/v1/leaderboard/my-rank/all-time
   * @access Private
   */
  getMyAllTimeRank = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const ranking = await leaderboardService.getUserAllTimeRanking(userId);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User all-time ranking retrieved successfully',
          ranking
        )
      );
    } catch (error) {
      console.error('Error getting user all-time ranking:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve user all-time ranking', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get comprehensive leaderboard data
   * @route GET /api/v1/leaderboard/comprehensive
   * @access Private
   */
  getComprehensiveLeaderboard = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { date, year, month } = req.query;
      
      const targetDate = date ? new Date(date) : new Date();
      const targetYear = year ? parseInt(year) : new Date().getFullYear();
      const targetMonth = month ? parseInt(month) : new Date().getMonth() + 1;

      const comprehensive = await leaderboardService.getComprehensiveLeaderboard(
        userId,
        targetDate,
        targetYear,
        targetMonth
      );

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Comprehensive leaderboard retrieved successfully',
          comprehensive
        )
      );
    } catch (error) {
      console.error('Error getting comprehensive leaderboard:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve comprehensive leaderboard', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get leaderboard statistics
   * @route GET /api/v1/leaderboard/statistics
   * @access Private (Admin only)
   */
  getLeaderboardStatistics = asyncHandler(async (req, res) => {
    try {
      const statistics = await leaderboardService.getLeaderboardStatistics();

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Leaderboard statistics retrieved successfully',
          statistics
        )
      );
    } catch (error) {
      console.error('Error getting leaderboard statistics:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve leaderboard statistics', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });
}

module.exports = new LeaderboardController();


================================================
FILE: src/controllers/pointController.js
================================================
const pointService = require('../services/pointService');
const PointActivity = require('../models/PointActivity');
const PointTransaction = require('../models/PointTransaction');
const PointRedemption = require('../models/PointRedemption');
const User = require('../models/User');
const { 
  successResponse, 
  errorResponse, 
  asyncHandler,
  HTTP_STATUS,
  SUCCESS_CODES,
  ERROR_CODES 
} = require('../utils/response');
const { logSecurityEvent } = require('../utils/logger');

class PointController {
  /**
   * Get user's current points and summary
   */
  getMyPoints = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;

      // Get user's current points from user model
      const user = await User.findByPk(userId, {
        attributes: ['id', 'username', 'email', 'currentPoints']
      });

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.USER_NOT_FOUND)
        );
      }

      // Get detailed point summary from transactions
      const pointSummary = await pointService.getUserPointSummary(userId);

      // Get available activities
      const availableActivities = await pointService.getAvailableActivitiesForUser(userId);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Points retrieved successfully',
          {
            currentBalance: user.currentPoints,
            summary: pointSummary,
            availableActivities: availableActivities
          }
        )
      );
    } catch (error) {
      console.error('Error getting user points:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve points', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get user's point transaction history
   */
  getMyTransactionHistory = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { 
        page = 1, 
        limit = 20, 
        transactionType, 
        activityType,
        startDate,
        endDate
      } = req.query;

      const transactions = await PointTransaction.getUserTransactions(userId, {
        page: parseInt(page),
        limit: parseInt(limit),
        transactionType,
        activityType,
        startDate,
        endDate
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Transaction history retrieved successfully',
          {
            transactions: transactions.rows.map(tx => tx.toSafeJSON()),
            pagination: {
              currentPage: parseInt(page),
              totalPages: Math.ceil(transactions.count / parseInt(limit)),
              totalItems: transactions.count,
              itemsPerPage: parseInt(limit)
            }
          }
        )
      );
    } catch (error) {
      console.error('Error getting transaction history:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve transaction history', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Request point redemption
   */
  requestRedemption = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { 
        pointsToRedeem, 
        redemptionType, 
        redemptionDetails 
      } = req.body;

      // Get user's current points
      const user = await User.findByPk(userId);
      
      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.USER_NOT_FOUND)
        );
      }

      if (user.currentPoints < pointsToRedeem) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('Insufficient points balance', ERROR_CODES.INSUFFICIENT_BALANCE)
        );
      }

      // Calculate redemption value (example: 100 points = $1)
      const redemptionValue = pointsToRedeem / 100;

      // Create redemption request
      const redemption = await PointRedemption.create({
        userId: userId,
        pointsRedeemed: pointsToRedeem,
        redemptionType: redemptionType,
        redemptionValue: redemptionValue,
        redemptionDetails: redemptionDetails,
        status: 'pending'
      });

      logSecurityEvent('redemption_requested', {
        userId: userId,
        redemptionId: redemption.id,
        pointsRequested: pointsToRedeem,
        redemptionType: redemptionType
      });

      res.status(HTTP_STATUS.CREATED.code).json(
        successResponse(
          'Redemption request submitted successfully',
          {
            redemption: {
              id: redemption.id,
              pointsRedeemed: redemption.pointsRedeemed,
              redemptionType: redemption.redemptionType,
              redemptionValue: redemption.redemptionValue,
              status: redemption.status,
              requestedAt: redemption.requestedAt
            }
          },
          null,
          SUCCESS_CODES.REDEMPTION_REQUESTED
        )
      );
    } catch (error) {
      console.error('Error requesting redemption:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to process redemption request', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get user's redemption history
   */
  getMyRedemptions = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { 
        page = 1, 
        limit = 20, 
        status,
        redemptionType
      } = req.query;

      const redemptions = await PointRedemption.getUserRedemptions(userId, {
        page: parseInt(page),
        limit: parseInt(limit),
        status,
        redemptionType
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Redemption history retrieved successfully',
          {
            redemptions: redemptions.rows,
            pagination: {
              currentPage: parseInt(page),
              totalPages: Math.ceil(redemptions.count / parseInt(limit)),
              totalItems: redemptions.count,
              itemsPerPage: parseInt(limit)
            }
          }
        )
      );
    } catch (error) {
      console.error('Error getting redemption history:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve redemption history', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get available point activities
   */
  getAvailableActivities = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const activities = await pointService.getAvailableActivitiesForUser(userId);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Available activities retrieved successfully',
          { activities }
        )
      );
    } catch (error) {
      console.error('Error getting available activities:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve available activities', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  // Admin endpoints
  /**
   * Get all users' point transactions (Admin only)
   */
  getAllTransactions = asyncHandler(async (req, res) => {
    try {
      const { 
        page = 1, 
        limit = 20, 
        transactionType, 
        activityType,
        userId,
        startDate,
        endDate
      } = req.query;

      const whereClause = {};
      
      if (transactionType) whereClause.transactionType = transactionType;
      if (activityType) whereClause.activityType = activityType;
      if (userId) whereClause.userId = parseInt(userId);
      
      if (startDate || endDate) {
        whereClause.created_at = {};
        if (startDate) whereClause.created_at[PointTransaction.sequelize.Sequelize.Op.gte] = new Date(startDate);
        if (endDate) whereClause.created_at[PointTransaction.sequelize.Sequelize.Op.lte] = new Date(endDate);
      }

      const transactions = await PointTransaction.findAndCountAll({
        where: whereClause,
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'username', 'email']
          }
        ],
        order: [['created_at', 'DESC']],
        limit: parseInt(limit),
        offset: (parseInt(page) - 1) * parseInt(limit)
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'All transactions retrieved successfully',
          {
            transactions: transactions.rows,
            pagination: {
              currentPage: parseInt(page),
              totalPages: Math.ceil(transactions.count / parseInt(limit)),
              totalItems: transactions.count,
              itemsPerPage: parseInt(limit)
            }
          }
        )
      );
    } catch (error) {
      console.error('Error getting all transactions:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve transactions', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Award points manually (Admin only)
   */
  awardPointsManually = asyncHandler(async (req, res) => {
    try {
      const adminId = req.user.id;
      const { 
        userId, 
        points, 
        reason, 
        activityCode = 'MANUAL_AWARD' 
      } = req.body;

      // Check if target user exists
      const targetUser = await User.findByPk(userId);
      if (!targetUser) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('Target user not found', ERROR_CODES.USER_NOT_FOUND)
        );
      }

      // Award points manually
      const result = await pointService.awardPoints(userId, activityCode, {
        processedBy: adminId,
        referenceType: 'manual_award',
        metadata: {
          reason: reason,
          awardedBy: adminId,
          adminNote: `Manual award: ${reason}`
        }
      });

      if (!result.success) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse(result.message, ERROR_CODES.POINT_AWARD_FAILED)
        );
      }

      logSecurityEvent('manual_points_awarded', {
        adminId: adminId,
        targetUserId: userId,
        pointsAwarded: points,
        reason: reason
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Points awarded successfully',
          {
            pointsAwarded: result.points,
            newBalance: result.newBalance,
            targetUser: {
              id: targetUser.id,
              username: targetUser.username,
              email: targetUser.email
            }
          },
          null,
          SUCCESS_CODES.POINTS_AWARDED
        )
      );
    } catch (error) {
      console.error('Error awarding points manually:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to award points', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get system point statistics (Admin only)
   */
  getSystemStatistics = asyncHandler(async (req, res) => {
    try {
      const { startDate, endDate } = req.query;

      // Get system statistics
      const systemStats = await PointTransaction.getSystemStatistics({
        startDate,
        endDate
      });

      // Get activity statistics
      const activityStats = await PointActivity.getActivityStatistics();

      // Get total points in system from user balances
      const totalPointsInSystem = await User.getTotalPointsInSystem();

      // Get top point users
      const topUsers = await User.getTopPointUsers(10);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'System statistics retrieved successfully',
          {
            systemOverview: systemStats.overview,
            totalPointsInUserBalances: totalPointsInSystem,
            transactionsByActivity: systemStats.byActivity,
            activityStatistics: activityStats,
            topPointUsers: topUsers,
            consistencyCheck: {
              calculatedTotal: systemStats.overview.netPointsInCirculation,
              actualTotal: totalPointsInSystem,
              isConsistent: systemStats.overview.netPointsInCirculation === totalPointsInSystem
            }
          }
        )
      );
    } catch (error) {
      console.error('Error getting system statistics:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve system statistics', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get all redemption requests (Admin only)
   */
  getAllRedemptions = asyncHandler(async (req, res) => {
    try {
      const { 
        page = 1, 
        limit = 20, 
        status,
        redemptionType,
        userId
      } = req.query;

      const redemptions = await PointRedemption.getAllRedemptions({
        page: parseInt(page),
        limit: parseInt(limit),
        status,
        redemptionType,
        userId: userId ? parseInt(userId) : undefined
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'All redemptions retrieved successfully',
          {
            redemptions: redemptions.rows,
            pagination: {
              currentPage: parseInt(page),
              totalPages: Math.ceil(redemptions.count / parseInt(limit)),
              totalItems: redemptions.count,
              itemsPerPage: parseInt(limit)
            }
          }
        )
      );
    } catch (error) {
      console.error('Error getting all redemptions:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve redemptions', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Process redemption request (Admin only)
   */
  processRedemption = asyncHandler(async (req, res) => {
    try {
      const adminId = req.user.id;
      const { redemptionId } = req.params;
      const { action, adminNotes } = req.body; // action: 'approve' or 'reject'

      const redemption = await PointRedemption.findByPk(redemptionId);

      if (!redemption) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('Redemption request not found', ERROR_CODES.REDEMPTION_NOT_FOUND)
        );
      }

      if (redemption.status !== 'pending') {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('Only pending redemptions can be processed', ERROR_CODES.INVALID_REDEMPTION_STATUS)
        );
      }

      let result;
      if (action === 'approve') {
        result = await redemption.approve(adminId, adminNotes);
      } else if (action === 'reject') {
        result = await redemption.reject(adminId, adminNotes);
      } else {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('Invalid action. Use "approve" or "reject"', ERROR_CODES.VALIDATION_ERROR)
        );
      }

      logSecurityEvent('redemption_processed', {
        adminId: adminId,
        redemptionId: redemptionId,
        action: action,
        userId: redemption.userId,
        pointsProcessed: redemption.pointsRedeemed
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          `Redemption ${action}d successfully`,
          { redemption: result },
          null,
          action === 'approve' ? SUCCESS_CODES.REDEMPTION_APPROVED : SUCCESS_CODES.REDEMPTION_REJECTED
        )
      );
    } catch (error) {
      console.error('Error processing redemption:', error);
      
      if (error.message.includes('insufficient points')) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse(error.message, ERROR_CODES.INSUFFICIENT_BALANCE)
        );
      }

      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to process redemption', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Check system consistency (Admin only)
   */
  checkSystemConsistency = asyncHandler(async (req, res) => {
    try {
      const issues = [];
      const summary = {
        totalUsersChecked: 0,
        inconsistentUsers: 0,
        totalDiscrepancy: 0
      };

      // Get all active users with their current points
      const users = await User.findAll({
        where: { isActive: true },
        attributes: ['id', 'username', 'email', 'currentPoints']
      });

      summary.totalUsersChecked = users.length;

      for (const user of users) {
        // Calculate points from transactions
        const transactionSummary = await PointTransaction.getUserPointsSummary(user.id);
        const calculatedBalance = transactionSummary.netBalance;
        const actualBalance = user.currentPoints;

        if (calculatedBalance !== actualBalance) {
          const discrepancy = actualBalance - calculatedBalance;
          summary.inconsistentUsers++;
          summary.totalDiscrepancy += Math.abs(discrepancy);

          issues.push({
            userId: user.id,
            username: user.username,
            email: user.email,
            currentBalance: actualBalance,
            calculatedBalance: calculatedBalance,
            discrepancy: discrepancy,
            transactionSummary: transactionSummary
          });
        }
      }

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'System consistency check completed',
          {
            summary: summary,
            issues: issues,
            isSystemConsistent: issues.length === 0
          }
        )
      );
    } catch (error) {
      console.error('Error checking system consistency:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to check system consistency', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Fix inconsistent balances (Admin only)
   */
  fixInconsistentBalances = asyncHandler(async (req, res) => {
    try {
      const adminId = req.user.id;
      const { userIds } = req.body; // Array of user IDs to fix, or empty for all

      const fixedUsers = [];
      const errors = [];

      // Get users to fix
      let usersToFix;
      if (userIds && userIds.length > 0) {
        usersToFix = await User.findAll({
          where: { 
            id: userIds,
            isActive: true 
          }
        });
      } else {
        usersToFix = await User.findAll({
          where: { isActive: true }
        });
      }

      for (const user of usersToFix) {
        try {
          // Calculate correct balance from transactions
          const transactionSummary = await PointTransaction.getUserPointsSummary(user.id);
          const calculatedBalance = transactionSummary.netBalance;
          const currentBalance = user.currentPoints;

          if (calculatedBalance !== currentBalance) {
            const oldBalance = currentBalance;
            
            // Update user's balance to match transactions
            await user.update({ currentPoints: calculatedBalance });

            // Log the fix
            logSecurityEvent('balance_corrected', {
              adminId: adminId,
              userId: user.id,
              oldBalance: oldBalance,
              newBalance: calculatedBalance,
              discrepancy: currentBalance - calculatedBalance
            });

            fixedUsers.push({
              userId: user.id,
              username: user.username,
              email: user.email,
              oldBalance: oldBalance,
              newBalance: calculatedBalance,
              discrepancy: currentBalance - calculatedBalance
            });
          }
        } catch (userError) {
          errors.push({
            userId: user.id,
            username: user.username,
            error: userError.message
          });
        }
      }

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          `Balance correction completed. Fixed ${fixedUsers.length} users.`,
          {
            fixedUsers: fixedUsers,
            errors: errors,
            summary: {
              totalProcessed: usersToFix.length,
              successfulFixes: fixedUsers.length,
              errors: errors.length
            }
          },
          null,
          SUCCESS_CODES.BALANCES_FIXED
        )
      );
    } catch (error) {
      console.error('Error fixing inconsistent balances:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to fix inconsistent balances', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get detailed balance information for specific user (Admin only)
   */
  getUserBalanceDetails = asyncHandler(async (req, res) => {
    try {
      const { userId } = req.params;

      const user = await User.findByPk(userId, {
        attributes: ['id', 'username', 'email', 'currentPoints', 'isActive', 'isVerified']
      });

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.USER_NOT_FOUND)
        );
      }

      // Get transaction summary
      const transactionSummary = await PointTransaction.getUserPointsSummary(userId);

      // Get recent transactions
      const recentTransactions = await PointTransaction.getUserTransactions(userId, {
        page: 1,
        limit: 10
      });

      // Get available activities for this user
      const availableActivities = await pointService.getAvailableActivitiesForUser(userId);

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User balance details retrieved successfully',
          {
            user: user,
            currentBalance: user.currentPoints,
            transactionSummary: transactionSummary,
            recentTransactions: recentTransactions.rows.map(tx => tx.toSafeJSON()),
            availableActivities: availableActivities,
            consistencyCheck: {
              isConsistent: user.currentPoints === transactionSummary.netBalance,
              discrepancy: user.currentPoints - transactionSummary.netBalance
            }
          }
        )
      );
    } catch (error) {
      console.error('Error getting user balance details:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve user balance details', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Award product share points
   */
  awardProductSharePoints = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { productId } = req.body;

      const result = await pointService.awardProductSharePoints(userId, productId);

      if (!result.success) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse(result.message, ERROR_CODES.POINT_AWARD_FAILED)
        );
      }

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          result.message,
          {
            pointsAwarded: result.points,
            newBalance: result.newBalance,
            transaction: result.transaction
          },
          null,
          SUCCESS_CODES.POINTS_AWARDED
        )
      );
    } catch (error) {
      console.error('Error awarding product share points:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to award share points', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Award campaign share points
   */
  awardCampaignSharePoints = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { campaignId } = req.body;

      const result = await pointService.awardCampaignSharePoints(userId, campaignId);

      if (!result.success) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse(result.message, ERROR_CODES.POINT_AWARD_FAILED)
        );
      }

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          result.message,
          {
            pointsAwarded: result.points,
            newBalance: result.newBalance,
            transaction: result.transaction
          },
          null,
          SUCCESS_CODES.POINTS_AWARDED
        )
      );
    } catch (error) {
      console.error('Error awarding campaign share points:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to award share points', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });
}

module.exports = new PointController();


================================================
FILE: src/controllers/productController.js
================================================
const productService = require('../services/productService');
const { 
  successResponse, 
  errorResponse, 
  asyncHandler,
  HTTP_STATUS,
  SUCCESS_CODES,
  ERROR_CODES,
  createPaginationMeta
} = require('../utils/response');
const { getFileUrl, deleteFile } = require('../middleware/upload');

class ProductController {
  /**
   * Get all products (Admin only)
   */
  getAllProducts = asyncHandler(async (req, res) => {
    const {
      page = 1,
      limit = 10,
      search = '',
      categoryId,
      minPrice,
      maxPrice,
      minPoints,
      maxPoints,
      isActive,
      isFeatured,
      sortBy = 'createdAt',
      sortOrder = 'DESC'
    } = req.query;

    const result = await productService.getAllProducts({
      page: parseInt(page),
      limit: parseInt(limit),
      search,
      categoryId: categoryId ? parseInt(categoryId) : undefined,
      minPrice: minPrice ? parseFloat(minPrice) : undefined,
      maxPrice: maxPrice ? parseFloat(maxPrice) : undefined,
      minPoints: minPoints ? parseInt(minPoints) : undefined,
      maxPoints: maxPoints ? parseInt(maxPoints) : undefined,
      isActive: isActive !== undefined ? isActive === 'true' : undefined,
      isFeatured: isFeatured !== undefined ? isFeatured === 'true' : undefined,
      sortBy,
      sortOrder
    });

    // Add image URLs
    result.products = result.products.map(product => ({
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    }));

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Products retrieved successfully',
        result.products,
        createPaginationMeta(
          result.pagination.currentPage,
          result.pagination.itemsPerPage,
          result.pagination.totalItems,
          result.pagination.totalPages
        )
      )
    );
  });

  /**
   * Get active products (Public)
   */
  getActiveProducts = asyncHandler(async (req, res) => {
    const queryOptions = { ...req.query };
    
    const result = await productService.getActiveProducts({
      page: parseInt(queryOptions.page) || 1,
      limit: parseInt(queryOptions.limit) || 10,
      search: queryOptions.search || '',
      categoryId: queryOptions.categoryId ? parseInt(queryOptions.categoryId) : undefined,
      minPrice: queryOptions.minPrice ? parseFloat(queryOptions.minPrice) : undefined,
      maxPrice: queryOptions.maxPrice ? parseFloat(queryOptions.maxPrice) : undefined,
      minPoints: queryOptions.minPoints ? parseInt(queryOptions.minPoints) : undefined,
      maxPoints: queryOptions.maxPoints ? parseInt(queryOptions.maxPoints) : undefined,
      isFeatured: queryOptions.isFeatured !== undefined ? queryOptions.isFeatured === 'true' : undefined,
      sortBy: queryOptions.sortBy || 'createdAt',
      sortOrder: queryOptions.sortOrder || 'DESC'
    });

    // Add image URLs
    result.products = result.products.map(product => ({
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    }));

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Products retrieved successfully',
        result.products,
        createPaginationMeta(
          result.pagination.currentPage,
          result.pagination.itemsPerPage,
          result.pagination.totalItems,
          result.pagination.totalPages
        )
      )
    );
  });

  /**
   * Get featured products (Public)
   */
  getFeaturedProducts = asyncHandler(async (req, res) => {
    const { limit = 10 } = req.query;
    
    const products = await productService.getFeaturedProducts(parseInt(limit));

    const productsWithImageUrl = products.map(product => ({
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    }));

    res.status(HTTP_STATUS.OK.code).json(
      successResponse('Featured products retrieved successfully', productsWithImageUrl)
    );
  });

  /**
   * Get product by ID
   */
  getProductById = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { includeImages = false } = req.query;

    const product = await productService.getProductById(
      parseInt(id),
      includeImages === 'true'
    );

    const productData = {
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    };

    // Add image URLs to additional images if included
    if (productData.images) {
      productData.images = productData.images.map(image => ({
        ...image.toJSON(),
        imageUrl: getFileUrl(image.imagePath, 'products')
      }));
    }

    res.status(HTTP_STATUS.OK.code).json(
      successResponse('Product retrieved successfully', productData)
    );
  });

  /**
   * Get product by slug (Public)
   */
  getProductBySlug = asyncHandler(async (req, res) => {
    const { slug } = req.params;
    const incrementView = req.user ? false : true; // Only increment for non-authenticated users

    const product = await productService.getProductBySlug(slug, incrementView);

    const productData = {
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse('Product retrieved successfully', productData)
    );
  });

  /**
   * Search products (Public)
   */
  searchProducts = asyncHandler(async (req, res) => {
    const { q: query, ...options } = req.query;

    if (!query || query.trim().length === 0) {
      return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse('Search query is required', ERROR_CODES.MISSING_REQUIRED_FIELD)
      );
    }

    const result = await productService.searchProducts(query.trim(), {
      page: parseInt(options.page) || 1,
      limit: parseInt(options.limit) || 10,
      categoryId: options.categoryId ? parseInt(options.categoryId) : undefined,
      minPrice: options.minPrice ? parseFloat(options.minPrice) : undefined,
      maxPrice: options.maxPrice ? parseFloat(options.maxPrice) : undefined,
      sortBy: options.sortBy || 'viewCount',
      sortOrder: options.sortOrder || 'DESC'
    });

    // Add image URLs
    result.products = result.products.map(product => ({
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    }));

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        `Search results for "${query}"`,
        result.products,
        createPaginationMeta(
          result.pagination.currentPage,
          result.pagination.itemsPerPage,
          result.pagination.totalItems,
          result.pagination.totalPages
        )
      )
    );
  });

  /**
   * Get products by category (Public)
   */
  getProductsByCategory = asyncHandler(async (req, res) => {
    const { categoryId } = req.params;
    const options = req.query;

    const result = await productService.getProductsByCategory(parseInt(categoryId), {
      page: parseInt(options.page) || 1,
      limit: parseInt(options.limit) || 10,
      minPrice: options.minPrice ? parseFloat(options.minPrice) : undefined,
      maxPrice: options.maxPrice ? parseFloat(options.maxPrice) : undefined,
      sortBy: options.sortBy || 'sortOrder',
      sortOrder: options.sortOrder || 'ASC'
    });

    // Add image URLs
    result.products = result.products.map(product => ({
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    }));

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Products retrieved successfully',
        result.products,
        createPaginationMeta(
          result.pagination.currentPage,
          result.pagination.itemsPerPage,
          result.pagination.totalItems,
          result.pagination.totalPages
        )
      )
    );
  });

  /**
   * Create new product with optional image upload
   */
  createProduct = asyncHandler(async (req, res) => {
    const productData = req.body;
    const userId = req.user.id;
    
    // Get uploaded file if exists
    const imageFile = req.file;

    try {
      const product = await productService.createProduct(productData, userId, imageFile?.filename);

      const productWithImageUrl = {
        ...product.toSafeJSON(),
        imageUrl: product.image ? getFileUrl(product.image, 'products') : null
      };

      res.status(HTTP_STATUS.CREATED.code).json(
        successResponse(
          'Product created successfully',
          productWithImageUrl,
          null,
          SUCCESS_CODES.RESOURCE_CREATED
        )
      );
    } catch (error) {
      // Delete uploaded file if database operation fails
      if (imageFile) {
        deleteFile(`uploads/products/${imageFile.filename}`);
      }
      throw error;
    }
  });

  /**
 * Update product (Admin only)
 */
updateProduct = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;
  const userId = req.user.id;
  
  // Get uploaded file if exists
  const imageFile = req.file;

  try {
    const product = await productService.updateProduct(
      parseInt(id),
      updateData,
      userId,
      imageFile?.filename  // ← Pass image filename to service
    );

    const productWithImageUrl = {
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Product updated successfully',
        productWithImageUrl,
        null,
        SUCCESS_CODES.RESOURCE_UPDATED
      )
    );
  } catch (error) {
    // Delete uploaded file if database operation fails
    if (imageFile) {
      deleteFile(`uploads/products/${imageFile.filename}`);
    }
    throw error;
  }
});

  /**
   * Delete product (Admin only)
   */
  deleteProduct = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    await productService.deleteProduct(parseInt(id), userId);

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Product deleted successfully',
        null,
        null,
        SUCCESS_CODES.RESOURCE_DELETED
      )
    );
  });

  /**
   * Upload product image (Admin only) - for existing products
   */
  uploadProductImage = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    if (!req.file) {
      return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse('No image file provided', ERROR_CODES.MISSING_REQUIRED_FIELD)
      );
    }

    try {
      const product = await productService.uploadProductImage(
        parseInt(id),
        req.file.filename,
        userId
      );

      const productWithImageUrl = {
        ...product.toSafeJSON(),
        imageUrl: getFileUrl(product.image, 'products')
      };

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Product image uploaded successfully',
          productWithImageUrl,
          null,
          SUCCESS_CODES.FILE_UPLOADED
        )
      );
    } catch (error) {
      // Delete uploaded file if database operation fails
      deleteFile(`uploads/products/${req.file.filename}`);
      throw error;
    }
  });

  /**
   * Get product statistics (Admin only)
   */
  getProductStatistics = asyncHandler(async (req, res) => {
    const statistics = await productService.getProductStatistics();

    res.status(HTTP_STATUS.OK.code).json(
      successResponse('Product statistics retrieved successfully', statistics)
    );
  });

  /**
   * Toggle product status (Admin only)
   */
  toggleProductStatus = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    const product = await productService.toggleProductStatus(parseInt(id), userId);

    const productWithImageUrl = {
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        `Product ${product.isActive ? 'activated' : 'deactivated'} successfully`,
        productWithImageUrl,
        null,
        SUCCESS_CODES.STATUS_UPDATED
      )
    );
  });

  /**
   * Toggle product featured status (Admin only)
   */
  toggleProductFeatured = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    const product = await productService.toggleProductFeatured(parseInt(id), userId);

    const productWithImageUrl = {
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        `Product ${product.isFeatured ? 'marked as featured' : 'unmarked as featured'} successfully`,
        productWithImageUrl,
        null,
        SUCCESS_CODES.STATUS_UPDATED
      )
    );
  });

  /**
   * Update product stock (Admin only)
   */
  updateProductStock = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { quantity } = req.body;
    const userId = req.user.id;

    if (!quantity || isNaN(quantity)) {
      return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse('Valid quantity is required', ERROR_CODES.VALIDATION_ERROR)
      );
    }

    const product = await productService.updateProductStock(
      parseInt(id),
      parseInt(quantity),
      userId
    );

    const productWithImageUrl = {
      ...product.toSafeJSON(),
      imageUrl: product.image ? getFileUrl(product.image, 'products') : null
    };

    res.status(HTTP_STATUS.OK.code).json(
      successResponse(
        'Product stock updated successfully',
        productWithImageUrl,
        null,
        SUCCESS_CODES.RESOURCE_UPDATED
      )
    );
  });
}

module.exports = new ProductController();


================================================
FILE: src/controllers/userController.js
================================================
const User = require('../models/User');
const { 
  successResponse, 
  errorResponse, 
  asyncHandler,
  HTTP_STATUS,
  SUCCESS_CODES,
  ERROR_CODES 
} = require('../utils/response');
const { logSecurityEvent } = require('../utils/logger');
const { Op } = require('sequelize');

class UserController {
  /**
   * Get all users (Admin only)
   * @route GET /api/v1/users
   */
  getAllUsers = asyncHandler(async (req, res) => {
    const { 
      page = 1, 
      limit = 20, 
      search = '', 
      role = '',
      status = '',
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);
    const whereClause = {};

    // Search filter
    if (search) {
      whereClause[Op.or] = [
        { username: { [Op.like]: `%${search}%` } },
        { email: { [Op.like]: `%${search}%` } }
      ];
    }

    // Role filter
    if (role && ['admin', 'user'].includes(role)) {
      whereClause.role = role;
    }

    // Status filter
    if (status) {
      if (status === 'active') {
        whereClause.isActive = true;
      } else if (status === 'inactive') {
        whereClause.isActive = false;
      } else if (status === 'verified') {
        whereClause.isVerified = true;
      } else if (status === 'unverified') {
        whereClause.isVerified = false;
      }
    }

    try {
      const { count, rows: users } = await User.findAndCountAll({
        where: whereClause,
        attributes: { exclude: ['passwordHash', 'refreshTokenHash', 'twoFactorSecret', 'emailVerificationToken'] },
        order: [[sortBy, sortOrder.toUpperCase()]],
        limit: parseInt(limit),
        offset,
        paranoid: false // Include soft deleted users
      });

      const totalPages = Math.ceil(count / parseInt(limit));

      logSecurityEvent('admin_users_list_accessed', {
        adminId: req.user.id,
        filters: { search, role, status, sortBy, sortOrder },
        resultCount: users.length
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Users retrieved successfully',
          {
            users: users.map(user => ({
              ...user.toJSON(),
              // Add computed fields safely
              isLocked: user.isLocked ? user.isLocked() : false,
              canEarnPoints: user.canEarnPoints ? user.canEarnPoints() : false,
              accountAge: Math.floor((new Date() - user.createdAt) / (1000 * 60 * 60 * 24)) // days
            })),
            pagination: {
              currentPage: parseInt(page),
              totalPages,
              totalUsers: count,
              hasNext: parseInt(page) < totalPages,
              hasPrev: parseInt(page) > 1
            }
          }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve users', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get user by ID (Admin or own profile)
   * @route GET /api/v1/users/:id
   */
  getUserById = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const requestingUserId = req.user.id;
    const isAdmin = req.user.role === 'admin';

    // Check if user is accessing their own profile or is admin
    if (!isAdmin && parseInt(id) !== requestingUserId) {
      return res.status(HTTP_STATUS.FORBIDDEN.code).json(
        errorResponse('Access denied. You can only view your own profile.', ERROR_CODES.ACCESS_DENIED)
      );
    }

    try {
      const user = await User.findByPk(id, {
        attributes: { exclude: ['passwordHash', 'refreshTokenHash', 'twoFactorSecret', 'emailVerificationToken'] },
        paranoid: false // Include soft deleted users for admin
      });

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // For non-admin users, hide sensitive admin fields
      let userData = user.toJSON();
      if (!isAdmin) {
        delete userData.loginAttempts;
        delete userData.lockedUntil;
        delete userData.tokenVersion;
        delete userData.deletedAt;
      }

      // Add computed fields safely
      userData.isLocked = user.isLocked ? user.isLocked() : false;
      userData.canEarnPoints = user.canEarnPoints ? user.canEarnPoints() : false;
      userData.accountAge = Math.floor((new Date() - user.createdAt) / (1000 * 60 * 60 * 24));

      logSecurityEvent('user_profile_accessed', {
        accessedUserId: id,
        accessedBy: requestingUserId,
        isAdminAccess: isAdmin
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User profile retrieved successfully',
          { user: userData }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Create new user (Admin only)
   * @route POST /api/v1/users
   */
  createUser = asyncHandler(async (req, res) => {
    const { 
      username, 
      email, 
      phoneNumber, 
      password, 
      role = 'user',
      isVerified = false,
      isActive = true,
      currentPoints = 0
    } = req.body;

    try {
      // Check if user already exists
      const existingUser = await User.findOne({
        where: {
          [Op.or]: [
            { email: email.toLowerCase() },
            { username: username.toLowerCase() }
          ]
        },
        paranoid: false
      });

      if (existingUser) {
        const field = existingUser.email === email.toLowerCase() ? 'email' : 'username';
        return res.status(HTTP_STATUS.CONFLICT.code).json(
          errorResponse(`User with this ${field} already exists`, ERROR_CODES.RESOURCE_ALREADY_EXISTS)
        );
      }

      // Create new user
      const user = await User.create({
        username: username.toLowerCase(),
        email: email.toLowerCase(),
        phoneNumber,
        passwordHash: password, // Will be hashed by model hook
        role,
        isVerified,
        isActive,
        currentPoints,
        tokenVersion: 0
      });

      logSecurityEvent('admin_user_created', {
        adminId: req.user.id,
        createdUserId: user.id,
        createdUserEmail: user.email,
        assignedRole: role
      });

      res.status(HTTP_STATUS.CREATED.code).json(
        successResponse(
          'User created successfully',
          { user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON() },
          null,
          SUCCESS_CODES.USER_CREATED
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse(error.message, ERROR_CODES.VALIDATION_ERROR)
      );
    }
  });

  /**
   * Update user (Admin only)
   * @route PUT /api/v1/users/:id
   */
  updateUser = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const updateData = req.body;

    // Remove sensitive fields that shouldn't be updated directly
    delete updateData.passwordHash;
    delete updateData.refreshTokenHash;
    delete updateData.tokenVersion;
    delete updateData.emailVerificationToken;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // Check for duplicate username/email if they're being updated
      if (updateData.username || updateData.email) {
        const existingUser = await User.findOne({
          where: {
            [Op.and]: [
              { id: { [Op.ne]: id } },
              {
                [Op.or]: [
                  updateData.username ? { username: updateData.username.toLowerCase() } : null,
                  updateData.email ? { email: updateData.email.toLowerCase() } : null
                ].filter(Boolean)
              }
            ]
          },
          paranoid: false
        });

        if (existingUser) {
          const field = existingUser.username === updateData.username?.toLowerCase() ? 'username' : 'email';
          return res.status(HTTP_STATUS.CONFLICT.code).json(
            errorResponse(`This ${field} is already taken`, ERROR_CODES.RESOURCE_ALREADY_EXISTS)
          );
        }
      }

      // Prepare update data
      const cleanUpdateData = {};
      const allowedFields = [
        'username', 'email', 'phoneNumber', 'role', 'profilePicture',
        'isVerified', 'isActive', 'currentPoints', 'twoFactorEnabled'
      ];

      allowedFields.forEach(field => {
        if (updateData[field] !== undefined) {
          if (field === 'username' || field === 'email') {
            cleanUpdateData[field] = updateData[field].toLowerCase();
          } else {
            cleanUpdateData[field] = updateData[field];
          }
        }
      });

      await user.update(cleanUpdateData);

      logSecurityEvent('admin_user_updated', {
        adminId: req.user.id,
        updatedUserId: user.id,
        updatedFields: Object.keys(cleanUpdateData)
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User updated successfully',
          { user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON() },
          null,
          SUCCESS_CODES.PROFILE_UPDATED
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse(error.message, ERROR_CODES.VALIDATION_ERROR)
      );
    }
  });

  /**
   * Soft delete user (Admin only)
   * @route DELETE /api/v1/users/:id
   */
  deleteUser = asyncHandler(async (req, res) => {
    const { id } = req.params;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // Prevent admin from deleting themselves
      if (parseInt(id) === req.user.id) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('You cannot delete your own account', ERROR_CODES.INVALID_OPERATION)
        );
      }

      // Soft delete
      await user.destroy();

      logSecurityEvent('admin_user_deleted', {
        adminId: req.user.id,
        deletedUserId: user.id,
        deletedUserEmail: user.email
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User deleted successfully',
          null,
          null,
          SUCCESS_CODES.RESOURCE_DELETED
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to delete user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Restore deleted user (Admin only)
   * @route PATCH /api/v1/users/:id/restore
   */
  restoreUser = asyncHandler(async (req, res) => {
    const { id } = req.params;

    try {
      const user = await User.findByPk(id, { paranoid: false });

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      if (!user.deletedAt) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('User is not deleted', ERROR_CODES.INVALID_OPERATION)
        );
      }

      await user.restore();

      logSecurityEvent('admin_user_restored', {
        adminId: req.user.id,
        restoredUserId: user.id,
        restoredUserEmail: user.email
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User restored successfully',
          { user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON() }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to restore user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Reset user password (Admin only)
   * @route PATCH /api/v1/users/:id/reset-password
   */
  resetUserPassword = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { newPassword } = req.body;

    if (!newPassword || newPassword.length < 8) {
      return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
        errorResponse('New password must be at least 8 characters long', ERROR_CODES.VALIDATION_ERROR)
      );
    }

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // Update password and invalidate all tokens
      await user.update({
        passwordHash: newPassword // Will be hashed by model hook
      });

      // Invalidate all user tokens
      if (user.invalidateAllTokens) {
        await user.invalidateAllTokens('admin_password_reset');
      }

      logSecurityEvent('admin_password_reset', {
        adminId: req.user.id,
        targetUserId: user.id,
        targetUserEmail: user.email
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Password reset successfully. User will need to log in again.',
          null,
          null,
          SUCCESS_CODES.PASSWORD_CHANGED
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to reset password', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Unlock user account (Admin only)
   * @route PATCH /api/v1/users/:id/unlock
   */
  unlockUser = asyncHandler(async (req, res) => {
    const { id } = req.params;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      if (!user.isLocked || !user.isLocked()) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('User account is not locked', ERROR_CODES.INVALID_OPERATION)
        );
      }

      if (user.resetLoginAttempts) {
        await user.resetLoginAttempts();
      } else {
        // Fallback if method doesn't exist
        await user.update({
          loginAttempts: 0,
          lockedUntil: null
        });
      }

      logSecurityEvent('admin_user_unlocked', {
        adminId: req.user.id,
        unlockedUserId: user.id,
        unlockedUserEmail: user.email
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User account unlocked successfully',
          { user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON() }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to unlock user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Toggle user status (activate/deactivate) (Admin only)
   * @route PATCH /api/v1/users/:id/toggle-status
   */
  toggleUserStatus = asyncHandler(async (req, res) => {
    const { id } = req.params;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // Prevent admin from deactivating themselves
      if (parseInt(id) === req.user.id) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('You cannot deactivate your own account', ERROR_CODES.INVALID_OPERATION)
        );
      }

      const newStatus = !user.isActive;
      await user.update({ isActive: newStatus });

      // If deactivating, invalidate all tokens
      if (!newStatus && user.invalidateAllTokens) {
        await user.invalidateAllTokens('admin_account_deactivated');
      }

      logSecurityEvent('admin_user_status_toggled', {
        adminId: req.user.id,
        targetUserId: user.id,
        targetUserEmail: user.email,
        newStatus: newStatus ? 'active' : 'inactive'
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          `User ${newStatus ? 'activated' : 'deactivated'} successfully`,
          { user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON() }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to toggle user status', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Ban user (Deactivate account) (Admin only)
   * @route PATCH /api/v1/users/:id/ban
   */
  banUser = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { reason = 'Account banned by administrator', notifyUser = true } = req.body;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // Prevent admin from banning themselves
      if (parseInt(id) === req.user.id) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('You cannot ban your own account', ERROR_CODES.INVALID_OPERATION)
        );
      }

      // Check if user is already banned
      if (!user.isActive) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('User is already banned', ERROR_CODES.INVALID_OPERATION)
        );
      }

      // Ban the user (deactivate account)
      await user.update({
        isActive: false,
        lockedUntil: null, // Clear any temporary locks since this is permanent
        loginAttempts: 0   // Reset login attempts
      });

      // Invalidate all user tokens to force immediate logout
      if (user.invalidateAllTokens) {
        await user.invalidateAllTokens('account_banned');
      }

      // Send notification email if requested
      if (notifyUser) {
        try {
          const emailService = require('../services/emailService');
          await emailService.sendAccountBannedNotification(user, reason);
        } catch (emailError) {
          console.error('Failed to send ban notification email:', emailError);
          // Don't fail the ban operation if email fails
        }
      }

      logSecurityEvent('admin_user_banned', {
        adminId: req.user.id,
        bannedUserId: user.id,
        bannedUserEmail: user.email,
        reason: reason,
        notificationSent: notifyUser
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User has been banned successfully',
          {
            user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON(),
            bannedAt: new Date(),
            reason: reason,
            notificationSent: notifyUser,
            supportContact: 'support@sijago.ai'
          }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to ban user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Unban user (Reactivate account) (Admin only)
   * @route PATCH /api/v1/users/:id/unban
   */
  unbanUser = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { reason = 'Account reactivated by administrator', notifyUser = true } = req.body;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      // Check if user is actually banned
      if (user.isActive) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('User is not banned', ERROR_CODES.INVALID_OPERATION)
        );
      }

      // Unban the user (reactivate account)
      await user.update({
        isActive: true,
        loginAttempts: 0,
        lockedUntil: null
      });

      // Send notification email if requested
      if (notifyUser) {
        try {
          const emailService = require('../services/emailService');
          await emailService.sendAccountReactivatedNotification(user, reason);
        } catch (emailError) {
          console.error('Failed to send reactivation notification email:', emailError);
          // Don't fail the unban operation if email fails
        }
      }

      logSecurityEvent('admin_user_unbanned', {
        adminId: req.user.id,
        unbannedUserId: user.id,
        unbannedUserEmail: user.email,
        reason: reason,
        notificationSent: notifyUser
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User has been unbanned successfully',
          {
            user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON(),
            unbannedAt: new Date(),
            reason: reason,
            notificationSent: notifyUser
          }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to unban user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get banned users list (Admin only) - FIXED WITH RAW QUERY
   * @route GET /api/v1/users/banned
   */
  getBannedUsers = asyncHandler(async (req, res) => {
    const { 
      page = 1, 
      limit = 20, 
      search = '',
      sortBy = 'updated_at',
      sortOrder = 'DESC'
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);

    try {
      const { sequelize } = require('../config/database');
      
      // Build WHERE clause for search
      let searchClause = '';
      let replacements = { isActive: false, limit: parseInt(limit), offset: offset };
      
      if (search) {
        searchClause = 'AND (username LIKE :search OR email LIKE :search)';
        replacements.search = `%${search}%`;
      }

      // Build ORDER BY clause - ensure valid column names
      const validSortColumns = ['id', 'username', 'email', 'created_at', 'updated_at', 'is_active'];
      const safeSortBy = validSortColumns.includes(sortBy) ? sortBy : 'updated_at';
      const safeSortOrder = ['ASC', 'DESC'].includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'DESC';

      // Count query
      const countQuery = `
        SELECT COUNT(*) as total 
        FROM users 
        WHERE deleted_at IS NULL 
        AND is_active = :isActive
        ${searchClause}
      `;

      // Data query - using actual database column names
      const dataQuery = `
        SELECT 
          id, 
          username, 
          email, 
          phone_number as phoneNumber,
          role,
          google_id as googleId,
          profile_picture as profilePicture,
          is_verified as isVerified,
          is_active as isActive,
          login_attempts as loginAttempts,
          locked_until as lockedUntil,
          last_login as lastLogin,
          password_changed_at as passwordChangedAt,
          email_verified_at as emailVerifiedAt,
          two_factor_enabled as twoFactorEnabled,
          current_points as currentPoints,
          created_at as createdAt,
          updated_at as updatedAt
        FROM users 
        WHERE deleted_at IS NULL 
        AND is_active = :isActive
        ${searchClause}
        ORDER BY ${safeSortBy} ${safeSortOrder}
        LIMIT :limit OFFSET :offset
      `;

      // Execute queries
      const [countResult] = await sequelize.query(countQuery, {
        replacements,
        type: sequelize.QueryTypes.SELECT
      });

      const users = await sequelize.query(dataQuery, {
        replacements,
        type: sequelize.QueryTypes.SELECT
      });

      const totalBannedUsers = countResult.total;
      const totalPages = Math.ceil(totalBannedUsers / parseInt(limit));

      logSecurityEvent('admin_banned_users_list_accessed', {
        adminId: req.user.id,
        filters: { search, sortBy: safeSortBy, sortOrder: safeSortOrder },
        resultCount: users.length
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Banned users retrieved successfully',
          {
            bannedUsers: users.map(user => ({
              ...user,
              // Add computed fields
              accountAge: Math.floor((new Date() - new Date(user.createdAt)) / (1000 * 60 * 60 * 24)),
              bannedDuration: Math.floor((new Date() - new Date(user.updatedAt)) / (1000 * 60 * 60 * 24)),
              // Convert date strings to proper dates
              createdAt: new Date(user.createdAt),
              updatedAt: new Date(user.updatedAt),
              lastLogin: user.lastLogin ? new Date(user.lastLogin) : null,
              lockedUntil: user.lockedUntil ? new Date(user.lockedUntil) : null,
              passwordChangedAt: user.passwordChangedAt ? new Date(user.passwordChangedAt) : null,
              emailVerifiedAt: user.emailVerifiedAt ? new Date(user.emailVerifiedAt) : null
            })),
            pagination: {
              currentPage: parseInt(page),
              totalPages,
              totalBannedUsers,
              hasNext: parseInt(page) < totalPages,
              hasPrev: parseInt(page) > 1
            },
            supportContact: 'support@sijago.ai'
          }
        )
      );
    } catch (error) {
      console.error('getBannedUsers error:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve banned users', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Check ban status for a user (Admin only) - FIXED WITH RAW QUERY
   * @route GET /api/v1/users/:id/ban-status
   */
  getUserBanStatus = asyncHandler(async (req, res) => {
    const { id } = req.params;

    try {
      const { sequelize } = require('../config/database');
      
      // Use raw query to avoid field mapping issues
      const query = `
        SELECT 
          id, 
          username, 
          email, 
          is_active as isActive, 
          created_at as createdAt,
          updated_at as updatedAt
        FROM users 
        WHERE deleted_at IS NULL 
        AND id = :userId
      `;

      const [user] = await sequelize.query(query, {
        replacements: { userId: id },
        type: sequelize.QueryTypes.SELECT
      });

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      const banStatus = {
        userId: user.id,
        username: user.username,
        email: user.email,
        isBanned: !user.isActive,
        isActive: user.isActive,
        accountCreated: new Date(user.createdAt),
        lastStatusChange: new Date(user.updatedAt),
        supportContact: 'support@sijago.ai'
      };

      if (!user.isActive) {
        banStatus.bannedDuration = Math.floor((new Date() - new Date(user.updatedAt)) / (1000 * 60 * 60 * 24));
        banStatus.message = 'Account is currently banned. For more information about your account status, please contact: support@sijago.ai';
      }

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User ban status retrieved successfully',
          { banStatus }
        )
      );
    } catch (error) {
      console.error('getUserBanStatus error:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve ban status', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });

  /**
   * Get user statistics (Admin only)
   * @route GET /api/v1/users/statistics
   */
  getUserStatistics = asyncHandler(async (req, res) => {
    try {
      const { sequelize } = require('../config/database');
      
      // Use raw queries to avoid field mapping issues
      const queries = [
        // Total users
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL',
        // Active users
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND is_active = true',
        // Verified users
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND is_verified = true',
        // Admin users
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND role = "admin"',
        // Locked users
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND locked_until > NOW()',
        // Users registered this month
        `SELECT COUNT(*) as count FROM users 
         WHERE deleted_at IS NULL 
         AND created_at >= DATE_FORMAT(NOW(), '%Y-%m-01')`,
        // Deleted users
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NOT NULL',
        // Banned users (inactive but not deleted)
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND is_active = false'
      ];

      const results = await Promise.all(
        queries.map(query => 
          sequelize.query(query, { type: sequelize.QueryTypes.SELECT })
            .then(result => result[0].count)
        )
      );

      const statistics = {
        totalUsers: results[0],
        activeUsers: results[1],
        verifiedUsers: results[2],
        adminUsers: results[3],
        lockedUsers: results[4],
        newUsersThisMonth: results[5],
        deletedUsers: results[6],
        bannedUsers: results[7],
        inactiveUsers: results[0] - results[1],
        unverifiedUsers: results[0] - results[2],
        regularUsers: results[0] - results[3]
      };

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User statistics retrieved successfully',
          { statistics }
        )
      );
    } catch (error) {
      console.error('getUserStatistics error:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve statistics', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  });
}

module.exports = new UserController();


================================================
FILE: src/middleware/auth.js
================================================
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const { createResponse } = require('../utils/response');
const winston = require('winston');

// Verify JWT token with token version validation
const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      return res.status(401).json(
        createResponse(false, 'Access token required', null, 'MISSING_TOKEN')
      );
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log('🔍 Token decoded:', { 
      userId: decoded.userId, 
      tokenVersion: decoded.tokenVersion, 
      iat: decoded.iat, 
      exp: decoded.exp 
    });
    
    // Check if user still exists
    const user = await User.findByPk(decoded.userId);
    if (!user) {
      console.log('❌ User not found:', decoded.userId);
      return res.status(401).json(
        createResponse(false, 'User no longer exists', null, 'USER_NOT_FOUND')
      );
    }

    console.log('👤 Current user:', { 
      id: user.id, 
      tokenVersion: user.tokenVersion, 
      isActive: user.isActive 
    });

    // Check if user is active
    if (!user.isActive) {
      console.log('❌ Account deactivated for user:', user.id);
      return res.status(401).json(
        createResponse(false, 'Account has been deactivated', null, 'ACCOUNT_DEACTIVATED')
      );
    }

    // MAIN CHECK: Validate token version
    const userTokenVersion = user.tokenVersion || 0;
    const decodedTokenVersion = decoded.tokenVersion || 0;
    
    // If user has null tokenVersion, fix it
    if (user.tokenVersion === null || user.tokenVersion === undefined) {
      console.log('🔧 Fixing null tokenVersion for user:', user.id);
      try {
        await user.update({ tokenVersion: 0 });
        await user.reload();
      } catch (updateError) {
        console.error('❌ Failed to update tokenVersion:', updateError);
      }
    }
    
    if (decodedTokenVersion !== userTokenVersion) {
      console.log('❌ Token version mismatch:', {
        decodedVersion: decodedTokenVersion,
        currentVersion: userTokenVersion,
        userId: user.id,
        originalDecodedVersion: decoded.tokenVersion,
        originalUserVersion: user.tokenVersion
      });
      
      winston.warn(`Token version mismatch for user ${user.id}. Token: ${decodedTokenVersion}, Current: ${userTokenVersion}`);
      
      return res.status(401).json(
        createResponse(false, 'Token has been invalidated. Please log in again.', null, 'TOKEN_INVALIDATED')
      );
    }

    // Additional check: Password change validation (backup security)
    if (user.passwordChangedAt) {
      let passwordChangedTimestamp;
      
      // Handle both Date object and string
      if (user.passwordChangedAt instanceof Date) {
        passwordChangedTimestamp = parseInt(user.passwordChangedAt.getTime() / 1000, 10);
      } else if (typeof user.passwordChangedAt === 'string') {
        passwordChangedTimestamp = parseInt(new Date(user.passwordChangedAt).getTime() / 1000, 10);
      } else {
        // If it's already a timestamp
        passwordChangedTimestamp = parseInt(user.passwordChangedAt, 10);
      }
      
      if (decoded.iat < passwordChangedTimestamp) {
        console.log('❌ Password changed after token issued:', {
          tokenIat: decoded.iat,
          passwordChangedAt: passwordChangedTimestamp,
          passwordChangedAtRaw: user.passwordChangedAt
        });
        return res.status(401).json(
          createResponse(false, 'Password recently changed. Please log in again.', null, 'PASSWORD_CHANGED')
        );
      }
    }

    console.log('✅ Token validation successful for user:', user.id);

    // Add user to request object
    req.user = user;
    next();
  } catch (error) {
    console.log('❌ Token verification error:', error.message);
    winston.error('Token verification error:', error);
    
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json(
        createResponse(false, 'Invalid token', null, 'INVALID_TOKEN')
      );
    }
    
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json(
        createResponse(false, 'Token expired', null, 'TOKEN_EXPIRED')
      );
    }

    return res.status(500).json(
      createResponse(false, 'Authentication error', null, 'AUTH_ERROR')
    );
  }
};

// Authorize roles
const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json(
        createResponse(false, 'Authentication required', null, 'AUTH_REQUIRED')
      );
    }

    if (!roles.includes(req.user.role)) {
      winston.warn(`Unauthorized access attempt by user ${req.user.id} with role ${req.user.role}`);
      return res.status(403).json(
        createResponse(false, 'Insufficient permissions', null, 'INSUFFICIENT_PERMISSIONS')
      );
    }

    next();
  };
};

// Optional authentication (for public endpoints that can work with or without auth)
const optionalAuth = async (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      req.user = null;
      return next();
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findByPk(decoded.userId);
    
    // Check token version for optional auth too
    if (user && user.isActive && decoded.tokenVersion === (user.tokenVersion || 0)) {
      req.user = user;
    } else {
      req.user = null;
    }
    
    next();
  } catch (error) {
    // Don't throw error for optional auth, just set user to null
    req.user = null;
    next();
  }
};

// Check if user owns resource or is admin
const checkOwnershipOrAdmin = (resourceUserIdField = 'userId') => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json(
        createResponse(false, 'Authentication required', null, 'AUTH_REQUIRED')
      );
    }

    // Admin can access everything
    if (req.user.role === 'admin') {
      return next();
    }

    // Check ownership
    const resourceUserId = req.params[resourceUserIdField] || req.body[resourceUserIdField];
    if (req.user.id.toString() !== resourceUserId?.toString()) {
      return res.status(403).json(
        createResponse(false, 'Access denied. You can only access your own resources.', null, 'ACCESS_DENIED')
      );
    }

    next();
  };
};

// Verify refresh token with token version
const verifyRefreshToken = async (req, res, next) => {
  try {
    const { refreshToken } = req.body;
    const cookieRefreshToken = req.cookies?.refreshToken;
    const tokenToUse = refreshToken || cookieRefreshToken;

    if (!tokenToUse) {
      return res.status(401).json(
        createResponse(false, 'Refresh token required', null, 'MISSING_REFRESH_TOKEN')
      );
    }

    // Verify refresh token format
    const decoded = jwt.verify(tokenToUse, process.env.JWT_REFRESH_SECRET);
    
    // Find user and validate refresh token
    const user = await User.findByPk(decoded.userId);
    if (!user) {
      return res.status(401).json(
        createResponse(false, 'Invalid refresh token', null, 'INVALID_REFRESH_TOKEN')
      );
    }

    // Check token version
    if (decoded.tokenVersion !== (user.tokenVersion || 0)) {
      winston.warn(`Refresh token version mismatch for user ${user.id}. Token: ${decoded.tokenVersion}, Current: ${user.tokenVersion}`);
      return res.status(401).json(
        createResponse(false, 'Refresh token has been invalidated', null, 'REFRESH_TOKEN_INVALIDATED')
      );
    }

    // Validate refresh token hash
    if (!user.validateRefreshToken(tokenToUse)) {
      return res.status(401).json(
        createResponse(false, 'Invalid refresh token', null, 'INVALID_REFRESH_TOKEN')
      );
    }

    req.user = user;
    req.refreshToken = tokenToUse;
    next();
  } catch (error) {
    winston.error('Refresh token verification error:', error);
    return res.status(401).json(
      createResponse(false, 'Invalid refresh token', null, 'INVALID_REFRESH_TOKEN')
    );
  }
};

module.exports = {
  authenticateToken,
  authorizeRoles,
  optionalAuth,
  checkOwnershipOrAdmin,
  verifyRefreshToken
};


================================================
FILE: src/middleware/enhancedErrorHandler.js
================================================
// middleware/enhancedErrorHandler.js
const { logger } = require('../utils/logger');
const { 
  errorResponse, 
  HTTP_STATUS, 
  ERROR_CODES 
} = require('../utils/response');

/**
 * Enhanced error handler with specific handling for Category operations
 */
const enhancedErrorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  // Log error details
  logger.error(`Error ${err.message}`, {
    error: err.stack,
    path: req.path,
    method: req.method,
    params: req.params,
    query: req.query,
    userId: req.user?.id,
    userRole: req.user?.role
  });

  // Sequelize validation errors
  if (err.name === 'SequelizeValidationError') {
    const messages = err.errors.map(error => error.message);
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse(
        'Validation error',
        ERROR_CODES.VALIDATION_ERROR,
        {
          fields: messages
        }
      )
    );
  }

  // Sequelize unique constraint errors
  if (err.name === 'SequelizeUniqueConstraintError') {
    const field = err.errors[0]?.path || 'field';
    return res.status(HTTP_STATUS.CONFLICT.code).json(
      errorResponse(
        `${field} already exists`,
        ERROR_CODES.DUPLICATE_RESOURCE,
        {
          field: field,
          value: err.errors[0]?.value
        }
      )
    );
  }

  // Sequelize foreign key constraint errors
  if (err.name === 'SequelizeForeignKeyConstraintError') {
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse(
        'Referenced resource not found',
        ERROR_CODES.INVALID_REFERENCE
      )
    );
  }

  // Sequelize database connection errors
  if (err.name === 'SequelizeConnectionError') {
    return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
      errorResponse(
        'Database connection error',
        ERROR_CODES.DATABASE_ERROR
      )
    );
  }

  // Custom application errors
  if (err.message === 'Category not found') {
    return res.status(HTTP_STATUS.NOT_FOUND.code).json(
      errorResponse(
        'Category not found',
        ERROR_CODES.RESOURCE_NOT_FOUND,
        {
          resource: 'category',
          id: req.params.id
        }
      )
    );
  }

  if (err.message?.includes('already exists')) {
    return res.status(HTTP_STATUS.CONFLICT.code).json(
      errorResponse(
        err.message,
        ERROR_CODES.DUPLICATE_RESOURCE
      )
    );
  }

  if (err.message?.includes('Cannot delete category')) {
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse(
        err.message,
        ERROR_CODES.DEPENDENCY_CONFLICT,
        {
          suggestion: 'Remove or move associated products first'
        }
      )
    );
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
      errorResponse(
        'Invalid token',
        ERROR_CODES.INVALID_TOKEN
      )
    );
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(HTTP_STATUS.UNAUTHORIZED.code).json(
      errorResponse(
        'Token expired',
        ERROR_CODES.TOKEN_EXPIRED
      )
    );
  }

  // Multer errors (file upload)
  if (err.code === 'LIMIT_FILE_SIZE') {
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse(
        'File size too large',
        ERROR_CODES.FILE_TOO_LARGE,
        {
          maxSize: '5MB'
        }
      )
    );
  }

  if (err.code === 'LIMIT_UNEXPECTED_FILE') {
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse(
        'Unexpected file field',
        ERROR_CODES.INVALID_FILE_FIELD
      )
    );
  }

  // Default server error
  const statusCode = err.statusCode || HTTP_STATUS.INTERNAL_SERVER_ERROR.code;
  const message = process.env.NODE_ENV === 'production' 
    ? 'Internal server error' 
    : err.message;

  res.status(statusCode).json(
    errorResponse(
      message,
      ERROR_CODES.INTERNAL_ERROR,
      process.env.NODE_ENV === 'development' ? { stack: err.stack } : undefined
    )
  );
};

/**
 * Async handler wrapper with enhanced error context
 */
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch((error) => {
    // Add request context to error
    error.requestContext = {
      method: req.method,
      path: req.path,
      params: req.params,
      query: req.query,
      userId: req.user?.id,
      timestamp: new Date().toISOString()
    };
    next(error);
  });
};

/**
 * 404 handler
 */
const notFoundHandler = (req, res, next) => {
  const error = new Error(`Resource not found - ${req.originalUrl}`);
  error.statusCode = HTTP_STATUS.NOT_FOUND.code;
  next(error);
};

/**
 * Validation error formatter
 */
const formatValidationErrors = (errors) => {
  return errors.reduce((acc, error) => {
    const field = error.path;
    if (!acc[field]) {
      acc[field] = [];
    }
    acc[field].push(error.msg);
    return acc;
  }, {});
};

module.exports = {
  enhancedErrorHandler,
  asyncHandler,
  notFoundHandler,
  formatValidationErrors
};


================================================
FILE: src/middleware/errorHandler.js
================================================
const { 
  errorResponse, 
  HTTP_STATUS, 
  ERROR_CODES 
} = require('../utils/response');
const { logSystemError } = require('../utils/logger');

// Handle Sequelize validation errors
const handleSequelizeValidationError = (err) => {
  const errors = err.errors.map(error => ({
    field: error.path,
    message: error.message,
    value: error.value
  }));

  return errorResponse('Validation failed', ERROR_CODES.VALIDATION_ERROR, { errors });
};

// Handle Sequelize unique constraint errors
const handleSequelizeUniqueConstraintError = (err) => {
  const field = err.errors[0]?.path || 'field';
  const message = `${field} already exists`;
  
  return errorResponse(message, ERROR_CODES.RESOURCE_ALREADY_EXISTS);
};

// Handle Sequelize foreign key constraint errors
const handleSequelizeForeignKeyConstraintError = (err) => {
  return errorResponse('Referenced resource does not exist', ERROR_CODES.RESOURCE_NOT_FOUND);
};

// Handle Sequelize database connection errors
const handleSequelizeConnectionError = (err) => {
  return errorResponse('Database connection failed', ERROR_CODES.DATABASE_ERROR);
};

// Handle JWT errors
const handleJWTError = (err) => {
  if (err.name === 'JsonWebTokenError') {
    return errorResponse('Invalid token', ERROR_CODES.INVALID_TOKEN);
  }
  
  if (err.name === 'TokenExpiredError') {
    return errorResponse('Token expired', ERROR_CODES.TOKEN_EXPIRED);
  }
  
  return errorResponse('Authentication failed', ERROR_CODES.INVALID_TOKEN);
};

// Handle multer errors (file upload)
const handleMulterError = (err) => {
  if (err.code === 'LIMIT_FILE_SIZE') {
    return errorResponse('File too large', ERROR_CODES.VALIDATION_ERROR);
  }
  
  if (err.code === 'LIMIT_FILE_COUNT') {
    return errorResponse('Too many files', ERROR_CODES.VALIDATION_ERROR);
  }
  
  if (err.code === 'LIMIT_UNEXPECTED_FILE') {
    return errorResponse('Unexpected field', ERROR_CODES.VALIDATION_ERROR);
  }
  
  return errorResponse('File upload failed', ERROR_CODES.VALIDATION_ERROR);
};

// Handle cast errors
const handleCastError = (err) => {
  return errorResponse('Invalid data format', ERROR_CODES.VALIDATION_ERROR);
};

// Main error handler middleware
const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  // Log error
  logSystemError(err, {
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    userId: req.user ? req.user.id : null,
    body: req.method !== 'GET' ? req.body : undefined
  });

  // Sequelize errors
  if (err.name === 'SequelizeValidationError') {
    const response = handleSequelizeValidationError(err);
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(response);
  }

  if (err.name === 'SequelizeUniqueConstraintError') {
    const response = handleSequelizeUniqueConstraintError(err);
    return res.status(HTTP_STATUS.CONFLICT.code).json(response);
  }

  if (err.name === 'SequelizeForeignKeyConstraintError') {
    const response = handleSequelizeForeignKeyConstraintError(err);
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(response);
  }

  if (err.name === 'SequelizeConnectionError' || err.name === 'SequelizeConnectionRefusedError') {
    const response = handleSequelizeConnectionError(err);
    return res.status(HTTP_STATUS.SERVICE_UNAVAILABLE.code).json(response);
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError' || err.name === 'TokenExpiredError') {
    const response = handleJWTError(err);
    return res.status(HTTP_STATUS.UNAUTHORIZED.code).json(response);
  }

  // Multer errors
  if (err.name === 'MulterError') {
    const response = handleMulterError(err);
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(response);
  }

  // Cast errors (invalid ObjectId, etc.)
  if (err.name === 'CastError') {
    const response = handleCastError(err);
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(response);
  }

  // CORS errors
  if (err.message && err.message.includes('CORS')) {
    return res.status(HTTP_STATUS.FORBIDDEN.code).json(
      errorResponse('CORS policy violation', ERROR_CODES.ACCESS_DENIED)
    );
  }

  // Rate limiting errors
  if (err.status === 429) {
    return res.status(HTTP_STATUS.TOO_MANY_REQUESTS.code).json(
      errorResponse(err.message || 'Too many requests', ERROR_CODES.RATE_LIMIT_EXCEEDED)
    );
  }

  // Validation errors (express-validator)
  if (err.status === 400 && err.array) {
    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse('Validation failed', ERROR_CODES.VALIDATION_ERROR, { errors: err.array() })
    );
  }

  // Default error response
  const statusCode = err.statusCode || HTTP_STATUS.INTERNAL_SERVER_ERROR.code;
  const message = process.env.NODE_ENV === 'production' 
    ? 'Something went wrong' 
    : err.message || 'Internal server error';

  res.status(statusCode).json(
    errorResponse(message, ERROR_CODES.INTERNAL_ERROR)
  );
};

// Handle 404 errors
const notFoundHandler = (req, res, next) => {
  const message = `Route ${req.originalUrl} not found`;
  
  logSystemError(new Error(message), {
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  res.status(HTTP_STATUS.NOT_FOUND.code).json(
    errorResponse(message, ERROR_CODES.RESOURCE_NOT_FOUND)
  );
};

// Handle unhandled promise rejections
process.on('unhandledRejection', (err, promise) => {
  logSystemError(err, { 
    type: 'unhandledRejection',
    promise: promise.toString() 
  });
  
  // Close server & exit process
  if (process.env.NODE_ENV === 'production') {
    process.exit(1);
  }
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  logSystemError(err, { type: 'uncaughtException' });
  
  // Close server & exit process
  process.exit(1);
});

module.exports = {
  errorHandler,
  notFoundHandler
};


================================================
FILE: src/middleware/leaderboardValidation.js
================================================
const { query } = require('express-validator');
const { handleValidationErrors } = require('./validation');

/**
 * Validate date query parameter for daily leaderboard
 */
const validateDateQuery = [
  query('date')
    .optional()
    .isISO8601()
    .withMessage('Date must be in YYYY-MM-DD format')
    .custom((value) => {
      if (value) {
        const date = new Date(value);
        const now = new Date();
        if (date > now) {
          throw new Error('Date cannot be in the future');
        }
        // Limit to reasonable past dates (e.g., 1 year ago)
        const oneYearAgo = new Date();
        oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
        if (date < oneYearAgo) {
          throw new Error('Date cannot be more than 1 year ago');
        }
      }
      return true;
    }),
  handleValidationErrors
];

/**
 * Validate year and month query parameters for monthly leaderboard
 */
const validateMonthYearQuery = [
  query('year')
    .optional()
    .isInt({ min: 2020, max: new Date().getFullYear() })
    .withMessage(`Year must be between 2020 and ${new Date().getFullYear()}`),
  query('month')
    .optional()
    .isInt({ min: 1, max: 12 })
    .withMessage('Month must be between 1 and 12')
    .custom((value, { req }) => {
      if (value && req.query.year) {
        const targetYear = parseInt(req.query.year);
        const targetMonth = parseInt(value);
        const currentYear = new Date().getFullYear();
        const currentMonth = new Date().getMonth() + 1;
        
        // Check if the target date is not in the future
        if (targetYear === currentYear && targetMonth > currentMonth) {
          throw new Error('Cannot get leaderboard for future months');
        }
        if (targetYear > currentYear) {
          throw new Error('Cannot get leaderboard for future years');
        }
      }
      return true;
    }),
  handleValidationErrors
];

module.exports = {
  validateDateQuery,
  validateMonthYearQuery
};


================================================
FILE: src/middleware/rateLimiter.js
================================================
[Empty file]


================================================
FILE: src/middleware/security.js
================================================
[Empty file]


================================================
FILE: src/middleware/upload.js
================================================
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const { logSecurityEvent } = require('../utils/logger');

// Ensure upload directories exist
const createUploadDirs = () => {
  const dirs = [
    'uploads',
    'uploads/categories',
    'uploads/products',
    'uploads/temp'
  ];
  
  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
};

createUploadDirs();

// File filter function
const fileFilter = (req, file, cb) => {
  // Allowed file extensions
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
  const allowedMimeTypes = [
    'image/jpeg',
    'image/jpg', 
    'image/png', 
    'image/gif',
    'image/webp'
  ];
  
  const fileExtension = path.extname(file.originalname).toLowerCase();
  const mimeType = file.mimetype.toLowerCase();
  
  // Check file extension
  if (!allowedExtensions.includes(fileExtension)) {
    logSecurityEvent('file_upload_invalid_extension', {
      filename: file.originalname,
      extension: fileExtension,
      mimetype: mimeType,
      userId: req.user ? req.user.id : null
    });
    
    return cb(new Error(`Invalid file extension. Allowed: ${allowedExtensions.join(', ')}`), false);
  }
  
  // Check MIME type
  if (!allowedMimeTypes.includes(mimeType)) {
    logSecurityEvent('file_upload_invalid_mimetype', {
      filename: file.originalname,
      extension: fileExtension,
      mimetype: mimeType,
      userId: req.user ? req.user.id : null
    });
    
    return cb(new Error(`Invalid file type. Allowed: ${allowedMimeTypes.join(', ')}`), false);
  }
  
  cb(null, true);
};

// Storage configuration for categories
const categoryStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/categories');
  },
  filename: (req, file, cb) => {
    // Generate unique filename
    const uniqueSuffix = crypto.randomBytes(16).toString('hex');
    const fileExtension = path.extname(file.originalname).toLowerCase();
    const filename = `category_${Date.now()}_${uniqueSuffix}${fileExtension}`;
    
    cb(null, filename);
  }
});

// Storage configuration for products
const productStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/products');
  },
  filename: (req, file, cb) => {
    // Generate unique filename
    const uniqueSuffix = crypto.randomBytes(16).toString('hex');
    const fileExtension = path.extname(file.originalname).toLowerCase();
    const filename = `product_${Date.now()}_${uniqueSuffix}${fileExtension}`;
    
    cb(null, filename);
  }
});

// Multer configuration
const multerConfig = {
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
    files: 10 // Maximum 10 files
  }
};

// Create upload middleware instances
const uploadCategory = multer({
  storage: categoryStorage,
  ...multerConfig
});

const uploadProduct = multer({
  storage: productStorage,
  ...multerConfig
});

// Middleware for single file upload
const uploadSingleCategory = uploadCategory.single('image');
const uploadSingleProduct = uploadProduct.single('image');

// Middleware for multiple files upload
const uploadMultipleProducts = uploadProduct.array('images', 10);

// Error handling middleware for multer
const handleUploadError = (error, req, res, next) => {
  if (error instanceof multer.MulterError) {
    logSecurityEvent('file_upload_error', {
      error: error.message,
      code: error.code,
      field: error.field,
      userId: req.user ? req.user.id : null
    });
    
    let message = 'File upload error';
    
    switch (error.code) {
      case 'LIMIT_FILE_SIZE':
        message = 'File too large. Maximum size is 5MB';
        break;
      case 'LIMIT_FILE_COUNT':
        message = 'Too many files. Maximum is 10 files';
        break;
      case 'LIMIT_UNEXPECTED_FILE':
        message = 'Unexpected field name';
        break;
      case 'LIMIT_PART_COUNT':
        message = 'Too many parts';
        break;
      case 'LIMIT_FIELD_KEY':
        message = 'Field name too long';
        break;
      case 'LIMIT_FIELD_VALUE':
        message = 'Field value too long';
        break;
      case 'LIMIT_FIELD_COUNT':
        message = 'Too many fields';
        break;
    }
    
    return res.status(400).json({
      success: false,
      message,
      code: 'UPLOAD_ERROR'
    });
  }
  
  if (error.message.includes('Invalid file')) {
    return res.status(400).json({
      success: false,
      message: error.message,
      code: 'INVALID_FILE_TYPE'
    });
  }
  
  next(error);
};

// Utility function to delete uploaded file
const deleteFile = (filePath) => {
  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      return true;
    }
  } catch (error) {
    console.error('Error deleting file:', error);
  }
  return false;
};

// Utility function to get file URL
const getFileUrl = (filename, type = 'products') => {
  if (!filename) return null;
  
  const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
  return `${baseUrl}/uploads/${type}/${filename}`;
};

// Utility function to validate image file
const validateImageFile = (file) => {
  const errors = [];
  
  if (!file) {
    errors.push('No file provided');
    return errors;
  }
  
  // Check file size (5MB limit)
  if (file.size > 5 * 1024 * 1024) {
    errors.push('File size exceeds 5MB limit');
  }
  
  // Check file type
  const allowedMimeTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
  if (!allowedMimeTypes.includes(file.mimetype.toLowerCase())) {
    errors.push('Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed');
  }
  
  return errors;
};

module.exports = {
  uploadSingleCategory,
  uploadSingleProduct,
  uploadMultipleProducts,
  handleUploadError,
  deleteFile,
  getFileUrl,
  validateImageFile,
  createUploadDirs
};


================================================
FILE: src/middleware/validation.js
================================================
const { body, param, query, validationResult } = require('express-validator');
const { validatePassword, sanitizeInput } = require('../config/security');
const { isValidEmail } = require('../utils/email');
const { createResponse } = require('../utils/response');
const { errorResponse, HTTP_STATUS, ERROR_CODES } = require('../utils/response');

// Custom sanitizer untuk email yang hanya lowercase tanpa menghapus dots
const emailSanitizer = (value) => {
  if (!value || typeof value !== 'string') {
    return value;
  }
  return value.trim().toLowerCase();
};

// Handle validation errors
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(error => ({
      field: error.path,
      message: error.msg,
      value: error.value
    }));

    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse(
        'Validation failed',
        ERROR_CODES.VALIDATION_ERROR,
        { errors: errorMessages }
      )
    );
  }
  next();
};

// Validate user creation (Admin only)
const validateCreateUser = [
  body('username')
    .isLength({ min: 3, max: 50 })
    .withMessage('Username must be between 3 and 50 characters')
    .matches(/^[a-zA-Z0-9_]+$/)
    .withMessage('Username can only contain letters, numbers, and underscores')
    .toLowerCase(),

  body('email')
    .isEmail()
    .withMessage('Please provide a valid email address')
    .isLength({ max: 100 })
    .withMessage('Email must be less than 100 characters')
    .normalizeEmail(),

  body('phoneNumber')
    .optional({ nullable: true })
    .matches(/^[\+]?[1-9][\d]{0,15}$/)
    .withMessage('Please provide a valid phone number'),

  body('password')
    .isLength({ min: 8, max: 128 })
    .withMessage('Password must be between 8 and 128 characters')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, and one number'),

  body('role')
    .optional()
    .isIn(['admin', 'user'])
    .withMessage('Role must be either admin or user'),

  body('isVerified')
    .optional()
    .isBoolean()
    .withMessage('isVerified must be a boolean'),

  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean'),

  body('currentPoints')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Current points must be a non-negative integer'),

  handleValidationErrors
];

// Validate user update (Admin only)
const validateUpdateUser = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),

  body('username')
    .optional()
    .isLength({ min: 3, max: 50 })
    .withMessage('Username must be between 3 and 50 characters')
    .matches(/^[a-zA-Z0-9_]+$/)
    .withMessage('Username can only contain letters, numbers, and underscores')
    .toLowerCase(),

  body('email')
    .optional()
    .isEmail()
    .withMessage('Please provide a valid email address')
    .isLength({ max: 100 })
    .withMessage('Email must be less than 100 characters')
    .normalizeEmail(),

  body('phoneNumber')
    .optional({ nullable: true })
    .matches(/^[\+]?[1-9][\d]{0,15}$/)
    .withMessage('Please provide a valid phone number'),

  body('role')
    .optional()
    .isIn(['admin', 'user'])
    .withMessage('Role must be either admin or user'),

  body('profilePicture')
    .optional({ nullable: true })
    .isURL()
    .withMessage('Profile picture must be a valid URL'),

  body('isVerified')
    .optional()
    .isBoolean()
    .withMessage('isVerified must be a boolean'),

  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean'),

  body('currentPoints')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Current points must be a non-negative integer'),

  body('twoFactorEnabled')
    .optional()
    .isBoolean()
    .withMessage('twoFactorEnabled must be a boolean'),

  handleValidationErrors
];

// Validate password reset (Admin only)
const validateResetPassword = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),

  body('newPassword')
    .isLength({ min: 8, max: 128 })
    .withMessage('New password must be between 8 and 128 characters')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('New password must contain at least one uppercase letter, one lowercase letter, and one number'),

  handleValidationErrors
];

// Validate user ID parameter
const validateUserId = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),

  handleValidationErrors
];

// Validate user ID parameter for profile access
const validateProfileAccess = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),

  handleValidationErrors
];

// Sanitize input middleware
const sanitizeInputs = (fields) => {
  return (req, res, next) => {
    fields.forEach(field => {
      if (req.body[field]) {
        req.body[field] = sanitizeInput(req.body[field]);
      }
    });
    next();
  };
};

// Custom validators
const customValidators = {
  isStrongPassword: (value) => {
    const validation = validatePassword(value);
    if (!validation.isValid) {
      throw new Error(validation.errors.join(', '));
    }
    return true;
  },
  
  isValidPhoneNumber: (value) => {
    if (!value) return true; // Phone number is optional
    const phoneRegex = /^[+]?[\d\s\-()]+$/;
    if (!phoneRegex.test(value)) {
      throw new Error('Invalid phone number format');
    }
    return true;
  },
  
  isValidRole: (value) => {
    const validRoles = ['admin', 'user'];
    if (!validRoles.includes(value)) {
      throw new Error('Invalid role. Must be either admin or user');
    }
    return true;
  },

  isValidEmailAddress: (value) => {
    if (!isValidEmail(value)) {
      throw new Error('Please provide a valid email address');
    }
    return true;
  }
};

// Validation rules for signup
const validateSignup = [
  body('username')
    .trim()
    .isLength({ min: 3, max: 50 })
    .withMessage('Username must be between 3 and 50 characters')
    .isAlphanumeric()
    .withMessage('Username must contain only letters and numbers')
    .notEmpty()
    .withMessage('Username is required'),
    
  body('email')
    .isEmail()
    .withMessage('Please provide a valid email address')
    .trim()
    .custom(customValidators.isValidEmailAddress)
    .customSanitizer(emailSanitizer)
    .isLength({ max: 100 })
    .withMessage('Email must not exceed 100 characters'),
    
  body('phoneNumber')
    .optional()
    .trim()
    .custom(customValidators.isValidPhoneNumber),
    
  body('password')
    .isLength({ min: 8, max: 128 })
    .withMessage('Password must be between 8 and 128 characters')
    .custom(customValidators.isStrongPassword),
    
  body('confirmPassword')
    .custom((value, { req }) => {
      if (value !== req.body.password) {
        throw new Error('Password confirmation does not match password');
      }
      return true;
    }),
    
  sanitizeInputs(['username', 'email', 'phoneNumber']),
  handleValidationErrors
];

// Validation rules for login
const validateLogin = [
  body('identifier')
    .trim()
    .notEmpty()
    .withMessage('Username or email is required')
    .isLength({ min: 3, max: 100 })
    .withMessage('Identifier must be between 3 and 100 characters'),
    
  body('password')
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 1, max: 128 })
    .withMessage('Invalid password length'),
    
  sanitizeInputs(['identifier']),
  handleValidationErrors
];

// Validation rules for password change
const validatePasswordChange = [
  body('currentPassword')
    .notEmpty()
    .withMessage('Current password is required'),
    
  body('newPassword')
    .isLength({ min: 8, max: 128 })
    .withMessage('New password must be between 8 and 128 characters')
    .custom(customValidators.isStrongPassword),
    
  body('confirmNewPassword')
    .custom((value, { req }) => {
      if (value !== req.body.newPassword) {
        throw new Error('New password confirmation does not match new password');
      }
      return true;
    }),
    
  handleValidationErrors
];

// Validation rules for profile update
const validateProfileUpdate = [
  body('username')
    .optional()
    .trim()
    .isLength({ min: 3, max: 50 })
    .withMessage('Username must be between 3 and 50 characters')
    .isAlphanumeric()
    .withMessage('Username can only contain letters, numbers, and underscores')
    .toLowerCase(),

  body('email')
    .optional()
    .trim()
    .isEmail()
    .withMessage('Please provide a valid email address')
    .custom(customValidators.isValidEmailAddress)
    .customSanitizer(emailSanitizer)
    .isLength({ max: 100 })
    .withMessage('Email must not exceed 100 characters'),
    
  body('phoneNumber')
    .optional()
    .trim()
    .custom(customValidators.isValidPhoneNumber),
    
  body('profilePicture')
    .optional()
    .isURL()
    .withMessage('Profile picture must be a valid URL'),
    
  sanitizeInputs(['username', 'email', 'phoneNumber']),
  handleValidationErrors
];

// Validation rules for admin operations
const validateAdminUserUpdate = [
  body('role')
    .optional()
    .custom(customValidators.isValidRole),
    
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean value'),
    
  body('isVerified')
    .optional()
    .isBoolean()
    .withMessage('isVerified must be a boolean value'),
    
  handleValidationErrors
];

// Validation rules for refresh token
const validateRefreshToken = [
  body('refreshToken')
    .notEmpty()
    .withMessage('Refresh token is required')
    .isJWT()
    .withMessage('Invalid refresh token format'),
    
  handleValidationErrors
];

// Validation rules for pagination
const validatePagination = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
    
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100'),
    
  query('sortBy')
    .optional()
    .isIn(['createdAt', 'updatedAt', 'username', 'email', 'role'])
    .withMessage('Invalid sort field'),
    
  query('sortOrder')
    .optional()
    .isIn(['ASC', 'DESC'])
    .withMessage('Sort order must be ASC or DESC'),
    
  handleValidationErrors
];

// Validation rules for ID parameters (original)
const validateIdParam = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('ID must be a positive integer'),
    
  handleValidationErrors
];

// NEW: Validation rules for redemption ID parameter
const validateRedemptionIdParam = [
  param('redemptionId')
    .isInt({ min: 1 })
    .withMessage('Redemption ID must be a positive integer'),
    
  handleValidationErrors
];

// NEW: Validation rules for user ID parameter  
const validateUserIdParam = [
  param('userId')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),
    
  handleValidationErrors
];

// NEW: Flexible ID parameter validator (can specify parameter name)
const validateDynamicIdParam = (paramName = 'id') => [
  param(paramName)
    .isInt({ min: 1 })
    .withMessage(`${paramName} must be a positive integer`),
    
  handleValidationErrors
];

// Validation rules for category creation
const validateCategoryCreate = [
  body('name')
    .trim()
    .notEmpty()
    .withMessage('Category name is required')
    .isLength({ min: 2, max: 100 })
    .withMessage('Category name must be between 2 and 100 characters'),
    
  body('slug')
    .optional()
    .trim()
    .isSlug()
    .withMessage('Slug must be a valid slug format')
    .isLength({ min: 2, max: 120 })
    .withMessage('Slug must be between 2 and 120 characters'),
    
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description must not exceed 1000 characters'),
    
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean value'),
    
  body('sortOrder')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Sort order must be a non-negative integer'),
    
  sanitizeInputs(['name', 'slug', 'description']),
  handleValidationErrors
];

// Validation rules for category update
const validateCategoryUpdate = [
  body('name')
    .optional()
    .trim()
    .notEmpty()
    .withMessage('Category name cannot be empty')
    .isLength({ min: 2, max: 100 })
    .withMessage('Category name must be between 2 and 100 characters'),
    
  body('slug')
    .optional()
    .trim()
    .isSlug()
    .withMessage('Slug must be a valid slug format')
    .isLength({ min: 2, max: 120 })
    .withMessage('Slug must be between 2 and 120 characters'),
    
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description must not exceed 1000 characters'),
    
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean value'),
    
  body('sortOrder')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Sort order must be a non-negative integer'),
    
  sanitizeInputs(['name', 'slug', 'description']),
  handleValidationErrors
];

// Validation rules for product creation
const validateProductCreate = [
  body('title')
    .trim()
    .notEmpty()
    .withMessage('Product title is required')
    .isLength({ min: 2, max: 200 })
    .withMessage('Product title must be between 2 and 200 characters'),
    
  body('slug')
    .optional()
    .trim()
    .isSlug()
    .withMessage('Slug must be a valid slug format')
    .isLength({ min: 2, max: 220 })
    .withMessage('Slug must be between 2 and 220 characters'),
    
  body('description')
    .optional()
    .trim()
    .isLength({ max: 5000 })
    .withMessage('Description must not exceed 5000 characters'),
    
  body('points')
    .isInt({ min: 0 })
    .withMessage('Points must be a non-negative integer'),
    
  body('price')
    .isFloat({ min: 0 })
    .withMessage('Price must be a non-negative number'),
    
  body('url')
    .optional()
    .trim()
    .isURL()
    .withMessage('URL must be a valid URL')
    .isLength({ max: 500 })
    .withMessage('URL must not exceed 500 characters'),
    
  body('categoryId')
    .isInt({ min: 1 })
    .withMessage('Category ID must be a positive integer'),
    
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean value'),
    
  body('isFeatured')
    .optional()
    .isBoolean()
    .withMessage('isFeatured must be a boolean value'),
    
  body('stockQuantity')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Stock quantity must be a non-negative integer'),
    
  body('sortOrder')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Sort order must be a non-negative integer'),
    
  body('metaTitle')
    .optional()
    .trim()
    .isLength({ max: 200 })
    .withMessage('Meta title must not exceed 200 characters'),
    
  body('metaDescription')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Meta description must not exceed 500 characters'),
    
  sanitizeInputs(['title', 'slug', 'description', 'url', 'metaTitle', 'metaDescription']),
  handleValidationErrors
];

// Validation rules for product update
const validateProductUpdate = [
  body('title')
    .optional()
    .trim()
    .notEmpty()
    .withMessage('Product title cannot be empty')
    .isLength({ min: 2, max: 200 })
    .withMessage('Product title must be between 2 and 200 characters'),
    
  body('slug')
    .optional()
    .trim()
    .isSlug()
    .withMessage('Slug must be a valid slug format')
    .isLength({ min: 2, max: 220 })
    .withMessage('Slug must be between 2 and 220 characters'),
    
  body('description')
    .optional()
    .trim()
    .isLength({ max: 5000 })
    .withMessage('Description must not exceed 5000 characters'),
    
  body('points')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Points must be a non-negative integer'),
    
  body('price')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Price must be a non-negative number'),
    
  body('url')
    .optional()
    .trim()
    .isURL()
    .withMessage('URL must be a valid URL')
    .isLength({ max: 500 })
    .withMessage('URL must not exceed 500 characters'),
    
  body('categoryId')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Category ID must be a positive integer'),
    
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean value'),
    
  body('isFeatured')
    .optional()
    .isBoolean()
    .withMessage('isFeatured must be a boolean value'),
    
  body('stockQuantity')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Stock quantity must be a non-negative integer'),
    
  body('sortOrder')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Sort order must be a non-negative integer'),
    
  body('metaTitle')
    .optional()
    .trim()
    .isLength({ max: 200 })
    .withMessage('Meta title must not exceed 200 characters'),
    
  body('metaDescription')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Meta description must not exceed 500 characters'),
    
  sanitizeInputs(['title', 'slug', 'description', 'url', 'metaTitle', 'metaDescription']),
  handleValidationErrors
];

// Validation rules for search and filtering
const validateProductFilter = [
  query('category')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Category must be a positive integer'),
    
  query('minPrice')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Minimum price must be a non-negative number'),
    
  query('maxPrice')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Maximum price must be a non-negative number'),
    
  query('minPoints')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Minimum points must be a non-negative integer'),
    
  query('maxPoints')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Maximum points must be a non-negative integer'),
    
  query('featured')
    .optional()
    .isBoolean()
    .withMessage('Featured must be a boolean value'),
    
  query('search')
    .optional()
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Search query must be between 1 and 100 characters'),
    
  handleValidationErrors
];

// Validation rules for point redemption request
const validateRedemptionRequest = [
  body('pointsToRedeem')
    .isInt({ min: 1 })
    .withMessage('Points to redeem must be a positive integer'),
    
  body('redemptionType')
    .trim()
    .notEmpty()
    .withMessage('Redemption type is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('Redemption type must be between 2 and 50 characters'),
    
  body('redemptionValue')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Redemption value must be a non-negative number'),
    
  body('redemptionDetails')
    .optional()
    .isObject()
    .withMessage('Redemption details must be an object'),
    
  sanitizeInputs(['redemptionType']),
  handleValidationErrors
];

// Validation rules for manual point award (Admin only)
const validateManualPointAward = [
  body('userId')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),
    
  body('activityCode')
    .trim()
    .notEmpty()
    .withMessage('Activity code is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('Activity code must be between 2 and 50 characters'),
    
  body('customAmount')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Custom amount must be a positive integer'),
    
  body('description')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Description must not exceed 500 characters'),
    
  body('referenceId')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Reference ID must not exceed 100 characters'),
    
  body('referenceType')
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage('Reference type must not exceed 50 characters'),
    
  sanitizeInputs(['activityCode', 'description', 'referenceId', 'referenceType']),
  handleValidationErrors
];

// Validation rules for redemption processing (Admin only)
const validateRedemptionProcessing = [
  body('action')
    .isIn(['approve', 'reject'])
    .withMessage('Action must be either "approve" or "reject"'),
    
  body('notes')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Notes must not exceed 1000 characters'),
    
  sanitizeInputs(['notes']),
  handleValidationErrors
];

// Validation rules for transaction filtering
const validateTransactionFilter = [
  query('userId')
    .optional()
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),
    
  query('activityType')
    .optional()
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Activity type must be between 1 and 50 characters'),
    
  query('transactionType')
    .optional()
    .isIn(['credit', 'debit'])
    .withMessage('Transaction type must be either "credit" or "debit"'),
    
  query('startDate')
    .optional()
    .isISO8601()
    .withMessage('Start date must be a valid ISO 8601 date'),
    
  query('endDate')
    .optional()
    .isISO8601()
    .withMessage('End date must be a valid ISO 8601 date'),
    
  handleValidationErrors
];


module.exports = {
  validateCreateUser,
  validateUpdateUser,
  validateResetPassword,
  validateUserId: validateProfileAccess, // Renamed for clarity
  validateProfileAccess,
  validateProfileUpdate,
  validateSignup,
  validateLogin,
  validatePasswordChange,
  validateAdminUserUpdate,
  validateRefreshToken,
  validatePagination,
  validateIdParam,
  validateRedemptionIdParam,   // NEW
  validateUserIdParam,         // NEW  
  validateDynamicIdParam,      // NEW
  validateCategoryCreate,
  validateCategoryUpdate,
  validateProductCreate,
  validateProductUpdate,
  validateProductFilter,
  validateRedemptionRequest,
  validateManualPointAward,
  validateRedemptionProcessing,
  validateTransactionFilter,
  handleValidationErrors,
  sanitizeInputs,
  customValidators
};


================================================
FILE: src/models/Category.js
================================================
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Category = sequelize.define('Category', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true,
    validate: {
      len: [2, 100],
      notEmpty: true
    }
  },
  slug: {
    type: DataTypes.STRING(120),
    allowNull: false,
    unique: true,
    validate: {
      len: [2, 120],
      is: /^[a-z0-9-]+$/i
    }
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  image: {
    type: DataTypes.STRING(500),
    allowNull: true,
    validate: {
      len: [0, 500]
    }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
    field: 'is_active'
  },
  sortOrder: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    field: 'sort_order'
  },
  createdBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'created_by'
  },
  updatedBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'updated_by'
  }
}, {
  tableName: 'categories',
  timestamps: true,
  paranoid: true, // Enable soft delete
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  deletedAt: 'deleted_at', // Specify the deletedAt field
  hooks: {
    beforeValidate: (category) => {
      // Generate slug from name if not provided
      if (category.name && !category.slug) {
        category.slug = category.name
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .trim('-');
      }
    }
  }
});

// Instance methods
Category.prototype.toSafeJSON = function() {
  const values = Object.assign({}, this.get());
  return values;
};

// Static methods
Category.findActiveCategories = function(options = {}) {
  return this.findAll({
    where: { isActive: true },
    order: [['sortOrder', 'ASC'], ['name', 'ASC']],
    ...options
  });
};

Category.findBySlug = function(slug) {
  return this.findOne({
    where: { slug, isActive: true }
  });
};

Category.findWithProductCount = function(options = {}) {
  const Product = require('./Product');
  
  return this.findAll({
    attributes: {
      include: [
        [
          sequelize.fn('COUNT', sequelize.col('Products.id')),
          'productCount'
        ]
      ]
    },
    include: [{
      model: Product,
      attributes: [],
      required: false,
      where: { isActive: true }
    }],
    group: ['Category.id'],
    order: [['sortOrder', 'ASC'], ['name', 'ASC']],
    ...options
  });
};

module.exports = Category;


================================================
FILE: src/models/index.js
================================================
const { sequelize } = require('../config/database');
const User = require('./User');
const Category = require('./Category');
const Product = require('./Product');
const ProductImage = require('./ProductImage');
const PointTransaction = require('./PointTransaction');
const PointActivity = require('./PointActivity');
const PointRedemption = require('./PointRedemption');

// Define associations

// User associations
User.hasMany(Category, {
  foreignKey: 'createdBy',
  as: 'createdCategories'
});

User.hasMany(Category, {
  foreignKey: 'updatedBy',
  as: 'updatedCategories'
});

User.hasMany(Product, {
  foreignKey: 'createdBy',
  as: 'createdProducts'
});

User.hasMany(Product, {
  foreignKey: 'updatedBy',
  as: 'updatedProducts'
});

User.hasMany(PointTransaction, {
  foreignKey: 'userId',
  as: 'pointTransactions'
});

User.hasMany(PointTransaction, {
  foreignKey: 'processedBy',
  as: 'processedTransactions'
});

User.hasMany(PointRedemption, {
  foreignKey: 'userId',
  as: 'pointRedemptions'
});

User.hasMany(PointRedemption, {
  foreignKey: 'processedBy',
  as: 'processedRedemptions'
});

User.hasMany(PointActivity, {
  foreignKey: 'createdBy',
  as: 'createdActivities'
});

// Category associations
Category.belongsTo(User, {
  foreignKey: 'createdBy',
  as: 'creator'
});

Category.belongsTo(User, {
  foreignKey: 'updatedBy',
  as: 'updater'
});

Category.hasMany(Product, {
  foreignKey: 'categoryId',
  as: 'products'
});

// Product associations
Product.belongsTo(User, {
  foreignKey: 'createdBy',
  as: 'creator'
});

Product.belongsTo(User, {
  foreignKey: 'updatedBy',
  as: 'updater'
});

Product.belongsTo(Category, {
  foreignKey: 'categoryId',
  as: 'category'
});

Product.hasMany(ProductImage, {
  foreignKey: 'productId',
  as: 'images'
});

// ProductImage associations
ProductImage.belongsTo(Product, {
  foreignKey: 'productId',
  as: 'product'
});

// PointTransaction associations
PointTransaction.belongsTo(User, {
  foreignKey: 'userId',
  as: 'user'
});

PointTransaction.belongsTo(User, {
  foreignKey: 'processedBy',
  as: 'processor'
});

PointTransaction.belongsTo(PointRedemption, {
  foreignKey: 'referenceId',
  constraints: false,
  scope: {
    referenceType: 'redemption'
  },
  as: 'redemption'
});

// PointActivity associations
PointActivity.belongsTo(User, {
  foreignKey: 'createdBy',
  as: 'creator'
});

PointActivity.hasMany(PointTransaction, {
  foreignKey: 'activityType',
  sourceKey: 'activityCode',
  constraints: false,
  as: 'transactions'
});

// PointRedemption associations
PointRedemption.belongsTo(User, {
  foreignKey: 'userId',
  as: 'user'
});

PointRedemption.belongsTo(User, {
  foreignKey: 'processedBy',
  as: 'processor'
});

PointRedemption.belongsTo(PointTransaction, {
  foreignKey: 'transactionId',
  as: 'transaction'
});

PointRedemption.hasMany(PointTransaction, {
  foreignKey: 'referenceId',
  constraints: false,
  scope: {
    referenceType: 'redemption'
  },
  as: 'relatedTransactions'
});

// Sync database (optional - only in development)
const syncDatabase = async (force = false) => {
  try {
    await sequelize.sync({ force, alter: !force });
    console.log('Database synchronized successfully');
  } catch (error) {
    console.error('Error synchronizing database:', error);
    throw error;
  }
};

// Export all models and utilities
module.exports = {
  sequelize,
  User,
  Category,
  Product,
  ProductImage,
  PointTransaction,
  PointActivity,
  PointRedemption,
  syncDatabase
};


================================================
FILE: src/models/PointActivity.js
================================================
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const PointActivity = sequelize.define('PointActivity', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  activityCode: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
    field: 'activity_code'
  },
  activityName: {
    type: DataTypes.STRING(100),
    allowNull: false,
    field: 'activity_name'
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  pointsReward: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'points_reward',
    validate: {
      min: 0,
      isInt: true
    }
  },
  dailyLimit: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'daily_limit',
    validate: {
      min: 0,
      isInt: true
    }
  },
  totalLimit: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'total_limit',
    validate: {
      min: 0,
      isInt: true
    }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
    field: 'is_active'
  },
  validFrom: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'valid_from'
  },
  validUntil: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'valid_until'
  },
  createdBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'created_by',
    references: {
      model: 'users',
      key: 'id'
    }
  }
}, {
  tableName: 'point_activities',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  paranoid: true,
  deletedAt: 'deleted_at'
});

// Instance methods
PointActivity.prototype.isValidNow = function() {
  const now = new Date();
  
  if (!this.isActive) {
    return false;
  }
  
  if (this.validFrom && now < this.validFrom) {
    return false;
  }
  
  if (this.validUntil && now > this.validUntil) {
    return false;
  }
  
  return true;
};

PointActivity.prototype.canUserEarn = async function(userId) {
  const PointTransaction = require('./PointTransaction');
  
  if (!this.isValidNow()) {
    return {
      canEarn: false,
      reason: 'Activity is not currently active'
    };
  }

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);

  // Check daily limit
  if (this.dailyLimit) {
    const todayTransactions = await PointTransaction.count({
      where: {
        userId,
        activityType: this.activityCode,
        status: 'completed',
        created_at: {
          [sequelize.Sequelize.Op.gte]: today,
          [sequelize.Sequelize.Op.lt]: tomorrow
        }
      }
    });

    if (todayTransactions >= this.dailyLimit) {
      return {
        canEarn: false,
        reason: `Daily limit of ${this.dailyLimit} reached for this activity`
      };
    }
  }

  // Check total limit
  if (this.totalLimit) {
    const totalTransactions = await PointTransaction.count({
      where: {
        userId,
        activityType: this.activityCode,
        status: 'completed'
      }
    });

    if (totalTransactions >= this.totalLimit) {
      return {
        canEarn: false,
        reason: `Total limit of ${this.totalLimit} reached for this activity`
      };
    }
  }

  return {
    canEarn: true,
    reason: null
  };
};

// Static methods
PointActivity.findByCode = function(activityCode) {
  return this.findOne({
    where: { activityCode }
  });
};

PointActivity.findActiveActivities = function() {
  const now = new Date();
  
  return this.findAll({
    where: {
      isActive: true,
      [sequelize.Sequelize.Op.or]: [
        { validFrom: null },
        { validFrom: { [sequelize.Sequelize.Op.lte]: now } }
      ],
      [sequelize.Sequelize.Op.or]: [
        { validUntil: null },
        { validUntil: { [sequelize.Sequelize.Op.gte]: now } }
      ]
    },
    order: [['activity_name', 'ASC']]
  });
};

PointActivity.getActivityStatistics = async function() {
  const PointTransaction = require('./PointTransaction');
  
  const stats = await sequelize.query(`
    SELECT 
      pa.id,
      pa.activity_code,
      pa.activity_name,
      pa.points_reward,
      pa.daily_limit,
      pa.total_limit,
      pa.is_active,
      COUNT(pt.id) as usage_count,
      SUM(CASE WHEN pt.status = 'completed' THEN pt.amount ELSE 0 END) as total_points_awarded,
      COUNT(DISTINCT pt.user_id) as unique_users
    FROM point_activities pa
    LEFT JOIN point_transactions pt ON pa.activity_code = pt.activity_type
    GROUP BY pa.id, pa.activity_code, pa.activity_name, pa.points_reward, pa.daily_limit, pa.total_limit, pa.is_active
    ORDER BY total_points_awarded DESC
  `, {
    type: sequelize.QueryTypes.SELECT
  });

  return stats;
};

module.exports = PointActivity;


================================================
FILE: src/models/PointRedemption.js
================================================
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const PointRedemption = sequelize.define('PointRedemption', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'user_id',
    references: {
      model: 'users',
      key: 'id'
    }
  },
  pointsRedeemed: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'points_redeemed',
    validate: {
      min: 1,
      isInt: true
    }
  },
  redemptionType: {
    type: DataTypes.STRING(50),
    allowNull: false,
    field: 'redemption_type'
  },
  redemptionValue: {
    type: DataTypes.DECIMAL(12, 2),
    allowNull: true,
    field: 'redemption_value'
  },
  redemptionDetails: {
    type: DataTypes.JSON,
    allowNull: true,
    field: 'redemption_details'
  },
  status: {
    type: DataTypes.ENUM('pending', 'approved', 'rejected', 'completed', 'cancelled'),
    defaultValue: 'pending'
  },
  requestedAt: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    field: 'requested_at'
  },
  processedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'processed_at'
  },
  processedBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'processed_by',
    references: {
      model: 'users',
      key: 'id'
    }
  },
  adminNotes: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'admin_notes'
  },
  transactionId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'transaction_id',
    references: {
      model: 'point_transactions',
      key: 'id'
    }
  }
}, {
  tableName: 'point_redemptions',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at'
});

// Instance methods
PointRedemption.prototype.approve = async function(adminId, adminNotes = null) {
  const PointTransaction = require('./PointTransaction');
  const User = require('./User');

  if (this.status !== 'pending') {
    throw new Error('Only pending redemptions can be approved');
  }

  // Get user's current points
  const user = await User.findByPk(this.userId);
  if (!user) {
    throw new Error('User not found');
  }

  if (user.currentPoints < this.pointsRedeemed) {
    throw new Error('User has insufficient points for this redemption');
  }

  const transaction = await sequelize.transaction();

  try {
    // Create debit transaction
    const pointTransaction = await PointTransaction.create({
      userId: this.userId,
      transactionType: 'debit',
      amount: this.pointsRedeemed,
      balanceBefore: user.currentPoints,
      activityType: 'REDEMPTION',
      activityDescription: `Points redeemed for ${this.redemptionType}`,
      referenceId: this.id.toString(),
      referenceType: 'redemption',
      processedBy: adminId,
      metadata: {
        redemptionType: this.redemptionType,
        redemptionDetails: this.redemptionDetails
      }
    }, { transaction });

    // Update redemption status
    await this.update({
      status: 'approved',
      processedAt: new Date(),
      processedBy: adminId,
      adminNotes,
      transactionId: pointTransaction.id
    }, { transaction });

    await transaction.commit();
    return this;
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
};

PointRedemption.prototype.reject = async function(adminId, adminNotes) {
  if (this.status !== 'pending') {
    throw new Error('Only pending redemptions can be rejected');
  }

  return this.update({
    status: 'rejected',
    processedAt: new Date(),
    processedBy: adminId,
    adminNotes
  });
};

PointRedemption.prototype.cancel = async function() {
  if (!['pending', 'approved'].includes(this.status)) {
    throw new Error('Only pending or approved redemptions can be cancelled');
  }

  const updates = {
    status: 'cancelled',
    processedAt: new Date()
  };

  // If redemption was approved, we need to refund the points
  if (this.status === 'approved' && this.transactionId) {
    const PointTransaction = require('./PointTransaction');
    const User = require('./User');

    const user = await User.findByPk(this.userId);
    if (user) {
      // Create credit transaction to refund points
      await PointTransaction.create({
        userId: this.userId,
        transactionType: 'credit',
        amount: this.pointsRedeemed,
        balanceBefore: user.currentPoints,
        activityType: 'REFUND',
        activityDescription: `Points refunded from cancelled redemption`,
        referenceId: this.id.toString(),
        referenceType: 'redemption_refund',
        metadata: {
          originalRedemptionId: this.id,
          redemptionType: this.redemptionType
        }
      });
    }
  }

  return this.update(updates);
};

// Static methods
PointRedemption.getUserRedemptions = function(userId, options = {}) {
  const {
    page = 1,
    limit = 20,
    status,
    redemptionType
  } = options;

  const whereClause = { userId };
  
  if (status) {
    whereClause.status = status;
  }
  
  if (redemptionType) {
    whereClause.redemptionType = redemptionType;
  }

  return this.findAndCountAll({
    where: whereClause,
    order: [['requested_at', 'DESC']], // Use actual database field name
    limit: parseInt(limit),
    offset: (parseInt(page) - 1) * parseInt(limit)
  });
};

PointRedemption.getAllRedemptions = function(options = {}) {
  const {
    page = 1,
    limit = 20,
    status,
    redemptionType,
    userId
  } = options;

  const whereClause = {};
  
  if (status) {
    whereClause.status = status;
  }
  
  if (redemptionType) {
    whereClause.redemptionType = redemptionType;
  }
  
  if (userId) {
    whereClause.userId = userId;
  }

  return this.findAndCountAll({
    where: whereClause,
    order: [['requested_at', 'DESC']], // Use actual database field name
    limit: parseInt(limit),
    offset: (parseInt(page) - 1) * parseInt(limit)
  });
};

module.exports = PointRedemption;


================================================
FILE: src/models/PointTransaction.js
================================================
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const PointTransaction = sequelize.define('PointTransaction', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'user_id',
    references: {
      model: 'users',
      key: 'id'
    }
  },
  transactionType: {
    type: DataTypes.ENUM('credit', 'debit'),
    allowNull: false,
    field: 'transaction_type'
  },
  amount: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 1,
      isInt: true
    }
  },
  balanceBefore: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'balance_before',
    validate: {
      min: 0,
      isInt: true
    }
  },
  balanceAfter: {
    type: DataTypes.VIRTUAL,
    get() {
      const balance = this.balanceBefore;
      const amount = this.amount;
      const type = this.transactionType;
      
      if (type === 'credit') {
        return balance + amount;
      } else {
        return balance - amount;
      }
    }
  },
  activityType: {
    type: DataTypes.STRING(50),
    allowNull: false,
    field: 'activity_type'
  },
  activityDescription: {
    type: DataTypes.STRING(255),
    allowNull: true,
    field: 'activity_description'
  },
  referenceId: {
    type: DataTypes.STRING(50),
    allowNull: true,
    field: 'reference_id'
  },
  referenceType: {
    type: DataTypes.STRING(50),
    allowNull: true,
    field: 'reference_type'
  },
  status: {
    type: DataTypes.ENUM('pending', 'completed', 'failed', 'cancelled'),
    defaultValue: 'completed'
  },
  processedBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'processed_by',
    references: {
      model: 'users',
      key: 'id'
    }
  },
  processedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'processed_at',
    defaultValue: DataTypes.NOW
  },
  metadata: {
    type: DataTypes.JSON,
    allowNull: true,
    comment: 'Additional data related to the transaction'
  },
  notes: {
    type: DataTypes.TEXT,
    allowNull: true,
    comment: 'Administrative notes about the transaction'
  }
}, {
  tableName: 'point_transactions',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    {
      fields: ['user_id']
    },
    {
      fields: ['activity_type']
    },
    {
      fields: ['transaction_type']
    },
    {
      fields: ['status']
    },
    {
      fields: ['created_at']
    },
    {
      fields: ['user_id', 'activity_type']
    },
    {
      fields: ['user_id', 'created_at']
    }
  ]
});

// Instance methods
PointTransaction.prototype.toSafeJSON = function() {
  const values = Object.assign({}, this.get());
  
  // Include the virtual balanceAfter field
  values.balanceAfter = this.balanceAfter;
  
  return values;
};

// Static methods
PointTransaction.getUserTransactions = function(userId, options = {}) {
  const {
    page = 1,
    limit = 20,
    transactionType,
    activityType,
    status = 'completed',
    startDate,
    endDate
  } = options;

  const whereClause = { 
    userId,
    status: status || 'completed'
  };
  
  if (transactionType) {
    whereClause.transactionType = transactionType;
  }
  
  if (activityType) {
    whereClause.activityType = activityType;
  }
  
  if (startDate || endDate) {
    whereClause.created_at = {};
    if (startDate) {
      whereClause.created_at[sequelize.Sequelize.Op.gte] = new Date(startDate);
    }
    if (endDate) {
      whereClause.created_at[sequelize.Sequelize.Op.lte] = new Date(endDate);
    }
  }

  return this.findAndCountAll({
    where: whereClause,
    order: [['created_at', 'DESC']],
    limit: parseInt(limit),
    offset: (parseInt(page) - 1) * parseInt(limit)
  });
};

PointTransaction.getUserPointsSummary = async function(userId) {
  const creditResult = await this.findOne({
    where: { 
      userId, 
      transactionType: 'credit',
      status: 'completed'
    },
    attributes: [
      [sequelize.fn('SUM', sequelize.col('amount')), 'totalCredits'],
      [sequelize.fn('COUNT', sequelize.col('id')), 'creditCount']
    ]
  });

  const debitResult = await this.findOne({
    where: { 
      userId, 
      transactionType: 'debit',
      status: 'completed'
    },
    attributes: [
      [sequelize.fn('SUM', sequelize.col('amount')), 'totalDebits'],
      [sequelize.fn('COUNT', sequelize.col('id')), 'debitCount']
    ]
  });

  const totalCredits = parseInt(creditResult?.dataValues?.totalCredits) || 0;
  const totalDebits = parseInt(debitResult?.dataValues?.totalDebits) || 0;
  const creditCount = parseInt(creditResult?.dataValues?.creditCount) || 0;
  const debitCount = parseInt(debitResult?.dataValues?.debitCount) || 0;

  return {
    totalEarned: totalCredits,
    totalSpent: totalDebits,
    netBalance: totalCredits - totalDebits,
    totalTransactions: creditCount + debitCount,
    creditTransactions: creditCount,
    debitTransactions: debitCount
  };
};

PointTransaction.getActivityStatistics = async function(activityType = null, options = {}) {
  const {
    startDate,
    endDate,
    status = 'completed'
  } = options;

  const whereClause = { status };
  
  if (activityType) {
    whereClause.activityType = activityType;
  }
  
  if (startDate || endDate) {
    whereClause.created_at = {};
    if (startDate) {
      whereClause.created_at[sequelize.Sequelize.Op.gte] = new Date(startDate);
    }
    if (endDate) {
      whereClause.created_at[sequelize.Sequelize.Op.lte] = new Date(endDate);
    }
  }

  const stats = await this.findAll({
    where: whereClause,
    attributes: [
      'activity_type',
      'transaction_type',
      [sequelize.fn('COUNT', sequelize.col('id')), 'transaction_count'],
      [sequelize.fn('SUM', sequelize.col('amount')), 'total_amount'],
      [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('user_id'))), 'unique_users']
    ],
    group: ['activity_type', 'transaction_type'],
    order: [['activity_type', 'ASC'], ['transaction_type', 'ASC']]
  });

  return stats;
};

PointTransaction.getSystemStatistics = async function(options = {}) {
  const {
    startDate,
    endDate,
    status = 'completed'
  } = options;

  const whereClause = { status };
  
  if (startDate || endDate) {
    whereClause.created_at = {};
    if (startDate) {
      whereClause.created_at[sequelize.Sequelize.Op.gte] = new Date(startDate);
    }
    if (endDate) {
      whereClause.created_at[sequelize.Sequelize.Op.lte] = new Date(endDate);
    }
  }

  const [totalStats, activityStats] = await Promise.all([
    this.findOne({
      where: whereClause,
      attributes: [
        [sequelize.fn('COUNT', sequelize.col('id')), 'totalTransactions'],
        [sequelize.fn('SUM', 
          sequelize.literal("CASE WHEN transaction_type = 'credit' THEN amount ELSE 0 END")
        ), 'totalPointsAwarded'],
        [sequelize.fn('SUM', 
          sequelize.literal("CASE WHEN transaction_type = 'debit' THEN amount ELSE 0 END")
        ), 'totalPointsRedeemed'],
        [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('user_id'))), 'activeUsers']
      ]
    }),
    
    this.findAll({
      where: whereClause,
      attributes: [
        'activity_type',
        [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
        [sequelize.fn('SUM', sequelize.col('amount')), 'total'],
        [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('user_id'))), 'users']
      ],
      group: ['activity_type'],
      order: [[sequelize.fn('SUM', sequelize.col('amount')), 'DESC']]
    })
  ]);

  return {
    overview: {
      totalTransactions: parseInt(totalStats?.dataValues?.totalTransactions) || 0,
      totalPointsAwarded: parseInt(totalStats?.dataValues?.totalPointsAwarded) || 0,
      totalPointsRedeemed: parseInt(totalStats?.dataValues?.totalPointsRedeemed) || 0,
      activeUsers: parseInt(totalStats?.dataValues?.activeUsers) || 0,
      netPointsInCirculation: (parseInt(totalStats?.dataValues?.totalPointsAwarded) || 0) - (parseInt(totalStats?.dataValues?.totalPointsRedeemed) || 0)
    },
    byActivity: activityStats.map(stat => ({
      activityType: stat.activity_type,
      transactionCount: parseInt(stat.dataValues.count),
      totalPoints: parseInt(stat.dataValues.total),
      uniqueUsers: parseInt(stat.dataValues.users)
    }))
  };
};

module.exports = PointTransaction;


================================================
FILE: src/models/Product.js
================================================
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Product = sequelize.define('Product', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  title: {
    type: DataTypes.STRING(200),
    allowNull: false,
    validate: {
      len: [2, 200],
      notEmpty: true
    }
  },
  slug: {
    type: DataTypes.STRING(220),
    allowNull: false,
    unique: true,
    validate: {
      len: [2, 220],
      is: /^[a-z0-9-]+$/i
    }
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  points: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    validate: {
      min: 0,
      isInt: true
    }
  },
  price: {
    type: DataTypes.DECIMAL(12, 2),
    allowNull: false,
    defaultValue: 0.00,
    validate: {
      min: 0,
      isDecimal: true
    }
  },
  url: {
    type: DataTypes.STRING(500),
    allowNull: true,
    validate: {
      len: [0, 500],
      isUrl: true
    }
  },
  image: {
    type: DataTypes.STRING(500),
    allowNull: true,
    validate: {
      len: [0, 500]
    }
  },
  categoryId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'category_id',
    references: {
      model: 'categories',
      key: 'id'
    }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
    field: 'is_active'
  },
  isFeatured: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'is_featured'
  },
  stockQuantity: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    field: 'stock_quantity',
    validate: {
      min: 0,
      isInt: true
    }
  },
  viewCount: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    field: 'view_count',
    validate: {
      min: 0,
      isInt: true
    }
  },
  sortOrder: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    field: 'sort_order'
  },
  metaTitle: {
    type: DataTypes.STRING(200),
    allowNull: true,
    field: 'meta_title',
    validate: {
      len: [0, 200]
    }
  },
  metaDescription: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'meta_description'
  },
  createdBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'created_by'
  },
  updatedBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'updated_by'
  },
  createdAt: {
    type: DataTypes.DATE,
    allowNull: false,
    field: 'created_at',
    defaultValue: DataTypes.NOW
  },
  updatedAt: {
    type: DataTypes.DATE,
    allowNull: false,
    field: 'updated_at',
    defaultValue: DataTypes.NOW
  }
}, {
  tableName: 'products',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  hooks: {
    beforeValidate: (product) => {
      // Generate slug from title if not provided
      if (product.title && !product.slug) {
        product.slug = product.title
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .trim('-');
      }
      
      // Generate meta title from title if not provided
      if (product.title && !product.metaTitle) {
        product.metaTitle = product.title.length > 200 
          ? product.title.substring(0, 197) + '...'
          : product.title;
      }
    }
  }
});

// Instance methods
Product.prototype.toSafeJSON = function() {
  const values = Object.assign({}, this.get());
  
  // Format price for display
  values.formattedPrice = new Intl.NumberFormat('id-ID', {
    style: 'currency',
    currency: 'IDR'
  }).format(values.price);
  
  return values;
};

Product.prototype.incrementViewCount = async function() {
  return this.increment('viewCount');
};

Product.prototype.updateStock = async function(quantity) {
  if (this.stockQuantity + quantity < 0) {
    throw new Error('Insufficient stock');
  }
  return this.increment('stockQuantity', { by: quantity });
};

// Static methods
Product.findActiveProducts = function(options = {}) {
  const Category = require('./Category');
  
  return this.findAll({
    where: { isActive: true },
    include: [{
      model: Category,
      as: 'category',
      attributes: ['id', 'name', 'slug'],
      where: { isActive: true }
    }],
    order: [['sortOrder', 'ASC'], ['created_at', 'DESC']],
    ...options
  });
};

Product.findBySlug = function(slug, includeCategory = true) {
  const includeOptions = [];
  
  if (includeCategory) {
    const Category = require('./Category');
    includeOptions.push({
      model: Category,
      as: 'category',
      attributes: ['id', 'name', 'slug']
    });
  }
  
  return this.findOne({
    where: { slug, isActive: true },
    include: includeOptions
  });
};

Product.findFeaturedProducts = function(limit = 10) {
  const Category = require('./Category');
  
  return this.findAll({
    where: { 
      isActive: true,
      isFeatured: true 
    },
    include: [{
      model: Category,
      as: 'category',
      attributes: ['id', 'name', 'slug'],
      where: { isActive: true }
    }],
    order: [['sortOrder', 'ASC'], ['viewCount', 'DESC']],
    limit
  });
};

Product.findByCategory = function(categoryId, options = {}) {
  return this.findActiveProducts({
    where: { categoryId },
    ...options
  });
};

Product.searchProducts = function(query, options = {}) {
  const Category = require('./Category');
  const { Op } = sequelize.Sequelize;
  
  return this.findAll({
    where: {
      isActive: true,
      [Op.or]: [
        { title: { [Op.like]: `%${query}%` } },
        { description: { [Op.like]: `%${query}%` } },
        { metaTitle: { [Op.like]: `%${query}%` } }
      ]
    },
    include: [{
      model: Category,
      as: 'category',
      attributes: ['id', 'name', 'slug'],
      where: { isActive: true }
    }],
    order: [['viewCount', 'DESC'], ['created_at', 'DESC']],
    ...options
  });
};

module.exports = Product;


================================================
FILE: src/models/ProductImage.js
================================================
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const ProductImage = sequelize.define('ProductImage', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  productId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'product_id',
    references: {
      model: 'products',
      key: 'id'
    }
  },
  imagePath: {
    type: DataTypes.STRING(500),
    allowNull: false,
    field: 'image_path',
    validate: {
      len: [1, 500],
      notEmpty: true
    }
  },
  altText: {
    type: DataTypes.STRING(200),
    allowNull: true,
    field: 'alt_text',
    validate: {
      len: [0, 200]
    }
  },
  isPrimary: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'is_primary'
  },
  sortOrder: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    field: 'sort_order'
  }
}, {
  tableName: 'product_images',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: false, // Only track creation time
  hooks: {
    beforeCreate: async (productImage) => {
      // If this is set as primary, unset other primary images for the same product
      if (productImage.isPrimary) {
        await ProductImage.update(
          { isPrimary: false },
          { where: { productId: productImage.productId } }
        );
      }
    },
    beforeUpdate: async (productImage) => {
      // If this is being set as primary, unset other primary images for the same product
      if (productImage.isPrimary && productImage.changed('isPrimary')) {
        await ProductImage.update(
          { isPrimary: false },
          { 
            where: { 
              productId: productImage.productId,
              id: { [sequelize.Sequelize.Op.ne]: productImage.id }
            } 
          }
        );
      }
    }
  }
});

// Instance methods
ProductImage.prototype.getFullImageUrl = function(baseUrl = '') {
  return `${baseUrl}/uploads/products/${this.imagePath}`;
};

// Static methods
ProductImage.findByProduct = function(productId) {
  return this.findAll({
    where: { productId },
    order: [['isPrimary', 'DESC'], ['sortOrder', 'ASC'], ['createdAt', 'ASC']]
  });
};

ProductImage.findPrimaryImage = function(productId) {
  return this.findOne({
    where: { 
      productId,
      isPrimary: true 
    }
  });
};

ProductImage.setPrimaryImage = async function(imageId, productId) {
  // First, unset all primary images for this product
  await this.update(
    { isPrimary: false },
    { where: { productId } }
  );
  
  // Then set the specified image as primary
  return this.update(
    { isPrimary: true },
    { where: { id: imageId, productId } }
  );
};

module.exports = ProductImage;


================================================
FILE: src/models/User.js
================================================
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const User = sequelize.define('User', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  username: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
    validate: {
      len: [3, 50],
      is: /^[a-zA-Z0-9_]+$/
    }
  },
  email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
      len: [5, 100]
    }
  },
  phoneNumber: {
    type: DataTypes.STRING(20),
    allowNull: true,
    field: 'phone_number',
    validate: {
      is: /^[\+]?[1-9][\d]{0,15}$/
    }
  },
  passwordHash: {
    type: DataTypes.STRING(255),
    allowNull: true,
    field: 'password_hash'
  },
  role: {
    type: DataTypes.ENUM('admin', 'user'),
    defaultValue: 'user'
  },
  googleId: {
    type: DataTypes.STRING(255),
    allowNull: true,
    unique: true,
    field: 'google_id'
  },
  profilePicture: {
    type: DataTypes.STRING(500),
    allowNull: true,
    field: 'profile_picture'
  },
  isVerified: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'is_verified'
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
    field: 'is_active'
  },
  loginAttempts: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    field: 'login_attempts'
  },
  lockedUntil: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'locked_until'
  },
  lastLogin: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'last_login'
  },
  passwordChangedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'password_changed_at'
  },
  emailVerifiedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'email_verified_at'
  },
  twoFactorSecret: {
    type: DataTypes.STRING(32),
    allowNull: true,
    field: 'two_factor_secret'
  },
  twoFactorEnabled: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'two_factor_enabled'
  },
  currentPoints: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'current_points',
    validate: {
      min: 0,
      isInt: true
    }
  },
  emailVerificationToken: {
    type: DataTypes.STRING(255),
    allowNull: true,
    field: 'email_verification_token'
  },
  emailVerificationExpires: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'email_verification_expires'
  },
  emailVerificationSentAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'email_verification_sent_at'
  },
  refreshTokenHash: {
    type: DataTypes.STRING(255),
    allowNull: true,
    field: 'refresh_token_hash'
  },
  // Token version field for invalidating tokens
  tokenVersion: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'token_version',
    comment: 'Incremented on logout/password change to invalidate old tokens'
  }
}, {
  tableName: 'users',
  timestamps: true,
  // FIXED: Use the actual database column names
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  paranoid: true,
  deletedAt: 'deleted_at',
  // Ensure proper field mapping for ordering
  defaultScope: {},
  scopes: {},
  hooks: {
    beforeCreate: async (user) => {
      if (user.passwordHash) {
        user.passwordHash = await bcrypt.hash(user.passwordHash, 12);
      }
    },
    beforeUpdate: async (user) => {
      if (user.changed('passwordHash') && user.passwordHash) {
        user.passwordHash = await bcrypt.hash(user.passwordHash, 12);
        user.passwordChangedAt = new Date(); // Ensure it's a Date object
      }
    },
    afterFind: (result) => {
      // Ensure date fields are proper Date objects
      if (result) {
        const users = Array.isArray(result) ? result : [result];
        users.forEach(user => {
          if (user && user.dataValues) {
            // Handle various date field formats
            const dateFields = ['passwordChangedAt', 'emailVerifiedAt', 'lastLogin', 'lockedUntil', 'createdAt', 'updatedAt'];
            dateFields.forEach(field => {
              if (user.dataValues[field] && typeof user.dataValues[field] === 'string') {
                user.dataValues[field] = new Date(user.dataValues[field]);
              }
            });
          }
        });
      }
    }
  }
});

// Instance methods
User.prototype.comparePassword = async function(password) {
  if (!this.passwordHash) return false;
  return bcrypt.compare(password, this.passwordHash);
};

// ADD: Missing method that authService.js expects
User.prototype.validatePassword = async function(password) {
  return this.comparePassword(password);
};

User.prototype.isLocked = function() {
  return this.lockedUntil && this.lockedUntil > new Date();
};

User.prototype.incrementLoginAttempts = async function() {
  const maxAttempts = parseInt(process.env.MAX_LOGIN_ATTEMPTS) || 5;
  const lockTime = parseInt(process.env.ACCOUNT_LOCK_TIME) || 2 * 60 * 60 * 1000; // 2 hours

  this.loginAttempts += 1;

  if (this.loginAttempts >= maxAttempts && !this.isLocked()) {
    this.lockedUntil = new Date(Date.now() + lockTime);
  }

  return this.save();
};

User.prototype.resetLoginAttempts = async function() {
  this.loginAttempts = 0;
  this.lockedUntil = null;
  this.lastLogin = new Date();
  return this.save();
};

// Method to invalidate all tokens by incrementing version
User.prototype.invalidateAllTokens = async function(reason = 'logout') {
  this.tokenVersion = (this.tokenVersion || 0) + 1;
  this.refreshTokenHash = null; // Also clear refresh token
  
  console.log(`🔄 Invalidating all tokens for user ${this.id}. New token version: ${this.tokenVersion}. Reason: ${reason}`);
  
  return this.save();
};

User.prototype.toSafeJSON = function() {
  const values = Object.assign({}, this.get());
  delete values.passwordHash;
  delete values.refreshTokenHash;
  delete values.twoFactorSecret;
  delete values.emailVerificationToken;
  delete values.tokenVersion; // Don't expose token version to client
  return values;
};

User.prototype.canEarnPoints = function() {
  return this.isActive && this.isVerified;
};

User.prototype.addPoints = async function(amount, transaction = null) {
  const options = transaction ? { transaction } : {};
  this.currentPoints += amount;
  return this.save(options);
};

User.prototype.deductPoints = async function(amount, transaction = null) {
  if (this.currentPoints < amount) {
    throw new Error('Insufficient points balance');
  }
  
  const options = transaction ? { transaction } : {};
  this.currentPoints -= amount;
  return this.save(options);
};

// Email verification methods
User.prototype.generateEmailVerificationToken = function() {
  const token = crypto.randomBytes(32).toString('hex');
  const expires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

  this.emailVerificationToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  this.emailVerificationExpires = expires;
  this.emailVerificationSentAt = new Date();

  return token;
};

User.prototype.validateEmailVerificationToken = function(token) {
  if (!token || !this.emailVerificationToken || !this.emailVerificationExpires) {
    return false;
  }

  if (new Date() > this.emailVerificationExpires) {
    return false;
  }

  const hashedToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');

  return hashedToken === this.emailVerificationToken;
};

User.prototype.isEmailVerificationExpired = function() {
  return this.emailVerificationExpires && new Date() > this.emailVerificationExpires;
};

User.prototype.markEmailAsVerified = async function() {
  this.isVerified = true;
  this.emailVerifiedAt = new Date();
  this.emailVerificationToken = null;
  this.emailVerificationExpires = null;
  return this.save();
};

User.prototype.canResendVerificationEmail = function() {
  if (!this.emailVerificationSentAt) {
    return true;
  }

  const waitTime = 2 * 60 * 1000; // 2 minutes
  return new Date() - this.emailVerificationSentAt > waitTime;
};

// Refresh token methods
User.prototype.setRefreshToken = async function(refreshToken) {
  this.refreshTokenHash = await bcrypt.hash(refreshToken, 10);
  return this.save();
};

User.prototype.validateRefreshToken = async function(refreshToken) {
  if (!this.refreshTokenHash || !refreshToken) {
    return false;
  }
  return bcrypt.compare(refreshToken, this.refreshTokenHash);
};

// Static methods
User.findByEmail = function(email) {
  return this.findOne({ where: { email } });
};

User.findByUsername = function(username) {
  return this.findOne({ where: { username } });
};

// Method that authService.js expects
User.findByEmailOrUsername = function(identifier) {
  const lowerIdentifier = identifier.toLowerCase().trim();
  
  return this.findOne({
    where: {
      [sequelize.Sequelize.Op.or]: [
        { email: lowerIdentifier },
        { username: lowerIdentifier }
      ]
    }
  });
};

User.findByGoogleId = function(googleId) {
  return this.findOne({ where: { googleId } });
};

User.findByEmailVerificationToken = function(token) {
  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
  
  return this.findOne({ 
    where: { 
      emailVerificationToken: hashedToken,
      emailVerificationExpires: {
        [sequelize.Sequelize.Op.gt]: new Date()
      }
    }
  });
};

User.getUsersWithPoints = function(options = {}) {
  const {
    page = 1,
    limit = 20,
    minPoints = 0,
    orderBy = 'current_points',
    orderDirection = 'DESC'
  } = options;

  return this.findAndCountAll({
    where: {
      currentPoints: {
        [sequelize.Sequelize.Op.gte]: minPoints
      },
      isActive: true
    },
    attributes: ['id', 'username', 'email', 'currentPoints', 'created_at'],
    order: [[orderBy, orderDirection]],
    limit: parseInt(limit),
    offset: (parseInt(page) - 1) * parseInt(limit)
  });
};

User.getTopPointUsers = function(limit = 10) {
  return this.findAll({
    where: {
      currentPoints: {
        [sequelize.Sequelize.Op.gt]: 0
      },
      isActive: true
    },
    attributes: ['id', 'username', 'email', 'currentPoints'],
    order: [['current_points', 'DESC']],
    limit: parseInt(limit)
  });
};

User.getTotalPointsInSystem = async function() {
  const result = await this.sum('currentPoints', {
    where: {
      isActive: true
    }
  });
  
  return result || 0;
};

module.exports = User;


================================================
FILE: src/routes/auth.js
================================================
const express = require('express');
const { body } = require('express-validator');
const passport = require('passport');
const authController = require('../controllers/authController');
const { 
  authenticateToken, 
  verifyRefreshToken,
  optionalAuth
} = require('../middleware/auth');

// Simple fallback validation
const handleValidationErrors = (req, res, next) => next();
const basicValidation = [handleValidationErrors];

// Import validation functions with fallbacks
let validateSignup = basicValidation;
let validateLogin = basicValidation;
let validatePasswordChange = basicValidation;
let validateProfileUpdate = basicValidation;
let validateRefreshToken = basicValidation;
let validateProfileAccess = basicValidation;

try {
  const validationModule = require('../middleware/validation');
  if (validationModule.validateSignup) validateSignup = validationModule.validateSignup;
  if (validationModule.validateLogin) validateLogin = validationModule.validateLogin;
  if (validationModule.validatePasswordChange) validatePasswordChange = validationModule.validatePasswordChange;
  if (validationModule.validateProfileUpdate) validateProfileUpdate = validationModule.validateProfileUpdate;
  if (validationModule.validateRefreshToken) validateRefreshToken = validationModule.validateRefreshToken;
  if (validationModule.validateProfileAccess) validateProfileAccess = validationModule.validateProfileAccess;
  if (validationModule.handleValidationErrors) handleValidationErrors = validationModule.handleValidationErrors;
} catch (error) {
  console.warn('⚠️ Validation middleware not found, using basic validation');
}

// Simple fallback limiters
const noOpLimiter = (req, res, next) => next();
let authLimiter = noOpLimiter;
let loginLimiter = noOpLimiter;
let authSpeedLimiter = noOpLimiter;

try {
  const securityConfig = require('../config/security');
  if (securityConfig.authLimiter) authLimiter = securityConfig.authLimiter;
  if (securityConfig.loginLimiter) loginLimiter = securityConfig.loginLimiter;
  if (securityConfig.authSpeedLimiter) authSpeedLimiter = securityConfig.authSpeedLimiter;
} catch (error) {
  console.warn('⚠️ Security config not found, using no-op limiters');
}

const router = express.Router();

// Apply rate limiting to all auth routes
router.use(authLimiter);
router.use(authSpeedLimiter);

// Simple fallback handler function
const notImplementedHandler = (methodName) => {
  return (req, res) => {
    res.status(501).json({
      success: false,
      message: `${methodName} method not implemented in authController`,
      code: 'METHOD_NOT_IMPLEMENTED',
      hint: `Please implement ${methodName} method in authController`
    });
  };
};

/**
 * @route   POST /api/auth/register
 * @desc    Register new user
 * @access  Public
 */
router.post('/register', validateSignup, authController.register);

/**
 * @route   POST /api/auth/login
 * @desc    Login user
 * @access  Public
 */
router.post('/login', loginLimiter, validateLogin, authController.login);

/**
 * @route   POST /api/auth/refresh-token
 * @desc    Refresh access token
 * @access  Public
 */
router.post('/refresh-token', validateRefreshToken, authController.refreshToken);

/**
 * @route   POST /api/auth/logout
 * @desc    Logout user
 * @access  Private
 */
router.post('/logout', authenticateToken, authController.logout);

/**
 * @route   POST /api/auth/change-password
 * @desc    Change user password
 * @access  Private
 */
router.post('/change-password', 
  authenticateToken, 
  validatePasswordChange, 
  authController.changePassword
);

/**
 * @route   GET /api/auth/profile
 * @desc    Get current user profile
 * @access  Private
 */
router.get('/profile', authenticateToken, authController.getProfile);

/**
 * @route   PUT /api/auth/profile
 * @desc    Update user profile
 * @access  Private
 */
router.put('/profile', 
  authenticateToken, 
  validateProfileUpdate, 
  authController.updateProfile
);

/**
 * @route   GET /api/auth/profile/:id
 * @desc    Get user profile by ID (Own profile or Admin access)
 * @access  Private (Own profile or Admin)
 */
router.get('/profile/:id', 
  authenticateToken,
  validateProfileAccess,
  authController.getUserProfileById || notImplementedHandler('getUserProfileById')
);

/**
 * @route   GET /api/auth/public-profile/:id
 * @desc    Get limited public user profile by ID
 * @access  Public (Limited information only)
 */
router.get('/public-profile/:id', 
  validateProfileAccess,
  authController.getPublicProfile || notImplementedHandler('getPublicProfile')
);

/**
 * @route   GET /api/auth/verify-email
 * @desc    Verify user email address
 * @access  Public
 */
router.get('/verify-email', authController.verifyEmail);

/**
 * @route   POST /api/auth/resend-verification
 * @desc    Resend email verification
 * @access  Public
 */
router.post('/resend-verification', 
  body('email').isEmail().withMessage('Valid email is required'),
  handleValidationErrors,
  authController.resendEmailVerification
);

/**
 * @route   POST /api/auth/verify-email
 * @desc    Verify user email (legacy endpoint for authenticated users)
 * @access  Private
 */
router.post('/verify-email', authenticateToken, authController.verifyEmail);

// Google OAuth routes
/**
 * @route   GET /api/auth/google
 * @desc    Initiate Google OAuth
 * @access  Public
 */
router.get('/google',
  passport.authenticate('google', { 
    scope: ['profile', 'email'],
    prompt: 'select_account'
  })
);

/**
 * @route   GET /api/auth/google/callback
 * @desc    Google OAuth callback
 * @access  Public
 */
router.get('/google/callback',
  passport.authenticate('google', { 
    failureRedirect: `${process.env.FRONTEND_URL}/login?error=oauth_failed`,
    session: false
  }),
  authController.googleCallback
);

// Development/Debug endpoints (only in development)
if (process.env.NODE_ENV !== 'production') {
  /**
   * @route   GET /api/v1/auth/debug-email
   * @desc    Debug email service status (Development only)
   * @access  Public
   */
  router.get('/debug-email', (req, res) => {
    try {
      const emailService = require('../services/emailService');
      const status = emailService.getStatus();
      
      res.json({
        success: true,
        message: 'Email service debug information',
        ...status,
        environment: {
          NODE_ENV: process.env.NODE_ENV,
          BASE_URL: process.env.BASE_URL,
          FRONTEND_URL: process.env.FRONTEND_URL
        },
        actions: {
          reinitialize: 'POST /api/v1/auth/reinit-email',
          testConnection: 'POST /api/v1/auth/test-connection',
          testEmail: 'POST /api/v1/auth/test-email'
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Email service not available',
        error: error.message
      });
    }
  });

  /**
   * @route   POST /api/v1/auth/reinit-email
   * @desc    Reinitialize email service (Development only)
   * @access  Public
   */
  router.post('/reinit-email', (req, res) => {
    try {
      console.log('🔄 Manual email service reinitialization requested...');
      const emailService = require('../services/emailService');
      const status = emailService.reinitialize();
      
      res.json({
        success: true,
        message: 'Email service reinitialized',
        ...status,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Failed to reinitialize email service:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to reinitialize email service',
        error: error.message
      });
    }
  });

  /**
   * @route   POST /api/v1/auth/test-connection
   * @desc    Test Mailjet connection only (Development only)
   * @access  Public
   */
  router.post('/test-connection', async (req, res) => {
    try {
      console.log('🔍 Manual connection test requested...');
      const emailService = require('../services/emailService');
      const connectionTest = await emailService.testConnection();
      
      if (connectionTest.success) {
        res.json({
          success: true,
          message: '✅ Mailjet connection test successful',
          ...connectionTest,
          timestamp: new Date().toISOString()
        });
      } else {
        res.status(500).json({
          success: false,
          message: '❌ Mailjet connection test failed',
          ...connectionTest,
          timestamp: new Date().toISOString()
        });
      }
    } catch (error) {
      console.error('❌ Connection test error:', error);
      res.status(500).json({
        success: false,
        message: 'Connection test encountered an error',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  });

  /**
   * @route   POST /api/v1/auth/test-email
   * @desc    Test Mailjet email configuration (Development only)
   * @access  Public
   */
  router.post('/test-email', async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({
          success: false,
          message: 'Email is required for testing'
        });
      }

      // Validate email format
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({
          success: false,
          message: 'Invalid email format'
        });
      }

      const emailService = require('../services/emailService');
      
      // Get current email service status
      const status = emailService.getStatus();
      console.log('📧 Current email service status:', status);
      
      // Show current configuration
      const config = {
        provider: status.provider,
        hasTransporter: status.hasTransporter,
        lastError: status.lastError,
        mailjetApiKey: process.env.MAILJET_API_KEY ? 
          `${process.env.MAILJET_API_KEY.substring(0, 8)}...` : 
          'Not configured',
        mailjetSecretKey: process.env.MAILJET_SECRET_KEY ? 'Configured' : 'Not configured',
        fromEmail: process.env.FROM_EMAIL || 'Not configured',
        appName: process.env.APP_NAME || 'Secure Node.js Backend',
        baseUrl: process.env.BASE_URL || 'http://localhost:3000'
      };

      console.log('📧 Current configuration:', config);
      
      // If service is in error state, suggest reinitialization
      if (status.provider === 'error' || !status.hasTransporter) {
        return res.status(500).json({
          success: false,
          message: `Email service is not properly initialized (provider: ${status.provider})`,
          config,
          error: {
            message: status.lastError || 'Email transporter not available',
            provider: status.provider
          },
          troubleshooting: {
            immediate_steps: [
              '1. Check server console for detailed error messages',
              '2. Try reinitialization: POST /api/v1/auth/reinit-email',
              '3. Verify environment variables are correctly set',
              '4. Restart the server if needed'
            ],
            verification_steps: [
              '1. Verify MAILJET_API_KEY is correct in .env',
              '2. Verify MAILJET_SECRET_KEY is correct in .env', 
              '3. Check FROM_EMAIL uses a verified domain in Mailjet',
              '4. Ensure your Mailjet account is active',
              '5. Check server internet connection'
            ]
          }
        });
      }

      // Test Mailjet connection first
      console.log('🔍 Testing Mailjet connection...');
      const connectionTest = await emailService.testConnection();
      
      if (!connectionTest.success) {
        return res.status(500).json({
          success: false,
          message: `Mailjet connection failed: ${connectionTest.error}`,
          config,
          error: {
            message: connectionTest.error || 'Unknown error',
            code: connectionTest.code,
            provider: connectionTest.provider,
            suggestion: connectionTest.suggestion || 'Check your Mailjet credentials'
          },
          troubleshooting: {
            steps: [
              '1. Verify MAILJET_API_KEY is correct in .env',
              '2. Verify MAILJET_SECRET_KEY is correct in .env', 
              '3. Check FROM_EMAIL uses a verified domain in Mailjet',
              '4. Ensure your Mailjet account is active',
              '5. Check server internet connection',
              '6. Try reinitializing: POST /api/v1/auth/reinit-email'
            ]
          }
        });
      }

      // Create test user object
      const testUser = {
        id: 999,
        username: 'testuser',
        email: email
      };

      // Generate test verification token
      const testToken = 'test-verification-token-' + Date.now();

      console.log(`📧 Sending test verification email to: ${email}`);
      console.log(`📧 Using provider: ${status.provider}`);
      console.log(`📧 From email: ${process.env.FROM_EMAIL}`);
      
      // Send test email using the same method as registration
      const emailSent = await emailService.sendEmailVerification(testUser, testToken);
      
      if (emailSent) {
        res.json({
          success: true,
          message: '✅ Test email sent successfully via Mailjet!',
          details: {
            recipient: email,
            sender: process.env.FROM_EMAIL,
            provider: status.provider,
            timestamp: new Date().toISOString(),
            testVerificationUrl: `${process.env.BASE_URL || 'http://localhost:3000'}/api/v1/auth/verify-email?token=${testToken}&email=${encodeURIComponent(email)}`
          },
          config: {
            provider: status.provider,
            fromEmail: process.env.FROM_EMAIL,
            appName: process.env.APP_NAME
          },
          instructions: [
            '1. Check your inbox and spam folder',
            '2. The test email contains a verification link',
            '3. Email should arrive within 1-2 minutes',
            '4. If not received, check Mailjet dashboard for delivery status'
          ]
        });
      } else {
        res.status(500).json({
          success: false,
          message: '❌ Failed to send test email via Mailjet',
          details: {
            recipient: email,
            provider: status.provider,
            timestamp: new Date().toISOString()
          },
          config,
          troubleshooting: {
            checkLogs: 'Review server console for detailed error messages',
            verifyConfig: 'Ensure all Mailjet configuration is correct',
            mailjetDashboard: 'Check Mailjet dashboard for account status',
            reinitialize: 'Try POST /api/v1/auth/reinit-email',
            contactSupport: 'Contact Mailjet support if issues persist'
          }
        });
      }
      
    } catch (error) {
      console.error('❌ Test email endpoint error:', error);
      
      res.status(500).json({
        success: false,
        message: 'Test email endpoint encountered an error',
        error: {
          message: error.message,
          code: error.code || 'UNKNOWN_ERROR',
          stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
        },
        timestamp: new Date().toISOString(),
        suggestions: [
          'Check server logs for detailed error information',
          'Verify .env file contains correct Mailjet credentials',
          'Ensure Mailjet account is active and not suspended',
          'Try reinitializing email service: POST /api/v1/auth/reinit-email'
        ]
      });
    }
  });
}

module.exports = router;


================================================
FILE: src/routes/category.js
================================================
const express = require('express');
const categoryController = require('../controllers/categoryController');
const { authenticateToken, authorizeRoles, optionalAuth } = require('../middleware/auth');
const {
  validateCategoryCreate,
  validateCategoryUpdate,
  validatePagination,
  validateIdParam
} = require('../middleware/validation');
const { uploadSingleCategory, handleUploadError } = require('../middleware/upload');
const { generalLimiter } = require('../config/security');

const router = express.Router();

// Apply rate limiting
router.use(generalLimiter);

/**
 * @route   GET /api/v1/categories
 * @desc    Get all categories (Admin) or active categories (Public)
 * @access  Public/Admin
 */
router.get('/', optionalAuth, validatePagination, (req, res, next) => {
  // If user is admin, show all categories, otherwise show active categories only
  if (req.user && req.user.role === 'admin') {
    return categoryController.getAllCategories(req, res, next);
  } else {
    return categoryController.getActiveCategories(req, res, next);
  }
});

/**
 * @route   GET /api/v1/categories/active
 * @desc    Get active categories
 * @access  Public
 */
router.get('/active', categoryController.getActiveCategories);

/**
 * @route   GET /api/v1/categories/:id
 * @desc    Get category by ID
 * @access  Public
 */
router.get('/:id', validateIdParam, categoryController.getCategoryById);

/**
 * @route   GET /api/v1/categories/slug/:slug
 * @desc    Get category by slug
 * @access  Public
 */
router.get('/slug/:slug', categoryController.getCategoryBySlug);

/**
 * @route   POST /api/v1/categories
 * @desc    Create new category
 * @access  Admin
 */
router.post('/',
  authenticateToken,
  authorizeRoles('admin'),
  validateCategoryCreate,
  categoryController.createCategory
);

/**
 * @route   PUT /api/v1/categories/:id
 * @desc    Update category
 * @access  Admin
 */
router.put('/:id',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  validateCategoryUpdate,
  categoryController.updateCategory
);

/**
 * @route   DELETE /api/v1/categories/:id
 * @desc    Soft delete category
 * @access  Admin
 */
router.delete('/:id',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  categoryController.deleteCategory
);

/**
 * @route   DELETE /api/v1/categories/:id/force
 * @desc    Force delete category (permanent)
 * @access  Admin
 */
router.delete('/:id/force',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  categoryController.forceDeleteCategory
);

/**
 * @route   POST /api/v1/categories/:id/restore
 * @desc    Restore soft deleted category
 * @access  Admin
 */
router.post('/:id/restore',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  categoryController.restoreCategory
);

/**
 * @route   POST /api/v1/categories/:id/image
 * @desc    Upload category image
 * @access  Admin
 */
router.post('/:id/image',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  uploadSingleCategory,
  handleUploadError,
  categoryController.uploadCategoryImage
);

/**
 * @route   PATCH /api/v1/categories/:id/toggle-status
 * @desc    Toggle category active status
 * @access  Admin
 */
router.patch('/:id/toggle-status',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  categoryController.toggleCategoryStatus
);

module.exports = router;


================================================
FILE: src/routes/index.js
================================================
[Empty file]


================================================
FILE: src/routes/leaderboard.js
================================================
const express = require('express');
const leaderboardController = require('../controllers/leaderboardController');
const { authenticateToken, authorizeRoles, optionalAuth } = require('../middleware/auth');
const {
  validateDateQuery,
  validateMonthYearQuery
} = require('../middleware/leaderboardValidation');
const {
  validatePagination
} = require('../middleware/validation');
const { generalLimiter } = require('../config/security');

const router = express.Router();

// Apply rate limiting
router.use(generalLimiter);

/**
 * @route   GET /api/v1/leaderboard/daily
 * @desc    Get daily leaderboard (top 10)
 * @access  Public (with optional auth for enhanced features)
 */
router.get('/daily', 
  optionalAuth,
  validateDateQuery,
  leaderboardController.getDailyLeaderboard
);

/**
 * @route   GET /api/v1/leaderboard/monthly
 * @desc    Get monthly leaderboard (top 10)
 * @access  Public (with optional auth for enhanced features)
 */
router.get('/monthly',
  optionalAuth,
  validateMonthYearQuery,
  leaderboardController.getMonthlyLeaderboard
);

/**
 * @route   GET /api/v1/leaderboard/all-time
 * @desc    Get all-time leaderboard (top 10)
 * @access  Public (with optional auth for enhanced features)
 */
router.get('/all-time',
  optionalAuth,
  leaderboardController.getAllTimeLeaderboard
);

// User-specific ranking endpoints (require authentication)
/**
 * @route   GET /api/v1/leaderboard/my-rank/daily
 * @desc    Get user's daily ranking
 * @access  Private
 */
router.get('/my-rank/daily',
  authenticateToken,
  validateDateQuery,
  leaderboardController.getMyDailyRank
);

/**
 * @route   GET /api/v1/leaderboard/my-rank/monthly
 * @desc    Get user's monthly ranking
 * @access  Private
 */
router.get('/my-rank/monthly',
  authenticateToken,
  validateMonthYearQuery,
  leaderboardController.getMyMonthlyRank
);

/**
 * @route   GET /api/v1/leaderboard/my-rank/all-time
 * @desc    Get user's all-time ranking
 * @access  Private
 */
router.get('/my-rank/all-time',
  authenticateToken,
  leaderboardController.getMyAllTimeRank
);

/**
 * @route   GET /api/v1/leaderboard/comprehensive
 * @desc    Get comprehensive leaderboard data (all types + user rankings)
 * @access  Private
 */
router.get('/comprehensive',
  authenticateToken,
  validateDateQuery,
  validateMonthYearQuery,
  leaderboardController.getComprehensiveLeaderboard
);

// Admin-only endpoints
/**
 * @route   GET /api/v1/leaderboard/statistics
 * @desc    Get leaderboard statistics (Admin only)
 * @access  Admin
 */
router.get('/statistics',
  authenticateToken,
  authorizeRoles('admin'),
  leaderboardController.getLeaderboardStatistics
);


module.exports = router;


================================================
FILE: src/routes/point.js
================================================
const express = require('express');
const pointController = require('../controllers/pointController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const {
  validateRedemptionRequest,
  validateManualPointAward,
  validateRedemptionProcessing,
  validateTransactionFilter,
  validatePagination,
  validateRedemptionIdParam,
  validateUserIdParam
} = require('../middleware/validation');
const { generalLimiter } = require('../config/security');

const router = express.Router();

// Apply rate limiting
router.use(generalLimiter);

// All point management routes require authentication
router.use(authenticateToken);

/**
 * @route   GET /api/v1/points/my-points
 * @desc    Get user's current points balance and summary
 * @access  Private (User/Admin)
 */
router.get('/my-points', pointController.getMyPoints);

/**
 * @route   GET /api/v1/points/my-transactions
 * @desc    Get user's point transaction history
 * @access  Private (User/Admin)
 */
router.get('/my-transactions', 
  validatePagination,
  validateTransactionFilter,
  pointController.getMyTransactionHistory
);

/**
 * @route   POST /api/v1/points/redeem
 * @desc    Request point redemption
 * @access  Private (User/Admin)
 */
router.post('/redeem',
  validateRedemptionRequest,
  pointController.requestRedemption
);

/**
 * @route   GET /api/v1/points/my-redemptions
 * @desc    Get user's redemption history
 * @access  Private (User/Admin)
 */
router.get('/my-redemptions',
  validatePagination,
  pointController.getMyRedemptions
);

/**
 * @route   GET /api/v1/points/activities
 * @desc    Get available point activities
 * @access  Private (User/Admin)
 */
router.get('/activities', pointController.getAvailableActivities);

// Admin-only routes
/**
 * @route   GET /api/v1/points/admin/transactions
 * @desc    Get all users' point transactions
 * @access  Admin
 */
router.get('/admin/transactions',
  authorizeRoles('admin'),
  validatePagination,
  validateTransactionFilter,
  pointController.getAllTransactions
);

/**
 * @route   GET /api/v1/points/admin/redemptions
 * @desc    Get all redemption requests
 * @access  Admin
 */
router.get('/admin/redemptions',
  authorizeRoles('admin'),
  validatePagination,
  pointController.getAllRedemptions
);

/**
 * @route   PUT /api/v1/points/admin/redemptions/:redemptionId/process
 * @desc    Process redemption request (approve/reject)
 * @access  Admin
 */
router.put('/admin/redemptions/:redemptionId/process',
  authorizeRoles('admin'),
  validateRedemptionIdParam, // Use specific validator for redemptionId
  validateRedemptionProcessing,
  pointController.processRedemption
);

/**
 * @route   GET /api/v1/points/admin/statistics
 * @desc    Get system point statistics including consistency check
 * @access  Admin
 */
router.get('/admin/statistics',
  authorizeRoles('admin'),
  pointController.getSystemStatistics
);

/**
 * @route   POST /api/v1/points/admin/award
 * @desc    Award points manually to user
 * @access  Admin
 */
router.post('/admin/award',
  authorizeRoles('admin'),
  validateManualPointAward,
  pointController.awardPointsManually
);

/**
 * @route   GET /api/v1/points/admin/consistency/check
 * @desc    Check system consistency between users and transactions
 * @access  Admin
 */
router.get('/admin/consistency/check',
  authorizeRoles('admin'),
  pointController.checkSystemConsistency
);

/**
 * @route   POST /api/v1/points/admin/consistency/fix
 * @desc    Fix inconsistent point balances between users and transactions
 * @access  Admin
 */
router.post('/admin/consistency/fix',
  authorizeRoles('admin'),
  pointController.fixInconsistentBalances
);

/**
 * @route   GET /api/v1/points/admin/users/:userId/balance
 * @desc    Get detailed balance information for specific user
 * @access  Admin
 */
router.get('/admin/users/:userId/balance',
  authorizeRoles('admin'),
  validateUserIdParam, // Use specific validator for userId
  pointController.getUserBalanceDetails
);

module.exports = router;


================================================
FILE: src/routes/product.js
================================================
const express = require('express');
const productController = require('../controllers/productController');
const { authenticateToken, authorizeRoles, optionalAuth } = require('../middleware/auth');
const {
  validateProductCreate,
  validateProductUpdate,
  validateProductFilter,
  validatePagination,
  validateIdParam
} = require('../middleware/validation');
const { uploadSingleProduct, handleUploadError } = require('../middleware/upload');
const { generalLimiter } = require('../config/security');

const router = express.Router();

// Apply rate limiting
router.use(generalLimiter);

/**
 * @route   GET /api/v1/products
 * @desc    Get all products (Admin) or active products (Public)
 * @access  Public/Admin
 */
router.get('/', optionalAuth, validatePagination, validateProductFilter, (req, res, next) => {
  // If user is admin, show all products, otherwise show active products only
  if (req.user && req.user.role === 'admin') {
    return productController.getAllProducts(req, res, next);
  } else {
    return productController.getActiveProducts(req, res, next);
  }
});

/**
 * @route   GET /api/v1/products/featured
 * @desc    Get featured products
 * @access  Public
 */
router.get('/featured', productController.getFeaturedProducts);

/**
 * @route   GET /api/v1/products/search
 * @desc    Search products
 * @access  Public
 */
router.get('/search', validateProductFilter, productController.searchProducts);

/**
 * @route   GET /api/v1/products/statistics
 * @desc    Get product statistics
 * @access  Admin
 */
router.get('/statistics',
  authenticateToken,
  authorizeRoles('admin'),
  productController.getProductStatistics
);

/**
 * @route   GET /api/v1/products/category/:categoryId
 * @desc    Get products by category
 * @access  Public
 */
router.get('/category/:categoryId',
  validateIdParam,
  validatePagination,
  validateProductFilter,
  productController.getProductsByCategory
);

/**
 * @route   GET /api/v1/products/:id
 * @desc    Get product by ID
 * @access  Public
 */
router.get('/:id', validateIdParam, productController.getProductById);

/**
 * @route   GET /api/v1/products/slug/:slug
 * @desc    Get product by slug
 * @access  Public
 */
router.get('/slug/:slug', optionalAuth, productController.getProductBySlug);

/**
 * @route   POST /api/v1/products
 * @desc    Create new product with optional image upload
 * @access  Admin
 */
router.post('/',
  authenticateToken,
  authorizeRoles('admin'),
  uploadSingleProduct, // Handle file upload first
  handleUploadError,
  validateProductCreate,
  productController.createProduct
);


/**
 * @route   PUT /api/v1/products/:id
 * @desc    Update product with optional image upload
 * @access  Admin
 */
router.put('/:id',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  uploadSingleProduct,      // ← Tambahkan middleware upload
  handleUploadError,        // ← Tambahkan error handler
  validateProductUpdate,
  productController.updateProduct
);

/**
 * @route   DELETE /api/v1/products/:id
 * @desc    Delete product
 * @access  Admin
 */
router.delete('/:id',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  productController.deleteProduct
);

/**
 * @route   POST /api/v1/products/:id/image
 * @desc    Upload product image (separate endpoint for existing products)
 * @access  Admin
 */
router.post('/:id/image',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  uploadSingleProduct,
  handleUploadError,
  productController.uploadProductImage
);

/**
 * @route   PATCH /api/v1/products/:id/toggle-status
 * @desc    Toggle product active status
 * @access  Admin
 */
router.patch('/:id/toggle-status',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  productController.toggleProductStatus
);

/**
 * @route   PATCH /api/v1/products/:id/toggle-featured
 * @desc    Toggle product featured status
 * @access  Admin
 */
router.patch('/:id/toggle-featured',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  productController.toggleProductFeatured
);

/**
 * @route   PATCH /api/v1/products/:id/stock
 * @desc    Update product stock
 * @access  Admin
 */
router.patch('/:id/stock',
  authenticateToken,
  authorizeRoles('admin'),
  validateIdParam,
  productController.updateProductStock
);

module.exports = router;


================================================
FILE: src/routes/user.js
================================================
const express = require('express');
const { Op } = require('sequelize');
const { 
  successResponse, 
  errorResponse, 
  asyncHandler,
  HTTP_STATUS,
  SUCCESS_CODES,
  ERROR_CODES 
} = require('../utils/response');
const { logSecurityEvent } = require('../utils/logger');
const { 
  authenticateToken, 
  authorizeRoles 
} = require('../middleware/auth');
const { param, body, validationResult } = require('express-validator');

// Import rate limiters with fallback
let authLimiter, adminLimiter;
try {
  const security = require('../config/security');
  authLimiter = security.authLimiter || ((req, res, next) => next());
  adminLimiter = security.adminLimiter || ((req, res, next) => next());
} catch (error) {
  console.warn('⚠️ Security config not found, using no-op limiters');
  authLimiter = (req, res, next) => next();
  adminLimiter = (req, res, next) => next();
}

const router = express.Router();

// Handle validation errors
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(error => ({
      field: error.path,
      message: error.msg,
      value: error.value
    }));

    return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
      errorResponse(
        'Validation failed',
        ERROR_CODES.VALIDATION_ERROR,
        { errors: errorMessages }
      )
    );
  }
  next();
};

// Validate user ID parameter
const validateUserId = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),
  handleValidationErrors
];

// Validate password reset
const validatePasswordReset = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('User ID must be a positive integer'),
  body('newPassword')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters'),
  handleValidationErrors
];

// Apply rate limiting to all user management routes
router.use(authLimiter);

// Import User model with error handling
let User;
try {
  User = require('../models/User');
} catch (error) {
  console.error('⚠️ User model not found. Make sure models/User.js exists.');
}

// Direct controller methods to avoid import issues
const userControllerMethods = {
  // Get all users
  getAllUsers: asyncHandler(async (req, res) => {
    if (!User) {
      return res.status(500).json(errorResponse('User model not available', ERROR_CODES.INTERNAL_ERROR));
    }

    const { 
      page = 1, 
      limit = 20, 
      search = '', 
      role = '',
      status = '',
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);
    const whereClause = {};

    if (search) {
      whereClause[Op.or] = [
        { username: { [Op.like]: `%${search}%` } },
        { email: { [Op.like]: `%${search}%` } }
      ];
    }

    if (role && ['admin', 'user'].includes(role)) {
      whereClause.role = role;
    }

    if (status) {
      if (status === 'active') whereClause.isActive = true;
      else if (status === 'inactive') whereClause.isActive = false;
      else if (status === 'verified') whereClause.isVerified = true;
      else if (status === 'unverified') whereClause.isVerified = false;
    }

    try {
      const { count, rows: users } = await User.findAndCountAll({
        where: whereClause,
        attributes: { exclude: ['passwordHash', 'refreshTokenHash', 'twoFactorSecret', 'emailVerificationToken'] },
        order: [[sortBy, sortOrder.toUpperCase()]],
        limit: parseInt(limit),
        offset,
        paranoid: false
      });

      const totalPages = Math.ceil(count / parseInt(limit));

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Users retrieved successfully',
          {
            users: users.map(user => ({
              ...user.toJSON(),
              isLocked: user.isLocked ? user.isLocked() : false,
              canEarnPoints: user.canEarnPoints ? user.canEarnPoints() : false,
              accountAge: Math.floor((new Date() - user.createdAt) / (1000 * 60 * 60 * 24))
            })),
            pagination: {
              currentPage: parseInt(page),
              totalPages,
              totalUsers: count,
              hasNext: parseInt(page) < totalPages,
              hasPrev: parseInt(page) > 1
            }
          }
        )
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve users', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  }),

  // Get user statistics
  getUserStatistics: asyncHandler(async (req, res) => {
    try {
      const { sequelize } = require('../config/database');
      
      // Use raw queries to avoid field mapping issues
      const queries = [
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL',
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND is_active = true',
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND is_verified = true',
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND role = "admin"',
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND locked_until > NOW()',
        `SELECT COUNT(*) as count FROM users 
         WHERE deleted_at IS NULL 
         AND created_at >= DATE_FORMAT(NOW(), '%Y-%m-01')`,
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NOT NULL',
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL AND is_active = false'
      ];

      const results = await Promise.all(
        queries.map(query => 
          sequelize.query(query, { type: sequelize.QueryTypes.SELECT })
            .then(result => result[0].count)
        )
      );

      const statistics = {
        totalUsers: results[0],
        activeUsers: results[1],
        verifiedUsers: results[2],
        adminUsers: results[3],
        lockedUsers: results[4],
        newUsersThisMonth: results[5],
        deletedUsers: results[6],
        bannedUsers: results[7],
        inactiveUsers: results[0] - results[1],
        unverifiedUsers: results[0] - results[2],
        regularUsers: results[0] - results[3]
      };

      res.status(HTTP_STATUS.OK.code).json(
        successResponse('User statistics retrieved successfully', { statistics })
      );
    } catch (error) {
      console.error('getUserStatistics error:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve statistics', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  }),

  // Get banned users - FIXED WITH PURE RAW QUERY
  getBannedUsers: asyncHandler(async (req, res) => {
    const { 
      page = 1, 
      limit = 20, 
      search = '',
      sortBy = 'updated_at',
      sortOrder = 'DESC'
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);

    try {
      const { sequelize } = require('../config/database');
      
      // Build WHERE clause for search
      let searchClause = '';
      let replacements = { isActive: false, limit: parseInt(limit), offset: offset };
      
      if (search) {
        searchClause = 'AND (username LIKE :search OR email LIKE :search)';
        replacements.search = `%${search}%`;
      }

      // Validate sort parameters
      const validSortColumns = ['id', 'username', 'email', 'created_at', 'updated_at', 'is_active'];
      const safeSortBy = validSortColumns.includes(sortBy) ? sortBy : 'updated_at';
      const safeSortOrder = ['ASC', 'DESC'].includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'DESC';

      // Count query
      const countQuery = `
        SELECT COUNT(*) as total 
        FROM users 
        WHERE deleted_at IS NULL 
        AND is_active = :isActive
        ${searchClause}
      `;

      // Data query
      const dataQuery = `
        SELECT 
          id, 
          username, 
          email, 
          phone_number as phoneNumber,
          role,
          google_id as googleId,
          profile_picture as profilePicture,
          is_verified as isVerified,
          is_active as isActive,
          login_attempts as loginAttempts,
          locked_until as lockedUntil,
          last_login as lastLogin,
          password_changed_at as passwordChangedAt,
          email_verified_at as emailVerifiedAt,
          two_factor_enabled as twoFactorEnabled,
          current_points as currentPoints,
          created_at as createdAt,
          updated_at as updatedAt
        FROM users 
        WHERE deleted_at IS NULL 
        AND is_active = :isActive
        ${searchClause}
        ORDER BY ${safeSortBy} ${safeSortOrder}
        LIMIT :limit OFFSET :offset
      `;

      // Execute queries
      const [countResult] = await sequelize.query(countQuery, {
        replacements,
        type: sequelize.QueryTypes.SELECT
      });

      const users = await sequelize.query(dataQuery, {
        replacements,
        type: sequelize.QueryTypes.SELECT
      });

      const totalBannedUsers = countResult.total;
      const totalPages = Math.ceil(totalBannedUsers / parseInt(limit));

      logSecurityEvent('admin_banned_users_list_accessed', {
        adminId: req.user.id,
        filters: { search, sortBy: safeSortBy, sortOrder: safeSortOrder },
        resultCount: users.length
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'Banned users retrieved successfully',
          {
            bannedUsers: users.map(user => ({
              ...user,
              accountAge: Math.floor((new Date() - new Date(user.createdAt)) / (1000 * 60 * 60 * 24)),
              bannedDuration: Math.floor((new Date() - new Date(user.updatedAt)) / (1000 * 60 * 60 * 24)),
              createdAt: new Date(user.createdAt),
              updatedAt: new Date(user.updatedAt),
              lastLogin: user.lastLogin ? new Date(user.lastLogin) : null,
              lockedUntil: user.lockedUntil ? new Date(user.lockedUntil) : null,
              passwordChangedAt: user.passwordChangedAt ? new Date(user.passwordChangedAt) : null,
              emailVerifiedAt: user.emailVerifiedAt ? new Date(user.emailVerifiedAt) : null
            })),
            pagination: {
              currentPage: parseInt(page),
              totalPages,
              totalBannedUsers,
              hasNext: parseInt(page) < totalPages,
              hasPrev: parseInt(page) > 1
            },
            supportContact: 'support@sijago.ai'
          }
        )
      );
    } catch (error) {
      console.error('getBannedUsers error:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve banned users', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  }),

  // Get user ban status - FIXED WITH PURE RAW QUERY  
  getUserBanStatus: asyncHandler(async (req, res) => {
    const { id } = req.params;

    try {
      const { sequelize } = require('../config/database');
      
      // Pure raw query to avoid any Sequelize field mapping
      const query = `
        SELECT 
          id, 
          username, 
          email, 
          is_active as isActive, 
          created_at as createdAt,
          updated_at as updatedAt
        FROM users 
        WHERE deleted_at IS NULL 
        AND id = ?
      `;

      const [user] = await sequelize.query(query, {
        replacements: [id],
        type: sequelize.QueryTypes.SELECT
      });

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      const banStatus = {
        userId: user.id,
        username: user.username,
        email: user.email,
        isBanned: !user.isActive,
        isActive: user.isActive,
        accountCreated: new Date(user.createdAt),
        lastStatusChange: new Date(user.updatedAt),
        supportContact: 'support@sijago.ai'
      };

      if (!user.isActive) {
        banStatus.bannedDuration = Math.floor((new Date() - new Date(user.updatedAt)) / (1000 * 60 * 60 * 24));
        banStatus.message = 'Account is currently banned. For more information about your account status, please contact: support@sijago.ai';
      }

      res.status(HTTP_STATUS.OK.code).json(
        successResponse(
          'User ban status retrieved successfully',
          { banStatus }
        )
      );
    } catch (error) {
      console.error('getUserBanStatus error:', error);
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to retrieve ban status', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  }),

  // Ban user
  banUser: asyncHandler(async (req, res) => {
    if (!User) {
      return res.status(500).json(errorResponse('User model not available', ERROR_CODES.INTERNAL_ERROR));
    }

    const { id } = req.params;
    const { reason = 'Account banned by administrator', notifyUser = true } = req.body;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      if (parseInt(id) === req.user.id) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('You cannot ban your own account', ERROR_CODES.INVALID_OPERATION)
        );
      }

      if (!user.isActive) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('User is already banned', ERROR_CODES.INVALID_OPERATION)
        );
      }

      await user.update({ 
        isActive: false,
        lockedUntil: null,
        loginAttempts: 0
      });

      // Invalidate tokens if method exists
      if (user.invalidateAllTokens) {
        await user.invalidateAllTokens('account_banned');
      }

      // Send notification email if requested
      if (notifyUser) {
        try {
          const emailService = require('../services/emailService');
          await emailService.sendAccountBannedNotification(user, reason);
        } catch (emailError) {
          console.error('Failed to send ban notification email:', emailError);
        }
      }

      logSecurityEvent('admin_user_banned', {
        adminId: req.user.id,
        bannedUserId: user.id,
        bannedUserEmail: user.email,
        reason: reason,
        notificationSent: notifyUser
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse('User has been banned successfully', {
          user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON(),
          bannedAt: new Date(),
          reason: reason,
          notificationSent: notifyUser,
          supportContact: 'support@sijago.ai'
        })
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to ban user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  }),

  // Unban user
  unbanUser: asyncHandler(async (req, res) => {
    if (!User) {
      return res.status(500).json(errorResponse('User model not available', ERROR_CODES.INTERNAL_ERROR));
    }

    const { id } = req.params;
    const { reason = 'Account reactivated by administrator', notifyUser = true } = req.body;

    try {
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(HTTP_STATUS.NOT_FOUND.code).json(
          errorResponse('User not found', ERROR_CODES.RESOURCE_NOT_FOUND)
        );
      }

      if (user.isActive) {
        return res.status(HTTP_STATUS.BAD_REQUEST.code).json(
          errorResponse('User is not banned', ERROR_CODES.INVALID_OPERATION)
        );
      }

      await user.update({
        isActive: true,
        loginAttempts: 0,
        lockedUntil: null
      });

      // Send notification email if requested
      if (notifyUser) {
        try {
          const emailService = require('../services/emailService');
          await emailService.sendAccountReactivatedNotification(user, reason);
        } catch (emailError) {
          console.error('Failed to send reactivation notification email:', emailError);
        }
      }

      logSecurityEvent('admin_user_unbanned', {
        adminId: req.user.id,
        unbannedUserId: user.id,
        unbannedUserEmail: user.email,
        reason: reason,
        notificationSent: notifyUser
      });

      res.status(HTTP_STATUS.OK.code).json(
        successResponse('User has been unbanned successfully', {
          user: user.toSafeJSON ? user.toSafeJSON() : user.toJSON(),
          unbannedAt: new Date(),
          reason: reason,
          notificationSent: notifyUser
        })
      );
    } catch (error) {
      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR.code).json(
        errorResponse('Failed to unban user', ERROR_CODES.INTERNAL_ERROR)
      );
    }
  })
};

// Validation middleware for user creation
const validateCreateUser = [
  body('username')
    .isLength({ min: 3, max: 50 })
    .withMessage('Username must be between 3 and 50 characters')
    .matches(/^[a-zA-Z0-9_]+$/)
    .withMessage('Username can only contain letters, numbers, and underscores'),
  body('email')
    .isEmail()
    .withMessage('Please provide a valid email address'),
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters'),
  handleValidationErrors
];

/**
 * @route   GET /api/v1/users/banned
 * @desc    Get banned users list (Admin only)
 * @access  Private (Admin)
 */
router.get('/banned', 
  adminLimiter,
  authenticateToken, 
  authorizeRoles('admin'), 
  userControllerMethods.getBannedUsers
);

/**
 * @route   GET /api/v1/users/statistics
 * @desc    Get user statistics (Admin only)
 * @access  Private (Admin)
 */
router.get('/statistics', 
  adminLimiter,
  authenticateToken, 
  authorizeRoles('admin'), 
  userControllerMethods.getUserStatistics
);

/**
 * @route   GET /api/v1/users/:id/ban-status
 * @desc    Check ban status for a user (Admin only)
 * @access  Private (Admin)
 */
router.get('/:id/ban-status', 
  adminLimiter,
  authenticateToken, 
  authorizeRoles('admin'),
  validateUserId,
  userControllerMethods.getUserBanStatus
);

/**
 * @route   GET /api/v1/users
 * @desc    Get all users with pagination and filtering (Admin only)
 * @access  Private (Admin)
 */
router.get('/', 
  adminLimiter,
  authenticateToken, 
  authorizeRoles('admin'), 
  userControllerMethods.getAllUsers
);

/**
 * @route   PATCH /api/v1/users/:id/ban
 * @desc    Ban user (deactivate account) (Admin only)
 * @access  Private (Admin)
 */
router.patch('/:id/ban', 
  adminLimiter,
  authenticateToken, 
  authorizeRoles('admin'),
  validateUserId,
  userControllerMethods.banUser
);

/**
 * @route   PATCH /api/v1/users/:id/unban
 * @desc    Unban user (reactivate account) (Admin only)
 * @access  Private (Admin)
 */
router.patch('/:id/unban', 
  adminLimiter,
  authenticateToken, 
  authorizeRoles('admin'),
  validateUserId,
  userControllerMethods.unbanUser
);

module.exports = router;


================================================
FILE: src/services/authService.js
================================================
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const User = require('../models/User');
const emailService = require('./emailService');
const pointService = require('./pointService'); // Add point service
const { logAuthAttempt, logSecurityEvent } = require('../utils/logger');

class AuthService {
  /**
   * Generate JWT tokens with token version
   * @param {object} user - User object
   * @returns {object} Access and refresh tokens
   */
  generateTokens(user) {
    // Ensure tokenVersion is a number, default to 0 if null/undefined
    const currentTokenVersion = user.tokenVersion !== null && user.tokenVersion !== undefined ? user.tokenVersion : 0;
    
    console.log('🔐 Generating tokens for user:', {
      userId: user.id,
      currentTokenVersion: currentTokenVersion,
      userTokenVersion: user.tokenVersion,
      userTokenVersionType: typeof user.tokenVersion
    });

    const payload = {
      userId: user.id,
      email: user.email,
      role: user.role,
      tokenVersion: currentTokenVersion, // Explicitly include token version
      iat: Math.floor(Date.now() / 1000)
    };

    console.log('🔐 Token payload:', payload);

    const accessToken = jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_EXPIRE || '15m',
      algorithm: 'HS256'
    });

    const refreshToken = jwt.sign(
      { 
        userId: user.id,
        tokenVersion: currentTokenVersion // Also include in refresh token
      },
      process.env.JWT_REFRESH_SECRET,
      {
        expiresIn: process.env.JWT_REFRESH_EXPIRE || '7d',
        algorithm: 'HS256'
      }
    );

    // Debug: Verify the tokens contain tokenVersion
    try {
      const decodedAccess = jwt.decode(accessToken);
      const decodedRefresh = jwt.decode(refreshToken);
      
      console.log('🔍 Generated token verification:', {
        accessTokenVersion: decodedAccess.tokenVersion,
        refreshTokenVersion: decodedRefresh.tokenVersion,
        expectedVersion: currentTokenVersion,
        accessTokenVersionType: typeof decodedAccess.tokenVersion,
        refreshTokenVersionType: typeof decodedRefresh.tokenVersion
      });
      
      // Additional check - verify token can be decoded properly
      if (decodedAccess.tokenVersion === undefined) {
        console.error('❌ CRITICAL: Access token tokenVersion is undefined!');
        console.error('❌ User object:', JSON.stringify(user.toJSON(), null, 2));
        console.error('❌ Payload:', JSON.stringify(payload, null, 2));
      }
      
    } catch (error) {
      console.error('❌ Token decode error:', error);
    }

    return { accessToken, refreshToken };
  }

  /**
   * Register new user
   * @param {object} userData - User registration data
   * @returns {object} Created user and tokens
   */
  async register(userData) {
    const { username, email, phoneNumber, password } = userData;

    try {
      // Check if user already exists
      const existingUser = await User.findOne({
        where: {
          [User.sequelize.Sequelize.Op.or]: [
            { email: email.toLowerCase() },
            { username: username.toLowerCase() }
          ]
        }
      });

      if (existingUser) {
        const field = existingUser.email === email.toLowerCase() ? 'email' : 'username';
        throw new Error(`User with this ${field} already exists`);
      }

      // Create new user (unverified) with explicit tokenVersion
      const user = await User.create({
        username: username.toLowerCase(),
        email: email.toLowerCase(),
        phoneNumber,
        passwordHash: password, // Will be hashed by the model hook
        role: 'user',
        isVerified: false,
        isActive: true,
        tokenVersion: 0 // Explicitly set initial token version
      });

      // Reload user to ensure all fields are populated
      await user.reload();

      // Generate email verification token
      const verificationToken = user.generateEmailVerificationToken();
      await user.save();

      // Send verification email
      try {
        await emailService.sendEmailVerification(user, verificationToken);
      } catch (emailError) {
        logSecurityEvent('email_verification_send_failed', {
          userId: user.id,
          email: user.email,
          error: emailError.message
        });
      }

      logAuthAttempt('register', true, {
        userId: user.id,
        username: user.username,
        email: user.email,
        requiresVerification: true,
        tokenVersion: user.tokenVersion
      });

      return {
        user: user.toSafeJSON(),
        message: 'Registration successful. Please check your email to verify your account before logging in.'
      };
    } catch (error) {
      logAuthAttempt('register', false, {
        username,
        email,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Login user with daily login bonus
   * @param {string} identifier - Username or email
   * @param {string} password - User password
   * @param {string} ipAddress - Client IP address
   * @returns {object} User and tokens
   */
  async login(identifier, password, ipAddress) {
    try {
      console.log('🔍 Login attempt:', { identifier, ipAddress });
      
      // Find user by email or username
      let user = await User.findByEmailOrUsername(identifier);
      console.log('👤 User found:', user ? `ID: ${user.id}, Email: ${user.email}, Username: ${user.username}, TokenVersion: ${user.tokenVersion}` : 'No user found');

      if (!user) {
        logSecurityEvent('login_attempt_invalid_user', {
          identifier,
          ipAddress
        });
        throw new Error('Invalid credentials');
      }

      // Ensure tokenVersion is not null - fix if needed
      if (user.tokenVersion === null || user.tokenVersion === undefined) {
        console.log('🔧 Fixing null tokenVersion for user:', user.id);
        await user.update({ tokenVersion: 0 });
        // Reload user to get fresh data
        await user.reload();
        console.log('🔧 Fixed tokenVersion:', user.tokenVersion);
      }

      // Check if account is locked
      if (user.isLocked()) {
        console.log('🔒 Account is locked until:', user.lockedUntil);
        logSecurityEvent('login_attempt_locked_account', {
          userId: user.id,
          ipAddress,
          lockedUntil: user.lockedUntil
        });
        throw new Error('Account is temporarily locked due to too many failed login attempts');
      }

      // Check if account is active
      if (!user.isActive) {
        console.log('❌ Account is not active');
        logSecurityEvent('login_attempt_inactive_account', {
          userId: user.id,
          ipAddress
        });
        throw new Error('Account has been deactivated');
      }

      // Check if email is verified
      if (!user.isVerified) {
        console.log('📧 Email is not verified');
        logSecurityEvent('login_attempt_unverified_email', {
          userId: user.id,
          ipAddress
        });
        throw new Error('Please verify your email address before logging in. Check your inbox for verification instructions.');
      }

      // Validate password
      console.log('🔐 Validating password...');
      const isPasswordValid = await user.validatePassword(password);
      console.log('🔐 Password validation result:', isPasswordValid);

      if (!isPasswordValid) {
        // Increment login attempts
        await user.incrementLoginAttempts();
        
        logSecurityEvent('login_attempt_invalid_password', {
          userId: user.id,
          ipAddress,
          loginAttempts: user.loginAttempts + 1
        });
        
        throw new Error('Invalid credentials');
      }

      // Reset login attempts on successful login
      await user.resetLoginAttempts();

      // IMPORTANT: Reload user again to ensure we have the latest tokenVersion
      await user.reload();
      console.log('🔄 User reloaded before token generation. TokenVersion:', user.tokenVersion);

      // Generate tokens with current token version
      const tokens = this.generateTokens(user);

      // Save refresh token hash
      await user.setRefreshToken(tokens.refreshToken);

      // NEW: Award daily login points (if eligible)
      let dailyLoginResult = null;
      try {
        console.log('🎯 Checking daily login bonus eligibility...');
        const hasLoggedInToday = await pointService.hasCompletedActivityToday(user.id, 'DAILY_LOGIN');
        
        if (!hasLoggedInToday) {
          console.log('🎁 User eligible for daily login bonus');
          dailyLoginResult = await pointService.awardDailyLoginPoints(user.id);
          console.log('🎁 Daily login result:', dailyLoginResult);
        } else {
          console.log('⏰ User already received daily login bonus today');
        }
      } catch (pointError) {
        console.error('❌ Error awarding daily login points:', pointError);
        // Don't throw error - login should still succeed even if points fail
        logSecurityEvent('daily_login_points_error', {
          userId: user.id,
          error: pointError.message
        });
      }

      logAuthAttempt('login', true, {
        userId: user.id,
        ipAddress,
        tokenVersion: user.tokenVersion,
        dailyLoginBonus: dailyLoginResult?.awarded || false
      });

      console.log('✅ Login successful for user:', user.id, 'with token version:', user.tokenVersion);

      const response = {
        user: user.toSafeJSON(),
        tokens
      };

      // Add daily login bonus info to response if awarded
      if (dailyLoginResult?.awarded) {
        response.dailyLoginBonus = {
          awarded: true,
          points: dailyLoginResult.points,
          message: dailyLoginResult.message
        };
      }

      return response;
    } catch (error) {
      console.log('❌ Login failed:', error.message);
      logAuthAttempt('login', false, {
        identifier,
        ipAddress,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Refresh access token with version validation
   * @param {string} refreshToken - Refresh token
   * @returns {object} New tokens
   */
  async refreshToken(refreshToken) {
    try {
      // Verify refresh token
      const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);

      // Find user
      const user = await User.findByPk(decoded.userId);

      if (!user || !user.isActive) {
        throw new Error('Invalid refresh token');
      }

      // Ensure tokenVersion is not null
      if (user.tokenVersion === null || user.tokenVersion === undefined) {
        await user.update({ tokenVersion: 0 });
        await user.reload();
      }

      // Check token version - if different, refresh token is invalid
      const userTokenVersion = user.tokenVersion || 0;
      const decodedTokenVersion = decoded.tokenVersion || 0;
      
      if (decodedTokenVersion !== userTokenVersion) {
        logSecurityEvent('invalid_refresh_token_version', {
          userId: user.id,
          decodedVersion: decodedTokenVersion,
          currentVersion: userTokenVersion
        });
        throw new Error('Invalid refresh token - please log in again');
      }

      // Validate refresh token
      if (!user.validateRefreshToken(refreshToken)) {
        logSecurityEvent('invalid_refresh_token_used', {
          userId: user.id
        });
        throw new Error('Invalid refresh token');
      }

      // Generate new tokens with current token version
      const tokens = this.generateTokens(user);

      // Save new refresh token hash
      await user.setRefreshToken(tokens.refreshToken);

      logAuthAttempt('token_refresh', true, {
        userId: user.id,
        tokenVersion: user.tokenVersion
      });

      return {
        user: user.toSafeJSON(),
        tokens
      };
    } catch (error) {
      logAuthAttempt('token_refresh', false, {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Logout user by invalidating all tokens
   * @param {object} user - User object
   * @returns {boolean} Success status
   */
  async logout(user) {
    try {
      // Invalidate all tokens by incrementing token version
      await user.invalidateAllTokens('logout');

      logAuthAttempt('logout', true, {
        userId: user.id,
        newTokenVersion: user.tokenVersion
      });

      console.log('✅ Logout successful for user:', user.id, 'New token version:', user.tokenVersion);

      return true;
    } catch (error) {
      logAuthAttempt('logout', false, {
        userId: user.id,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Change user password and invalidate all tokens
   * @param {object} user - User object
   * @param {string} currentPassword - Current password
   * @param {string} newPassword - New password
   * @returns {boolean} Success status
   */
  async changePassword(user, currentPassword, newPassword) {
    try {
      // Validate current password
      const isCurrentPasswordValid = await user.validatePassword(currentPassword);

      if (!isCurrentPasswordValid) {
        logSecurityEvent('password_change_invalid_current', {
          userId: user.id
        });
        throw new Error('Current password is incorrect');
      }

      // Update password
      await user.update({
        passwordHash: newPassword, // Will be hashed by the model hook
      });

      // Invalidate all tokens by incrementing token version
      await user.invalidateAllTokens('password_change');

      logAuthAttempt('password_change', true, {
        userId: user.id,
        newTokenVersion: user.tokenVersion
      });

      console.log('✅ Password changed for user:', user.id, 'New token version:', user.tokenVersion);

      return true;
    } catch (error) {
      logAuthAttempt('password_change', false, {
        userId: user.id,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Verify JWT token
   * @param {string} token - JWT token
   * @returns {object} Decoded token or null
   */
  verifyToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      return null;
    }
  }

  /**
   * Generate password reset token
   * @param {object} user - User object
   * @returns {string} Reset token
   */
  generatePasswordResetToken(user) {
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenHash = crypto.createHash('sha256').update(resetToken).digest('hex');
    
    return resetToken;
  }

  /**
   * Verify email address with point reward
   * @param {string} token - Verification token
   * @param {string} email - User email
   * @returns {object} Success message with point info
   */
  async verifyEmail(token, email) {
    try {
      const user = await User.findOne({
        where: { 
          email: email.toLowerCase(),
          isActive: true
        }
      });

      if (!user) {
        throw new Error('Invalid verification request');
      }

      if (user.isVerified) {
        return {
          message: 'Email is already verified. You can now log in to your account.',
          alreadyVerified: true
        };
      }

      if (!user.validateEmailVerificationToken(token)) {
        logSecurityEvent('invalid_email_verification_token', {
          userId: user.id,
          email: user.email
        });
        
        if (user.isEmailVerificationExpired()) {
          throw new Error('Verification link has expired. Please request a new verification email.');
        }
        
        throw new Error('Invalid verification token');
      }

      // Mark email as verified
      await user.markEmailAsVerified();

      // NEW: Award points for email verification
      let pointsResult = null;
      try {
        console.log('🎯 Awarding email verification points...');
        pointsResult = await pointService.awardEmailVerificationPoints(user.id);
        console.log('🎁 Email verification points result:', pointsResult);
      } catch (pointError) {
        console.error('❌ Error awarding email verification points:', pointError);
        // Don't throw error - verification should still succeed even if points fail
        logSecurityEvent('email_verification_points_error', {
          userId: user.id,
          error: pointError.message
        });
      }

      // Send welcome email
      try {
        await emailService.sendWelcomeEmail(user);
      } catch (emailError) {
        logSecurityEvent('welcome_email_send_failed', {
          userId: user.id,
          error: emailError.message
        });
      }

      logAuthAttempt('email_verification', true, {
        userId: user.id,
        email: user.email,
        pointsAwarded: pointsResult?.awarded || false
      });

      const response = {
        message: 'Email verified successfully! You can now log in to your account.',
        user: user.toSafeJSON()
      };

      // Add points info to response if awarded
      if (pointsResult?.awarded) {
        response.pointsAwarded = {
          points: pointsResult.points,
          message: pointsResult.message,
          newBalance: pointsResult.newBalance
        };
      }

      return response;
    } catch (error) {
      logAuthAttempt('email_verification', false, {
        email,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Resend email verification
   * @param {string} email - User email
   * @returns {object} Success message
   */
  async resendEmailVerification(email) {
    try {
      const user = await User.findOne({
        where: { 
          email: email.toLowerCase(),
          isActive: true
        }
      });

      if (!user) {
        return {
          message: 'If an account with this email exists and is not verified, a verification email has been sent.'
        };
      }

      if (user.isVerified) {
        return {
          message: 'Email is already verified. You can log in to your account.'
        };
      }

      if (!user.canResendVerificationEmail()) {
        throw new Error('Please wait before requesting another verification email. Check your spam folder.');
      }

      // Generate new verification token
      const verificationToken = user.generateEmailVerificationToken();
      await user.save();

      // Send verification email
      await emailService.sendEmailVerification(user, verificationToken);

      logAuthAttempt('email_verification_resent', true, {
        userId: user.id,
        email: user.email
      });

      return {
        message: 'Verification email has been sent. Please check your inbox and spam folder.'
      };
    } catch (error) {
      logAuthAttempt('email_verification_resent', false, {
        email,
        error: error.message
      });
      throw error;
    }
  }
}

module.exports = new AuthService();


================================================
FILE: src/services/categoryService.js
================================================
const Category = require('../models/Category');
const Product = require('../models/Product');
const { logUserAction } = require('../utils/logger');
const { deleteFile } = require('../middleware/upload');

class CategoryService {
  /**
   * Get all categories with pagination and filtering
   * @param {object} options - Query options
   * @returns {object} Categories with pagination info
   */
  async getAllCategories(options = {}) {
    const {
      page = 1,
      limit = 10,
      search = '',
      isActive,
      sortBy = 'sortOrder',
      sortOrder = 'ASC',
      includeProductCount = false
    } = options;

    const offset = (page - 1) * limit;
    const whereClause = {};

    // Add search filter
    if (search) {
      whereClause[Category.sequelize.Sequelize.Op.or] = [
        { name: { [Category.sequelize.Sequelize.Op.like]: `%${search}%` } },
        { description: { [Category.sequelize.Sequelize.Op.like]: `%${search}%` } }
      ];
    }

    // Add active filter
    if (isActive !== undefined) {
      whereClause.isActive = isActive;
    }

    // Build query options
    const queryOptions = {
      where: whereClause,
      order: [[sortBy, sortOrder.toUpperCase()]],
      limit: parseInt(limit),
      offset: parseInt(offset)
    };

    // Include product count if requested
    if (includeProductCount) {
      queryOptions.attributes = {
        include: [
          [
            Category.sequelize.fn('COUNT', Category.sequelize.col('products.id')),
            'productCount'
          ]
        ]
      };
      queryOptions.include = [{
        model: Product,
        as: 'products',
        attributes: [],
        required: false,
        where: { isActive: true }
      }];
      queryOptions.group = ['Category.id'];
      queryOptions.subQuery = false;
    }

    const { count, rows } = await Category.findAndCountAll(queryOptions);

    return {
      categories: rows,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(count / limit),
        totalItems: count,
        itemsPerPage: parseInt(limit)
      }
    };
  }

  /**
   * Get active categories for public view
   * @returns {Array} Active categories
   */
  async getActiveCategories() {
    return Category.findActiveCategories({
      attributes: ['id', 'name', 'slug', 'description', 'image', 'sortOrder']
    });
  }

  /**
   * Get category by ID
   * @param {number} categoryId - Category ID
   * @param {boolean} includeProducts - Include products
   * @returns {object} Category
   */
  async getCategoryById(categoryId, includeProducts = false) {
    const includeOptions = [];

    if (includeProducts) {
      includeOptions.push({
        model: Product,
        as: 'products',
        where: { isActive: true },
        required: false,
        attributes: ['id', 'title', 'slug', 'price', 'points', 'image', 'isFeatured']
      });
    }

    const category = await Category.findByPk(categoryId, {
      include: includeOptions
    });

    if (!category) {
      throw new Error('Category not found');
    }

    return category;
  }

  /**
   * Get category by slug
   * @param {string} slug - Category slug
   * @param {boolean} includeProducts - Include products
   * @returns {object} Category
   */
  async getCategoryBySlug(slug, includeProducts = false) {
    const includeOptions = [];

    if (includeProducts) {
      includeOptions.push({
        model: Product,
        as: 'products',
        where: { isActive: true },
        required: false,
        attributes: ['id', 'title', 'slug', 'price', 'points', 'image', 'isFeatured'],
        order: [['sortOrder', 'ASC'], ['createdAt', 'DESC']]
      });
    }

    const category = await Category.findOne({
      where: { slug },
      include: includeOptions
    });

    if (!category) {
      throw new Error('Category not found');
    }

    return category;
  }

  /**
   * Create new category
   * @param {object} categoryData - Category data
   * @param {number} userId - User ID who creates the category
   * @returns {object} Created category
   */
  async createCategory(categoryData, userId) {
    const { name, slug, description, isActive, sortOrder } = categoryData;

    // Check if category with same name or slug exists (including soft deleted ones)
    const existingCategory = await Category.findOne({
      where: {
        [Category.sequelize.Sequelize.Op.or]: [
          { name },
          { slug: slug || name.toLowerCase().replace(/\s+/g, '-') }
        ]
      },
      paranoid: false // Include soft deleted records
    });

    if (existingCategory) {
      const field = existingCategory.name === name ? 'name' : 'slug';
      throw new Error(`Category with this ${field} already exists`);
    }

    const category = await Category.create({
      name,
      slug,
      description,
      isActive: isActive !== undefined ? isActive : true,
      sortOrder: sortOrder || 0,
      createdBy: userId
    });

    logUserAction('category_created', userId, {
      categoryId: category.id,
      categoryName: category.name
    });

    return category;
  }

  /**
   * Update category
   * @param {number} categoryId - Category ID
   * @param {object} updateData - Update data
   * @param {number} userId - User ID who updates the category
   * @returns {object} Updated category
   */
  async updateCategory(categoryId, updateData, userId) {
    const category = await Category.findByPk(categoryId);

    if (!category) {
      throw new Error('Category not found');
    }

    // Check for duplicate name/slug if they're being updated
    if (updateData.name || updateData.slug) {
      const whereClause = {
        id: { [Category.sequelize.Sequelize.Op.ne]: categoryId }
      };

      const orConditions = [];
      if (updateData.name) orConditions.push({ name: updateData.name });
      if (updateData.slug) orConditions.push({ slug: updateData.slug });

      if (orConditions.length > 0) {
        whereClause[Category.sequelize.Sequelize.Op.or] = orConditions;
      }

      const existingCategory = await Category.findOne({ 
        where: whereClause,
        paranoid: false // Include soft deleted records
      });

      if (existingCategory) {
        const field = existingCategory.name === updateData.name ? 'name' : 'slug';
        throw new Error(`Category with this ${field} already exists`);
      }
    }

    // Update category
    await category.update({
      ...updateData,
      updatedBy: userId
    });

    logUserAction('category_updated', userId, {
      categoryId: category.id,
      categoryName: category.name,
      changes: Object.keys(updateData)
    });

    return category;
  }

  /**
   * Delete category (Soft delete)
   * @param {number} categoryId - Category ID
   * @param {number} userId - User ID who deletes the category
   * @returns {boolean} Success status
   */
  async deleteCategory(categoryId, userId) {
    const category = await Category.findByPk(categoryId);

    if (!category) {
      throw new Error('Category not found');
    }

    // Check if category has active products
    const productCount = await Product.count({
      where: { 
        categoryId,
        isActive: true 
      }
    });

    if (productCount > 0) {
      throw new Error('Cannot delete category that has active products. Please deactivate or move products first.');
    }

    // Perform soft delete
    await category.destroy();

    logUserAction('category_deleted', userId, {
      categoryId,
      categoryName: category.name
    });

    return true;
  }

  /**
   * Force delete category (Hard delete)
   * @param {number} categoryId - Category ID
   * @param {number} userId - User ID who deletes the category
   * @returns {boolean} Success status
   */
  async forceDeleteCategory(categoryId, userId) {
    const category = await Category.findByPk(categoryId, {
      paranoid: false // Include soft deleted records
    });

    if (!category) {
      throw new Error('Category not found');
    }

    // Check if category has products
    const productCount = await Product.count({
      where: { categoryId },
      paranoid: false // Include soft deleted products
    });

    if (productCount > 0) {
      throw new Error('Cannot permanently delete category that has products. Please delete products first.');
    }

    // Delete category image if exists
    if (category.image) {
      deleteFile(`uploads/categories/${category.image}`);
    }

    // Force delete (permanent)
    await category.destroy({ force: true });

    logUserAction('category_force_deleted', userId, {
      categoryId,
      categoryName: category.name
    });

    return true;
  }

  /**
   * Restore soft deleted category
   * @param {number} categoryId - Category ID
   * @param {number} userId - User ID who restores the category
   * @returns {object} Restored category
   */
  async restoreCategory(categoryId, userId) {
    const category = await Category.findByPk(categoryId, {
      paranoid: false
    });

    if (!category) {
      throw new Error('Category not found');
    }

    if (!category.deletedAt) {
      throw new Error('Category is not deleted');
    }

    await category.restore();

    logUserAction('category_restored', userId, {
      categoryId,
      categoryName: category.name
    });

    return category;
  }

  /**
   * Upload category image
   * @param {number} categoryId - Category ID
   * @param {string} filename - Image filename
   * @param {number} userId - User ID
   * @returns {object} Updated category
   */
  async uploadCategoryImage(categoryId, filename, userId) {
    const category = await Category.findByPk(categoryId);

    if (!category) {
      throw new Error('Category not found');
    }

    // Delete old image if exists
    if (category.image) {
      deleteFile(`uploads/categories/${category.image}`);
    }

    // Update category with new image
    await category.update({
      image: filename,
      updatedBy: userId
    });

    logUserAction('category_image_uploaded', userId, {
      categoryId,
      filename
    });

    return category;
  }

  /**
   * Toggle category status
   * @param {number} categoryId - Category ID
   * @param {number} userId - User ID
   * @returns {object} Updated category
   */
  async toggleCategoryStatus(categoryId, userId) {
    const category = await Category.findByPk(categoryId);

    if (!category) {
      throw new Error('Category not found');
    }

    await category.update({
      isActive: !category.isActive,
      updatedBy: userId
    });

    logUserAction('category_status_toggled', userId, {
      categoryId,
      newStatus: category.isActive
    });

    return category;
  }
}

module.exports = new CategoryService();


================================================
FILE: src/services/emailService.js
================================================
const nodemailer = require('nodemailer');
const { logSystemError, logUserAction } = require('../utils/logger');

class EmailService {
  constructor() {
    this.transporter = null;
    this.provider = 'none';
    this.lastError = null;
    this.appName = process.env.APP_NAME || 'Secure Node.js Backend';
    this.fromEmail = process.env.FROM_EMAIL;
    this.baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    
    // Debug nodemailer import
    console.log('🔍 Checking nodemailer import...');
    console.log('   nodemailer type:', typeof nodemailer);
    console.log('   createTransport type:', typeof nodemailer.createTransport);
    console.log('   nodemailer methods:', Object.keys(nodemailer));
    
    this.initializeTransporter();
  }

  /**
   * Initialize email transporter - FIXED ALL REFERENCES
   */
  initializeTransporter() {
    console.log('🔧 Starting email transporter initialization...');
    
    try {
      // FIXED: Check for createTransport (not createTransporter)
      if (!nodemailer || typeof nodemailer.createTransport !== 'function') {
        const error = `Nodemailer import issue. Type: ${typeof nodemailer}, createTransport: ${typeof nodemailer?.createTransport}`;
        console.error('❌', error);
        console.log('Available nodemailer methods:', Object.keys(nodemailer || {}));
        this.lastError = error;
        this.provider = 'error';
        return;
      }

      // Debug environment variables
      console.log('🔍 Environment check:');
      console.log(`   NODE_ENV: ${process.env.NODE_ENV}`);
      console.log(`   MAILJET_API_KEY: ${process.env.MAILJET_API_KEY ? 'SET (' + process.env.MAILJET_API_KEY.substring(0, 8) + '...)' : 'NOT SET'}`);
      console.log(`   MAILJET_SECRET_KEY: ${process.env.MAILJET_SECRET_KEY ? 'SET (' + process.env.MAILJET_SECRET_KEY.substring(0, 8) + '...)' : 'NOT SET'}`);
      console.log(`   FROM_EMAIL: ${process.env.FROM_EMAIL || 'NOT SET'}`);
      console.log(`   APP_NAME: ${process.env.APP_NAME || 'NOT SET'}`);

      if (process.env.NODE_ENV === 'test') {
        console.log('🧪 Test environment detected, using Ethereal email...');
        // FIXED: Use createTransport
        this.transporter = nodemailer.createTransport({
          host: 'smtp.ethereal.email',
          port: 587,
          auth: {
            user: 'test@example.com',
            pass: 'test'
          }
        });
        this.provider = 'test';
        console.log('✅ Test email transporter initialized');
        return;
      }

      // Validate required environment variables
      if (!process.env.MAILJET_API_KEY) {
        const error = 'MAILJET_API_KEY environment variable is not set';
        console.error('❌', error);
        this.lastError = error;
        this.provider = 'error';
        return;
      }

      if (!process.env.MAILJET_SECRET_KEY) {
        const error = 'MAILJET_SECRET_KEY environment variable is not set';
        console.error('❌', error);
        this.lastError = error;
        this.provider = 'error';
        return;
      }

      if (!process.env.FROM_EMAIL) {
        const error = 'FROM_EMAIL environment variable is not set';
        console.error('❌', error);
        this.lastError = error;
        this.provider = 'error';
        return;
      }

      // Validate email format
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(process.env.FROM_EMAIL)) {
        const error = `FROM_EMAIL has invalid format: ${process.env.FROM_EMAIL}`;
        console.error('❌', error);
        this.lastError = error;
        this.provider = 'error';
        return;
      }

      console.log('✅ All required environment variables are set');
      console.log('🔧 Creating Mailjet transporter...');

      // Mailjet SMTP configuration
      const transporterConfig = {
        host: 'in-v3.mailjet.com',
        port: 587,
        secure: false, // Use STARTTLS
        auth: {
          user: process.env.MAILJET_API_KEY,
          pass: process.env.MAILJET_SECRET_KEY
        },
        tls: {
          rejectUnauthorized: false
        },
        // Connection pooling and performance settings
        pool: true,
        maxConnections: 1,
        maxMessages: 100,
        rateLimit: 10, // Max 10 emails per second
        debug: process.env.NODE_ENV === 'development',
        logger: process.env.NODE_ENV === 'development'
      };

      console.log('📧 Transporter config:');
      console.log(`   Host: ${transporterConfig.host}`);
      console.log(`   Port: ${transporterConfig.port}`);
      console.log(`   Secure: ${transporterConfig.secure}`);
      console.log(`   Auth User: ${transporterConfig.auth.user.substring(0, 8)}...`);
      console.log(`   Pool: ${transporterConfig.pool}`);

      // FIXED: Use createTransport (correct method name)
      console.log('🔧 Calling nodemailer.createTransport...');
      this.transporter = nodemailer.createTransport(transporterConfig);
      this.provider = 'mailjet';
      this.lastError = null;

      console.log('✅ Mailjet transporter created successfully');
      console.log(`📧 Provider: ${this.provider}`);
      console.log(`📧 From Email: ${process.env.FROM_EMAIL}`);
      console.log(`📧 App Name: ${process.env.APP_NAME}`);

      // Quick verification (non-blocking)
      console.log('🔍 Testing transporter verification...');
      this.transporter.verify()
        .then(() => {
          console.log('✅ Mailjet connection verified successfully');
        })
        .catch((error) => {
          console.warn('⚠️ Connection verification failed (but transporter created):', error.message);
          // Don't change provider status here
        });
      
    } catch (error) {
      console.error('❌ Failed to initialize email transporter:', error);
      console.error('   Error details:', {
        message: error.message,
        code: error.code,
        stack: error.stack
      });
      
      this.transporter = null;
      this.provider = 'error';
      this.lastError = error.message;
    }
  }

  /**
   * Get detailed status information - FIXED PROPERTIES
   */
  getStatus() {
    return {
      provider: this.provider,
      hasTransporter: !!this.transporter,
      lastError: this.lastError,
      nodemailerInfo: {
        imported: !!nodemailer,
        type: typeof nodemailer,
        // FIXED: Check createTransport (not createTransporter)
        createTransportType: typeof nodemailer?.createTransport,
        version: this.getNodemailerVersion(),
        availableMethods: nodemailer ? Object.keys(nodemailer) : []
      },
      config: {
        mailjetApiKey: process.env.MAILJET_API_KEY ? `${process.env.MAILJET_API_KEY.substring(0, 8)}...` : null,
        mailjetSecretKeySet: !!process.env.MAILJET_SECRET_KEY,
        fromEmail: process.env.FROM_EMAIL,
        appName: process.env.APP_NAME,
        nodeEnv: process.env.NODE_ENV
      }
    };
  }

  /**
   * Get nodemailer version
   */
  getNodemailerVersion() {
    try {
      const packageInfo = require('nodemailer/package.json');
      return packageInfo.version;
    } catch (e) {
      return 'unknown';
    }
  }

  /**
   * Force reinitialize transporter
   */
  reinitialize() {
    console.log('🔄 Force reinitializing email transporter...');
    this.transporter = null;
    this.provider = 'none';
    this.lastError = null;
    this.initializeTransporter();
    return this.getStatus();
  }

  /**
   * Send email verification with enhanced error handling
   */
  async sendEmailVerification(user, token) {
    console.log('📧 Attempting to send email verification...');
    console.log('   Current provider:', this.provider);
    console.log('   Has transporter:', !!this.transporter);
    console.log('   User email:', user.email);

    try {
      // Check if transporter is available
      if (!this.transporter) {
        console.error('❌ Email transporter not available');
        console.error('   Provider status:', this.provider);
        console.error('   Last error:', this.lastError);
        return false;
      }

      if (this.provider === 'error') {
        console.error('❌ Email service is in error state');
        console.error('   Last error:', this.lastError);
        return false;
      }

      const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
      const verificationUrl = `${baseUrl}/api/v1/auth/verify-email?token=${token}&email=${encodeURIComponent(user.email)}`;
      
      const mailOptions = {
        from: {
          name: process.env.APP_NAME || 'Secure Node.js Backend',
          address: process.env.FROM_EMAIL
        },
        to: user.email,
        subject: `Verify Your Email - ${process.env.APP_NAME || 'Secure Node.js Backend'}`,
        html: this.generateEmailVerificationTemplate(user, verificationUrl),
        text: this.generateEmailVerificationText(user, verificationUrl)
      };

      console.log('📧 Mail options:');
      console.log('   From:', mailOptions.from);
      console.log('   To:', mailOptions.to);
      console.log('   Subject:', mailOptions.subject);
      
      console.log('📧 Sending email via Mailjet...');
      const info = await this.transporter.sendMail(mailOptions);
      
      console.log('✅ Email sent successfully:', {
        messageId: info.messageId,
        recipient: user.email,
        provider: this.provider,
        response: info.response
      });
      
      // Safe logging with try-catch
      try {
        if (typeof logUserAction === 'function') {
          logUserAction('email_verification_sent', user.id, {
            email: user.email,
            messageId: info.messageId,
            provider: this.provider
          });
        }
      } catch (logError) {
        console.warn('Warning: Could not log user action:', logError.message);
      }

      return true;
    } catch (error) {
      console.error('❌ Failed to send verification email:', {
        error: error.message,
        code: error.code,
        command: error.command,
        response: error.response,
        responseCode: error.responseCode,
        userId: user.id,
        email: user.email,
        provider: this.provider
      });

      // Safe logging with try-catch
      try {
        if (typeof logSystemError === 'function') {
          logSystemError(error, {
            context: 'send_email_verification',
            userId: user.id,
            email: user.email,
            provider: this.provider
          });
        }
      } catch (logError) {
        console.warn('Warning: Could not log system error:', logError.message);
      }
      
      return false;
    }
  }

  /**
   * Send account banned notification email
   * @param {object} user - User object
   * @param {string} reason - Reason for banning
   * @returns {boolean} Success status
   */
  async sendAccountBannedNotification(user, reason = 'Terms of service violation') {
    try {
      if (!this.transporter) {
        console.error('❌ Email transporter not available for ban notification');
        return false;
      }

      const subject = `${this.appName} - Account Suspended`;
      
      const htmlContent = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Account Suspended</title>
          <style>
            body { 
              font-family: Arial, sans-serif; 
              line-height: 1.6; 
              color: #333; 
              margin: 0; 
              padding: 0; 
              background-color: #f4f4f4;
            }
            .container { 
              max-width: 600px; 
              margin: 0 auto; 
              padding: 20px; 
              background-color: white;
              box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }
            .header { 
              background: #dc3545; 
              color: white; 
              padding: 20px; 
              text-align: center; 
              border-radius: 8px 8px 0 0; 
            }
            .content { 
              background: #f8f9fa; 
              padding: 30px; 
              border-radius: 0 0 8px 8px; 
            }
            .warning-box { 
              background: #fff3cd; 
              border: 1px solid #ffeaa7; 
              padding: 15px; 
              border-radius: 5px; 
              margin: 20px 0; 
            }
            .support-box { 
              background: #d1ecf1; 
              border: 1px solid #bee5eb; 
              padding: 20px; 
              border-radius: 5px; 
              margin: 20px 0; 
              text-align: center; 
            }
            .footer { 
              text-align: center; 
              margin-top: 30px; 
              font-size: 12px; 
              color: #666; 
            }
            ul { 
              padding-left: 20px; 
            }
            li { 
              margin: 8px 0; 
            }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>🚫 Account Suspended</h1>
            </div>
            <div class="content">
              <h2>Hello ${user.username},</h2>
              
              <div class="warning-box">
                <p><strong>⚠️ Your account has been suspended</strong></p>
                <p>Your ${this.appName} account has been temporarily suspended and you will not be able to access our services.</p>
              </div>

              <h3>📋 Suspension Details:</h3>
              <ul>
                <li><strong>Account:</strong> ${user.email}</li>
                <li><strong>Username:</strong> ${user.username}</li>
                <li><strong>Reason:</strong> ${reason}</li>
                <li><strong>Date:</strong> ${new Date().toLocaleDateString('id-ID', { 
                  year: 'numeric', 
                  month: 'long', 
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                })}</li>
              </ul>

              <div class="support-box">
                <h3>🆘 Need Help?</h3>
                <p><strong>For more information about your account status, please contact:</strong></p>
                <p><strong>📧 support@sijago.ai</strong></p>
                <p>Our support team will review your case and provide further assistance.</p>
              </div>

              <h3>🔍 What happens next?</h3>
              <ul>
                <li>Your account access has been temporarily disabled</li>
                <li>Your data remains secure in our system</li>
                <li>You can contact support for clarification or appeal</li>
                <li>Account reactivation is possible upon review</li>
              </ul>

              <p><strong>Important:</strong> If you believe this suspension was made in error, please contact our support team immediately with details about your situation.</p>
            </div>
            
            <div class="footer">
              <p>&copy; ${new Date().getFullYear()} ${this.appName}. All rights reserved.</p>
              <p>This is an automated message. Please do not reply to this email.</p>
            </div>
          </div>
        </body>
        </html>
      `;

      const textContent = `
Account Suspended - ${this.appName}

Hello ${user.username},

Your ${this.appName} account has been suspended.

Suspension Details:
- Account: ${user.email}
- Username: ${user.username}
- Reason: ${reason}
- Date: ${new Date().toLocaleDateString('id-ID')}

For more information about your account status, please contact: support@sijago.ai

What happens next:
- Your account access has been temporarily disabled
- Your data remains secure in our system
- You can contact support for clarification or appeal
- Account reactivation is possible upon review

If you believe this suspension was made in error, please contact our support team immediately.

© ${new Date().getFullYear()} ${this.appName}. All rights reserved.
      `;

      const mailOptions = {
        from: this.fromEmail,
        to: user.email,
        subject: subject,
        text: textContent,
        html: htmlContent
      };

      const info = await this.transporter.sendMail(mailOptions);
      
      console.log('✅ Account banned notification sent successfully:', {
        messageId: info.MessageID || info.messageId,
        to: user.email,
        reason: reason
      });

      return true;
    } catch (error) {
      console.error('❌ Failed to send account banned notification:', error);
      return false;
    }
  }

  /**
   * Send account reactivated notification email
   * @param {object} user - User object
   * @param {string} reason - Reason for reactivation
   * @returns {boolean} Success status
   */
  async sendAccountReactivatedNotification(user, reason = 'Account reviewed and reactivated') {
    try {
      if (!this.transporter) {
        console.error('❌ Email transporter not available for reactivation notification');
        return false;
      }

      const subject = `${this.appName} - Account Reactivated`;
      
      const htmlContent = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Account Reactivated</title>
          <style>
            body { 
              font-family: Arial, sans-serif; 
              line-height: 1.6; 
              color: #333; 
              margin: 0; 
              padding: 0; 
              background-color: #f4f4f4;
            }
            .container { 
              max-width: 600px; 
              margin: 0 auto; 
              padding: 20px; 
              background-color: white;
              box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }
            .header { 
              background: #28a745; 
              color: white; 
              padding: 20px; 
              text-align: center; 
              border-radius: 8px 8px 0 0; 
            }
            .content { 
              background: #f8f9fa; 
              padding: 30px; 
              border-radius: 0 0 8px 8px; 
            }
            .success-box { 
              background: #d4edda; 
              border: 1px solid #c3e6cb; 
              padding: 15px; 
              border-radius: 5px; 
              margin: 20px 0; 
            }
            .info-box { 
              background: #d1ecf1; 
              border: 1px solid #bee5eb; 
              padding: 20px; 
              border-radius: 5px; 
              margin: 20px 0; 
            }
            .footer { 
              text-align: center; 
              margin-top: 30px; 
              font-size: 12px; 
              color: #666; 
            }
            .btn { 
              display: inline-block; 
              padding: 12px 24px; 
              background: #007bff; 
              color: white; 
              text-decoration: none; 
              border-radius: 5px; 
              margin: 10px 0; 
            }
            ul { 
              padding-left: 20px; 
            }
            li { 
              margin: 8px 0; 
            }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>✅ Account Reactivated</h1>
            </div>
            <div class="content">
              <h2>Welcome back, ${user.username}!</h2>
              
              <div class="success-box">
                <p><strong>🎉 Great news! Your account has been reactivated</strong></p>
                <p>You can now access all ${this.appName} services again.</p>
              </div>

              <h3>📋 Reactivation Details:</h3>
              <ul>
                <li><strong>Account:</strong> ${user.email}</li>
                <li><strong>Username:</strong> ${user.username}</li>
                <li><strong>Reason:</strong> ${reason}</li>
                <li><strong>Date:</strong> ${new Date().toLocaleDateString('id-ID', { 
                  year: 'numeric', 
                  month: 'long', 
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                })}</li>
              </ul>

              <div class="info-box">
                <h3>🔑 What you can do now:</h3>
                <ul>
                  <li>Log in to your account normally</li>
                  <li>Access all platform features</li>
                  <li>Continue where you left off</li>
                  <li>Enjoy our services without restrictions</li>
                </ul>
              </div>

              <div style="text-align: center; margin: 30px 0;">
                <a href="${this.baseUrl}/login" class="btn">Login to Your Account</a>
              </div>

              <h3>📝 Important Reminders:</h3>
              <ul>
                <li>Please review our Terms of Service to avoid future issues</li>
                <li>Contact support if you have any questions: <strong>support@sijago.ai</strong></li>
                <li>Your account data and settings have been preserved</li>
              </ul>

              <p>Thank you for your patience during the review process. We're glad to have you back!</p>
            </div>
            
            <div class="footer">
              <p>&copy; ${new Date().getFullYear()} ${this.appName}. All rights reserved.</p>
              <p>This is an automated message. Please do not reply to this email.</p>
            </div>
          </div>
        </body>
        </html>
      `;

      const textContent = `
Account Reactivated - ${this.appName}

Welcome back, ${user.username}!

Great news! Your account has been reactivated and you can now access all ${this.appName} services again.

Reactivation Details:
- Account: ${user.email}
- Username: ${user.username}
- Reason: ${reason}
- Date: ${new Date().toLocaleDateString('id-ID')}

What you can do now:
- Log in to your account normally
- Access all platform features
- Continue where you left off
- Enjoy our services without restrictions

Important Reminders:
- Please review our Terms of Service to avoid future issues
- Contact support if you have any questions: support@sijago.ai
- Your account data and settings have been preserved

Thank you for your patience during the review process. We're glad to have you back!

Login: ${this.baseUrl}/login

© ${new Date().getFullYear()} ${this.appName}. All rights reserved.
      `;

      const mailOptions = {
        from: this.fromEmail,
        to: user.email,
        subject: subject,
        text: textContent,
        html: htmlContent
      };

      const info = await this.transporter.sendMail(mailOptions);
      
      console.log('✅ Account reactivation notification sent successfully:', {
        messageId: info.MessageID || info.messageId,
        to: user.email,
        reason: reason
      });

      return true;
    } catch (error) {
      console.error('❌ Failed to send account reactivation notification:', error);
      return false;
    }
  }

  /**
   * Send ban appeal instructions email
   * @param {object} user - User object
   * @param {string} appealEmail - Email address for appeals
   * @returns {boolean} Success status
   */
  async sendBanAppealInstructions(user, appealEmail = 'support@sijago.ai') {
    try {
      if (!this.transporter) {
        console.error('❌ Email transporter not available for ban appeal instructions');
        return false;
      }

      const subject = `${this.appName} - Account Appeal Process`;
      
      const htmlContent = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Account Appeal Process</title>
          <style>
            body { 
              font-family: Arial, sans-serif; 
              line-height: 1.6; 
              color: #333; 
              margin: 0; 
              padding: 0; 
              background-color: #f4f4f4;
            }
            .container { 
              max-width: 600px; 
              margin: 0 auto; 
              padding: 20px; 
              background-color: white;
              box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }
            .header { 
              background: #17a2b8; 
              color: white; 
              padding: 20px; 
              text-align: center; 
              border-radius: 8px 8px 0 0; 
            }
            .content { 
              background: #f8f9fa; 
              padding: 30px; 
              border-radius: 0 0 8px 8px; 
            }
            .info-box { 
              background: #d1ecf1; 
              border: 1px solid #bee5eb; 
              padding: 20px; 
              border-radius: 5px; 
              margin: 20px 0; 
            }
            .steps-box { 
              background: #fff; 
              border: 1px solid #dee2e6; 
              padding: 20px; 
              border-radius: 5px; 
              margin: 20px 0; 
            }
            .footer { 
              text-align: center; 
              margin-top: 30px; 
              font-size: 12px; 
              color: #666; 
            }
            .step { 
              margin: 15px 0; 
              padding: 15px; 
              background: #f8f9fa; 
              border-left: 4px solid #007bff; 
              border-radius: 0 5px 5px 0;
            }
            ul { 
              padding-left: 20px; 
            }
            li { 
              margin: 8px 0; 
            }
            .template-box {
              background: #e9ecef;
              padding: 20px;
              border-radius: 5px;
              margin: 15px 0;
              font-family: monospace;
              font-size: 14px;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>📋 Account Appeal Process</h1>
            </div>
            <div class="content">
              <h2>Hello ${user.username},</h2>
              
              <div class="info-box">
                <p><strong>ℹ️ You have requested information about the appeal process</strong></p>
                <p>We understand your concern about your account status. Here's how you can submit an appeal.</p>
              </div>

              <h3>📝 How to Submit an Appeal:</h3>
              
              <div class="steps-box">
                <div class="step">
                  <strong>Step 1:</strong> Send an email to <strong>${appealEmail}</strong>
                </div>
                
                <div class="step">
                  <strong>Step 2:</strong> Include the following information:
                  <ul>
                    <li>Your account email: ${user.email}</li>
                    <li>Your username: ${user.username}</li>
                    <li>Subject: "Account Appeal Request"</li>
                    <li>Detailed explanation of your situation</li>
                    <li>Any relevant evidence or documentation</li>
                  </ul>
                </div>
                
                <div class="step">
                  <strong>Step 3:</strong> Wait for our response (typically 3-5 business days)
                </div>
                
                <div class="step">
                  <strong>Step 4:</strong> Follow any additional instructions from our support team
                </div>
              </div>

              <h3>📧 Email Template for Appeal:</h3>
              <div class="template-box">
To: ${appealEmail}
Subject: Account Appeal Request - ${user.username}

Dear Support Team,

I am writing to appeal the suspension of my account.

Account Details:
- Email: ${user.email}
- Username: ${user.username}
- Suspension Date: [Insert date if known]

Reason for Appeal:
[Explain your situation and why you believe the suspension should be reviewed]

Additional Information:
[Include any relevant details or evidence]

Thank you for your time and consideration.

Best regards,
[Your Name]
              </div>

              <h3>⏰ What to Expect:</h3>
              <ul>
                <li><strong>Response Time:</strong> 3-5 business days</li>
                <li><strong>Review Process:</strong> Our team will carefully review your case</li>
                <li><strong>Possible Outcomes:</strong> Account reactivation, partial restrictions, or appeal denial</li>
                <li><strong>Communication:</strong> All updates will be sent to your email</li>
              </ul>

              <h3>📞 Additional Support:</h3>
              <div class="info-box">
                <p>If you have urgent questions about the appeal process, you can also contact us at:</p>
                <ul>
                  <li><strong>Email:</strong> ${appealEmail}</li>
                  <li><strong>Response Time:</strong> Within 24 hours</li>
                </ul>
              </div>

              <p><strong>Note:</strong> Please be patient as our team reviews each case thoroughly to ensure fair treatment.</p>
            </div>
            
            <div class="footer">
              <p>&copy; ${new Date().getFullYear()} ${this.appName}. All rights reserved.</p>
              <p>This is an automated message. Please do not reply to this email.</p>
            </div>
          </div>
        </body>
        </html>
      `;

      const textContent = `
Account Appeal Process - ${this.appName}

Hello ${user.username},

You have requested information about the appeal process. Here's how you can submit an appeal.

How to Submit an Appeal:

Step 1: Send an email to ${appealEmail}

Step 2: Include the following information:
- Your account email: ${user.email}
- Your username: ${user.username}
- Subject: "Account Appeal Request"
- Detailed explanation of your situation
- Any relevant evidence or documentation

Step 3: Wait for our response (typically 3-5 business days)

Step 4: Follow any additional instructions from our support team

Email Template for Appeal:
To: ${appealEmail}
Subject: Account Appeal Request - ${user.username}

Dear Support Team,

I am writing to appeal the suspension of my account.

Account Details:
- Email: ${user.email}
- Username: ${user.username}
- Suspension Date: [Insert date if known]

Reason for Appeal:
[Explain your situation and why you believe the suspension should be reviewed]

Additional Information:
[Include any relevant details or evidence]

Thank you for your time and consideration.

Best regards,
[Your Name]

What to Expect:
- Response Time: 3-5 business days
- Review Process: Our team will carefully review your case
- Possible Outcomes: Account reactivation, partial restrictions, or appeal denial
- Communication: All updates will be sent to your email

Additional Support:
Email: ${appealEmail}
Response Time: Within 24 hours

Note: Please be patient as our team reviews each case thoroughly to ensure fair treatment.

© ${new Date().getFullYear()} ${this.appName}. All rights reserved.
      `;

      const mailOptions = {
        from: this.fromEmail,
        to: user.email,
        subject: subject,
        text: textContent,
        html: htmlContent
      };

      const info = await this.transporter.sendMail(mailOptions);
      
      console.log('✅ Ban appeal instructions sent successfully:', {
        messageId: info.MessageID || info.messageId,
        to: user.email,
        appealEmail: appealEmail
      });

      return true;
    } catch (error) {
      console.error('❌ Failed to send ban appeal instructions:', error);
      return false;
    }
  }

  /**
   * Test email configuration with comprehensive diagnostics
   */
  async testConnection() {
    console.log('🔍 Testing email connection...');
    console.log('   Provider:', this.provider);
    console.log('   Has transporter:', !!this.transporter);
    console.log('   Last error:', this.lastError);

    try {
      if (!this.transporter) {
        return {
          success: false,
          provider: this.provider,
          error: this.lastError || 'Email transporter not initialized',
          suggestion: 'Check Mailjet API credentials in .env file',
          details: this.getStatus()
        };
      }

      if (this.provider === 'error') {
        return {
          success: false,
          provider: this.provider,
          error: this.lastError || 'Email service in error state',
          suggestion: 'Check environment variables and restart server',
          details: this.getStatus()
        };
      }
      
      console.log('🔍 Verifying Mailjet connection...');
      await this.transporter.verify();
      
      console.log('✅ Mailjet connection test successful');
      
      return {
        success: true,
        provider: this.provider,
        message: 'Mailjet connection verified successfully',
        config: {
          host: 'in-v3.mailjet.com',
          port: 587,
          apiKey: process.env.MAILJET_API_KEY ? `${process.env.MAILJET_API_KEY.substring(0, 8)}...` : 'Not set',
          fromEmail: process.env.FROM_EMAIL
        },
        details: this.getStatus()
      };
    } catch (error) {
      console.error('❌ Mailjet connection test failed:', {
        error: error.message,
        code: error.code,
        command: error.command,
        response: error.response
      });
      
      // Safe logging with try-catch
      try {
        if (typeof logSystemError === 'function') {
          logSystemError(error, { 
            context: 'email_test_connection',
            provider: this.provider 
          });
        }
      } catch (logError) {
        console.warn('Warning: Could not log system error:', logError.message);
      }
      
      return {
        success: false,
        provider: this.provider,
        error: error.message,
        code: error.code,
        suggestion: this.getErrorSuggestion(error),
        details: this.getStatus()
      };
    }
  }

  /**
   * Get suggestion based on error type
   */
  getErrorSuggestion(error) {
    if (error.code === 'EAUTH') {
      return 'Invalid Mailjet API credentials. Check MAILJET_API_KEY and MAILJET_SECRET_KEY';
    } else if (error.code === 'ENOTFOUND') {
      return 'Network connectivity issue. Check internet connection';
    } else if (error.code === 'ECONNECTION') {
      return 'Cannot connect to Mailjet SMTP server. Check firewall settings';
    } else if (error.code === 'ETIMEDOUT') {
      return 'Connection timeout. Check network connectivity';
    } else if (error.message.includes('Invalid API key')) {
      return 'Invalid Mailjet API key. Verify your API credentials';
    } else if (error.message.includes('Invalid Secret key')) {
      return 'Invalid Mailjet Secret key. Verify your API credentials';
    } else {
      return 'Check Mailjet account status and API credentials';
    }
  }

  /**
   * Generate HTML template for email verification
   */
  generateEmailVerificationTemplate(user, verificationUrl) {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Verification</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #667eea; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; font-weight: bold; }
        .button:hover { background: #5a67d8; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
        .security-note { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔐 Email Verification Required</h1>
        <p>Welcome to ${process.env.APP_NAME || 'Secure Node.js Backend'}!</p>
    </div>
    
    <div class="content">
        <h2>Hello ${user.username}!</h2>
        
        <p>Thank you for registering with us. To complete your registration and secure your account, please verify your email address by clicking the button below:</p>
        
        <div style="text-align: center;">
            <a href="${verificationUrl}" class="button">✅ Verify Email Address</a>
        </div>
        
        <div class="security-note">
            <h3>🔒 Security Information:</h3>
            <ul>
                <li>This verification link will expire in <strong>24 hours</strong></li>
                <li>You cannot log in until your email is verified</li>
                <li>If you didn't create this account, please ignore this email</li>
            </ul>
        </div>
        
        <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
        <p style="word-break: break-all; background: #e9ecef; padding: 10px; border-radius: 5px; font-family: monospace;">
            ${verificationUrl}
        </p>
        
        <p>If you have any questions or need assistance, please don't hesitate to contact our support team.</p>
        
        <p>Best regards,<br>
        <strong>${process.env.APP_NAME || 'Secure Node.js Backend'} Team</strong></p>
    </div>
    
    <div class="footer">
        <p>This email was sent to ${user.email}. If you did not request this verification, please ignore this email.</p>
        <p>&copy; ${new Date().getFullYear()} ${process.env.APP_NAME || 'Secure Node.js Backend'}. All rights reserved.</p>
    </div>
</body>
</html>`;
  }

  /**
   * Generate plain text template for email verification
   */
  generateEmailVerificationText(user, verificationUrl) {
    return `
Email Verification Required

Hello ${user.username}!

Thank you for registering with ${process.env.APP_NAME || 'Secure Node.js Backend'}. To complete your registration and secure your account, please verify your email address by visiting the following link:

${verificationUrl}

Security Information:
- This verification link will expire in 24 hours
- You cannot log in until your email is verified
- If you didn't create this account, please ignore this email

If you have any questions or need assistance, please contact our support team.

Best regards,
${process.env.APP_NAME || 'Secure Node.js Backend'} Team

This email was sent to ${user.email}. If you did not request this verification, please ignore this email.

© ${new Date().getFullYear()} ${process.env.APP_NAME || 'Secure Node.js Backend'}. All rights reserved.
`;
  }

  /**
   * Send welcome email after verification
   */
  async sendWelcomeEmail(user) {
    try {
      if (!this.transporter || this.provider === 'error') {
        console.warn('Email transporter not available. Skipping welcome email.');
        return false;
      }

      const mailOptions = {
        from: {
          name: process.env.APP_NAME || 'Secure Node.js Backend',
          address: process.env.FROM_EMAIL
        },
        to: user.email,
        subject: `Welcome to ${process.env.APP_NAME || 'Secure Node.js Backend'}!`,
        html: this.generateWelcomeEmailTemplate(user),
        text: this.generateWelcomeEmailText(user)
      };

      console.log(`📧 Sending welcome email to: ${user.email}`);
      
      const info = await this.transporter.sendMail(mailOptions);
      
      console.log('✅ Welcome email sent successfully:', {
        messageId: info.messageId,
        recipient: user.email
      });
      
      try {
        if (typeof logUserAction === 'function') {
          logUserAction('welcome_email_sent', user.id, {
            email: user.email,
            messageId: info.messageId,
            provider: this.provider
          });
        }
      } catch (logError) {
        console.warn('Warning: Could not log user action:', logError.message);
      }

      return true;
    } catch (error) {
      console.error('❌ Failed to send welcome email:', error.message);
      
      try {
        if (typeof logSystemError === 'function') {
          logSystemError(error, {
            context: 'send_welcome_email',
            userId: user.id,
            email: user.email,
            provider: this.provider
          });
        }
      } catch (logError) {
        console.warn('Warning: Could not log system error:', logError.message);
      }
      
      return false;
    }
  }

  /**
   * Generate HTML template for welcome email
   */
  generateWelcomeEmailTemplate(user) {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome!</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
        .feature-list { background: white; padding: 20px; border-radius: 5px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎉 Welcome to ${process.env.APP_NAME || 'Secure Node.js Backend'}!</h1>
        <p>Your email has been successfully verified!</p>
    </div>
    
    <div class="content">
        <h2>Hello ${user.username}!</h2>
        
        <p>Congratulations! Your email address has been successfully verified and your account is now active. You can now enjoy full access to all our features.</p>
        
        <div class="feature-list">
            <h3>🚀 What you can do now:</h3>
            <ul>
                <li>✅ Login to your account</li>
                <li>🛍️ Browse our products and categories</li>
                <li>👤 Update your profile information</li>
                <li>🔒 Enjoy secure access to all features</li>
            </ul>
        </div>
        
        <p>If you have any questions or need assistance, our support team is here to help.</p>
        
        <p>Thank you for joining us!</p>
        
        <p>Best regards,<br>
        <strong>${process.env.APP_NAME || 'Secure Node.js Backend'} Team</strong></p>
    </div>
    
    <div class="footer">
        <p>&copy; ${new Date().getFullYear()} ${process.env.APP_NAME || 'Secure Node.js Backend'}. All rights reserved.</p>
    </div>
</body>
</html>`;
  }

  /**
   * Generate plain text template for welcome email
   */
  generateWelcomeEmailText(user) {
    return `
Welcome to ${process.env.APP_NAME || 'Secure Node.js Backend'}!

Hello ${user.username}!

Congratulations! Your email address has been successfully verified and your account is now active. You can now enjoy full access to all our features.

What you can do now:
- Login to your account
- Browse our products and categories
- Update your profile information
- Enjoy secure access to all features

If you have any questions or need assistance, our support team is here to help.

Thank you for joining us!

Best regards,
${process.env.APP_NAME || 'Secure Node.js Backend'} Team

© ${new Date().getFullYear()} ${process.env.APP_NAME || 'Secure Node.js Backend'}. All rights reserved.
`;
  }
}

module.exports = new EmailService();


================================================
FILE: src/services/googleAuthService.js
================================================
[Empty file]


================================================
FILE: src/services/leaderboardService.js
================================================
const User = require('../models/User');
const PointTransaction = require('../models/PointTransaction');
const { sequelize } = require('../config/database');
const { Op } = require('sequelize');

class LeaderboardService {
  /**
   * Get daily leaderboard (top 10 users based on points earned on specific date)
   * @param {Date} date - Target date
   * @returns {Array} Leaderboard data
   */
  async getDailyLeaderboard(date = new Date()) {
    try {
      const startOfDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

      const query = `
        SELECT 
          u.id,
          u.username,
          u.email,
          u.profile_picture,
          COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) as daily_points,
          RANK() OVER (ORDER BY COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) DESC) as rank_position
        FROM users u
        LEFT JOIN point_transactions pt ON u.id = pt.user_id 
          AND pt.status = 'completed'
          AND pt.created_at >= :startOfDay 
          AND pt.created_at < :endOfDay
        WHERE u.is_active = 1 
          AND u.is_verified = 1
        GROUP BY u.id, u.username, u.email, u.profile_picture
        HAVING daily_points > 0
        ORDER BY daily_points DESC, u.username ASC
        LIMIT 10
      `;

      const results = await sequelize.query(query, {
        replacements: { 
          startOfDay: startOfDay, 
          endOfDay: endOfDay 
        },
        type: sequelize.QueryTypes.SELECT
      });

      return {
        type: 'daily',
        date: date.toISOString().split('T')[0],
        total_participants: results.length,
        leaderboard: results.map((user, index) => ({
          rank: index + 1,
          user: {
            id: user.id,
            username: user.username,
            email: user.email,
            profile_picture: user.profile_picture
          },
          points: parseInt(user.daily_points),
          badge: this.getBadge(index + 1)
        }))
      };
    } catch (error) {
      console.error('Error getting daily leaderboard:', error);
      throw error;
    }
  }

  /**
   * Get monthly leaderboard (top 10 users based on total points earned in specific month)
   * @param {number} year - Target year
   * @param {number} month - Target month (1-12)
   * @returns {Array} Leaderboard data
   */
  async getMonthlyLeaderboard(year = new Date().getFullYear(), month = new Date().getMonth() + 1) {
    try {
      const startOfMonth = new Date(year, month - 1, 1);
      const endOfMonth = new Date(year, month, 1);

      const query = `
        SELECT 
          u.id,
          u.username,
          u.email,
          u.profile_picture,
          COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) as monthly_points,
          RANK() OVER (ORDER BY COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) DESC) as rank_position
        FROM users u
        LEFT JOIN point_transactions pt ON u.id = pt.user_id 
          AND pt.status = 'completed'
          AND pt.created_at >= :startOfMonth 
          AND pt.created_at < :endOfMonth
        WHERE u.is_active = 1 
          AND u.is_verified = 1
        GROUP BY u.id, u.username, u.email, u.profile_picture
        HAVING monthly_points > 0
        ORDER BY monthly_points DESC, u.username ASC
        LIMIT 10
      `;

      const results = await sequelize.query(query, {
        replacements: { 
          startOfMonth: startOfMonth, 
          endOfMonth: endOfMonth 
        },
        type: sequelize.QueryTypes.SELECT
      });

      return {
        type: 'monthly',
        year: year,
        month: month,
        month_name: new Date(year, month - 1).toLocaleString('en-US', { month: 'long' }),
        total_participants: results.length,
        leaderboard: results.map((user, index) => ({
          rank: index + 1,
          user: {
            id: user.id,
            username: user.username,
            email: user.email,
            profile_picture: user.profile_picture
          },
          points: parseInt(user.monthly_points),
          badge: this.getBadge(index + 1)
        }))
      };
    } catch (error) {
      console.error('Error getting monthly leaderboard:', error);
      throw error;
    }
  }

  /**
   * Get all-time leaderboard (top 10 users based on current_points)
   * @returns {Array} Leaderboard data
   */
  async getAllTimeLeaderboard() {
    try {
      const users = await User.findAll({
        where: {
          isActive: true,
          isVerified: true,
          currentPoints: {
            [Op.gt]: 0
          }
        },
        attributes: ['id', 'username', 'email', 'profile_picture', 'current_points'],
        order: [
          ['current_points', 'DESC'],
          ['username', 'ASC']
        ],
        limit: 10
      });

      return {
        type: 'all_time',
        total_participants: users.length,
        leaderboard: users.map((user, index) => ({
          rank: index + 1,
          user: {
            id: user.id,
            username: user.username,
            email: user.email,
            profile_picture: user.profile_picture
          },
          points: user.current_points,
          badge: this.getBadge(index + 1)
        }))
      };
    } catch (error) {
      console.error('Error getting all-time leaderboard:', error);
      throw error;
    }
  }

  /**
   * Get user's daily ranking
   * @param {number} userId - User ID
   * @param {Date} date - Target date
   * @returns {Object} User ranking data
   */
  async getUserDailyRanking(userId, date = new Date()) {
    try {
      const startOfDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

      const query = `
        SELECT 
          u.id,
          u.username,
          u.email,
          u.profile_picture,
          COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) as daily_points,
          RANK() OVER (ORDER BY COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) DESC) as rank_position
        FROM users u
        LEFT JOIN point_transactions pt ON u.id = pt.user_id 
          AND pt.status = 'completed'
          AND pt.created_at >= :startOfDay 
          AND pt.created_at < :endOfDay
        WHERE u.is_active = 1 AND u.is_verified = 1
        GROUP BY u.id, u.username, u.email, u.profile_picture
        HAVING u.id = :userId
      `;

      const [userRank] = await sequelize.query(query, {
        replacements: { 
          userId: userId,
          startOfDay: startOfDay, 
          endOfDay: endOfDay 
        },
        type: sequelize.QueryTypes.SELECT
      });

      // Get total participants count
      const totalQuery = `
        SELECT COUNT(DISTINCT u.id) as total_participants
        FROM users u
        LEFT JOIN point_transactions pt ON u.id = pt.user_id 
          AND pt.status = 'completed'
          AND pt.created_at >= :startOfDay 
          AND pt.created_at < :endOfDay
        WHERE u.is_active = 1 AND u.is_verified = 1
        GROUP BY u.id
        HAVING COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) > 0
      `;

      const totalResult = await sequelize.query(totalQuery, {
        replacements: { 
          startOfDay: startOfDay, 
          endOfDay: endOfDay 
        },
        type: sequelize.QueryTypes.SELECT
      });

      if (!userRank) {
        return {
          type: 'daily',
          date: date.toISOString().split('T')[0],
          user_ranking: null,
          message: 'No points earned on this date'
        };
      }

      return {
        type: 'daily',
        date: date.toISOString().split('T')[0],
        user_ranking: {
          rank: parseInt(userRank.rank_position),
          user: {
            id: userRank.id,
            username: userRank.username,
            email: userRank.email,
            profile_picture: userRank.profile_picture
          },
          points: parseInt(userRank.daily_points),
          total_participants: totalResult.length,
          badge: this.getBadge(parseInt(userRank.rank_position))
        }
      };
    } catch (error) {
      console.error('Error getting user daily ranking:', error);
      throw error;
    }
  }

  /**
   * Get user's monthly ranking
   * @param {number} userId - User ID
   * @param {number} year - Target year
   * @param {number} month - Target month
   * @returns {Object} User ranking data
   */
  async getUserMonthlyRanking(userId, year = new Date().getFullYear(), month = new Date().getMonth() + 1) {
    try {
      const startOfMonth = new Date(year, month - 1, 1);
      const endOfMonth = new Date(year, month, 1);

      const query = `
        SELECT 
          u.id,
          u.username,
          u.email,
          u.profile_picture,
          COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) as monthly_points,
          RANK() OVER (ORDER BY COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) DESC) as rank_position
        FROM users u
        LEFT JOIN point_transactions pt ON u.id = pt.user_id 
          AND pt.status = 'completed'
          AND pt.created_at >= :startOfMonth 
          AND pt.created_at < :endOfMonth
        WHERE u.is_active = 1 AND u.is_verified = 1
        GROUP BY u.id, u.username, u.email, u.profile_picture
        HAVING u.id = :userId
      `;

      const [userRank] = await sequelize.query(query, {
        replacements: { 
          userId: userId,
          startOfMonth: startOfMonth, 
          endOfMonth: endOfMonth 
        },
        type: sequelize.QueryTypes.SELECT
      });

      // Get total participants count
      const totalQuery = `
        SELECT COUNT(DISTINCT u.id) as total_participants
        FROM users u
        LEFT JOIN point_transactions pt ON u.id = pt.user_id 
          AND pt.status = 'completed'
          AND pt.created_at >= :startOfMonth 
          AND pt.created_at < :endOfMonth
        WHERE u.is_active = 1 AND u.is_verified = 1
        GROUP BY u.id
        HAVING COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) > 0
      `;

      const totalResult = await sequelize.query(totalQuery, {
        replacements: { 
          startOfMonth: startOfMonth, 
          endOfMonth: endOfMonth 
        },
        type: sequelize.QueryTypes.SELECT
      });

      if (!userRank) {
        return {
          type: 'monthly',
          year: year,
          month: month,
          month_name: new Date(year, month - 1).toLocaleString('en-US', { month: 'long' }),
          user_ranking: null,
          message: 'No points earned in this month'
        };
      }

      return {
        type: 'monthly',
        year: year,
        month: month,
        month_name: new Date(year, month - 1).toLocaleString('en-US', { month: 'long' }),
        user_ranking: {
          rank: parseInt(userRank.rank_position),
          user: {
            id: userRank.id,
            username: userRank.username,
            email: userRank.email,
            profile_picture: userRank.profile_picture
          },
          points: parseInt(userRank.monthly_points),
          total_participants: totalResult.length,
          badge: this.getBadge(parseInt(userRank.rank_position))
        }
      };
    } catch (error) {
      console.error('Error getting user monthly ranking:', error);
      throw error;
    }
  }

  /**
   * Get user's all-time ranking
   * @param {number} userId - User ID
   * @returns {Object} User ranking data
   */
  async getUserAllTimeRanking(userId) {
    try {
      const query = `
        SELECT 
          u.id,
          u.username,
          u.email,
          u.profile_picture,
          u.current_points,
          RANK() OVER (ORDER BY u.current_points DESC) as rank_position
        FROM users u
        WHERE u.is_active = 1 AND u.is_verified = 1 AND u.id = :userId
      `;

      const [userRank] = await sequelize.query(query, {
        replacements: { userId: userId },
        type: sequelize.QueryTypes.SELECT
      });

      // Get total participants count
      const totalUsers = await User.count({
        where: {
          isActive: true,
          isVerified: true,
          currentPoints: {
            [Op.gt]: 0
          }
        }
      });

      if (!userRank) {
        return {
          type: 'all_time',
          user_ranking: null,
          message: 'User not found or no points earned'
        };
      }

      return {
        type: 'all_time',
        user_ranking: {
          rank: parseInt(userRank.rank_position),
          user: {
            id: userRank.id,
            username: userRank.username,
            email: userRank.email,
            profile_picture: userRank.profile_picture
          },
          points: userRank.current_points,
          total_participants: totalUsers,
          badge: this.getBadge(parseInt(userRank.rank_position))
        }
      };
    } catch (error) {
      console.error('Error getting user all-time ranking:', error);
      throw error;
    }
  }

  /**
   * Get comprehensive leaderboard data (all types + user rankings)
   * @param {number} userId - User ID
   * @param {Date} date - Target date for daily
   * @param {number} year - Target year for monthly
   * @param {number} month - Target month for monthly
   * @returns {Object} Comprehensive data
   */
  async getComprehensiveLeaderboard(userId, date = new Date(), year = new Date().getFullYear(), month = new Date().getMonth() + 1) {
    try {
      const [
        dailyLeaderboard,
        monthlyLeaderboard,
        allTimeLeaderboard,
        userDailyRank,
        userMonthlyRank,
        userAllTimeRank
      ] = await Promise.all([
        this.getDailyLeaderboard(date),
        this.getMonthlyLeaderboard(year, month),
        this.getAllTimeLeaderboard(),
        this.getUserDailyRanking(userId, date),
        this.getUserMonthlyRanking(userId, year, month),
        this.getUserAllTimeRanking(userId)
      ]);

      return {
        leaderboards: {
          daily: dailyLeaderboard,
          monthly: monthlyLeaderboard,
          all_time: allTimeLeaderboard
        },
        user_rankings: {
          daily: userDailyRank.user_ranking,
          monthly: userMonthlyRank.user_ranking,
          all_time: userAllTimeRank.user_ranking
        },
        metadata: {
          generated_at: new Date().toISOString(),
          target_date: date.toISOString().split('T')[0],
          target_month: `${year}-${month.toString().padStart(2, '0')}`
        }
      };
    } catch (error) {
      console.error('Error getting comprehensive leaderboard:', error);
      throw error;
    }
  }

  /**
   * Get leaderboard statistics (Admin only)
   * @returns {Object} Statistics data
   */
  async getLeaderboardStatistics() {
    try {
      const today = new Date();
      const currentMonth = today.getMonth() + 1;
      const currentYear = today.getFullYear();

      const [
        totalActiveUsers,
        usersWithPoints,
        dailyParticipants,
        monthlyParticipants,
        topDailyPoints,
        topMonthlyPoints,
        topAllTimePoints
      ] = await Promise.all([
        User.count({ where: { isActive: true, isVerified: true } }),
        User.count({ where: { isActive: true, isVerified: true, currentPoints: { [Op.gt]: 0 } } }),
        this.getDailyParticipantsCount(today),
        this.getMonthlyParticipantsCount(currentYear, currentMonth),
        this.getTopPoints('daily', today),
        this.getTopPoints('monthly', new Date(currentYear, currentMonth - 1)),
        this.getTopPoints('all_time')
      ]);

      return {
        overview: {
          total_active_users: totalActiveUsers,
          users_with_points: usersWithPoints,
          participation_rate: totalActiveUsers > 0 ? ((usersWithPoints / totalActiveUsers) * 100).toFixed(2) : 0
        },
        current_period: {
          daily_participants: dailyParticipants,
          monthly_participants: monthlyParticipants,
          daily_top_score: topDailyPoints,
          monthly_top_score: topMonthlyPoints,
          all_time_top_score: topAllTimePoints
        },
        generated_at: new Date().toISOString()
      };
    } catch (error) {
      console.error('Error getting leaderboard statistics:', error);
      throw error;
    }
  }

  /**
   * Helper method to get badge based on rank
   * @param {number} rank - User rank
   * @returns {string} Badge name
   */
  getBadge(rank) {
    switch (rank) {
      case 1:
        return '🥇 Gold';
      case 2:
        return '🥈 Silver';
      case 3:
        return '🥉 Bronze';
      case 4:
      case 5:
        return '🏆 Top 5';
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
        return '⭐ Top 10';
      default:
        return '🎯 Participant';
    }
  }

  /**
   * Helper method to get daily participants count
   */
  async getDailyParticipantsCount(date) {
    const startOfDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

    const result = await sequelize.query(`
      SELECT COUNT(DISTINCT u.id) as count
      FROM users u
      INNER JOIN point_transactions pt ON u.id = pt.user_id 
      WHERE pt.status = 'completed'
        AND pt.transaction_type = 'credit'
        AND pt.created_at >= :startOfDay 
        AND pt.created_at < :endOfDay
        AND u.is_active = 1 
        AND u.is_verified = 1
    `, {
      replacements: { startOfDay, endOfDay },
      type: sequelize.QueryTypes.SELECT
    });

    return result[0]?.count || 0;
  }

  /**
   * Helper method to get monthly participants count
   */
  async getMonthlyParticipantsCount(year, month) {
    const startOfMonth = new Date(year, month - 1, 1);
    const endOfMonth = new Date(year, month, 1);

    const result = await sequelize.query(`
      SELECT COUNT(DISTINCT u.id) as count
      FROM users u
      INNER JOIN point_transactions pt ON u.id = pt.user_id 
      WHERE pt.status = 'completed'
        AND pt.transaction_type = 'credit'
        AND pt.created_at >= :startOfMonth 
        AND pt.created_at < :endOfMonth
        AND u.is_active = 1 
        AND u.is_verified = 1
    `, {
      replacements: { startOfMonth, endOfMonth },
      type: sequelize.QueryTypes.SELECT
    });

    return result[0]?.count || 0;
  }

  /**
   * Helper method to get top points for different periods
   */
  async getTopPoints(type, date = null) {
    try {
      let query;
      let replacements = {};

      switch (type) {
        case 'daily':
          const startOfDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
          const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);
          query = `
            SELECT COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) as top_points
            FROM users u
            LEFT JOIN point_transactions pt ON u.id = pt.user_id 
              AND pt.status = 'completed'
              AND pt.created_at >= :startOfDay 
              AND pt.created_at < :endOfDay
            WHERE u.is_active = 1 AND u.is_verified = 1
            GROUP BY u.id
            ORDER BY top_points DESC
            LIMIT 1
          `;
          replacements = { startOfDay, endOfDay };
          break;

        case 'monthly':
          const startOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
          const endOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 1);
          query = `
            SELECT COALESCE(SUM(CASE WHEN pt.transaction_type = 'credit' THEN pt.amount ELSE 0 END), 0) as top_points
            FROM users u
            LEFT JOIN point_transactions pt ON u.id = pt.user_id 
              AND pt.status = 'completed'
              AND pt.created_at >= :startOfMonth 
              AND pt.created_at < :endOfMonth
            WHERE u.is_active = 1 AND u.is_verified = 1
            GROUP BY u.id
            ORDER BY top_points DESC
            LIMIT 1
          `;
          replacements = { startOfMonth, endOfMonth };
          break;

        case 'all_time':
        default:
          query = `
            SELECT current_points as top_points
            FROM users
            WHERE is_active = 1 AND is_verified = 1
            ORDER BY current_points DESC
            LIMIT 1
          `;
          break;
      }

      const result = await sequelize.query(query, {
        replacements,
        type: sequelize.QueryTypes.SELECT
      });

      return result[0]?.top_points || 0;
    } catch (error) {
      console.error('Error getting top points:', error);
      return 0;
    }
  }
}

module.exports = new LeaderboardService();


================================================
FILE: src/services/pointService.js
================================================
const User = require('../models/User');
const PointActivity = require('../models/PointActivity');
const PointTransaction = require('../models/PointTransaction');
const { sequelize } = require('../config/database');
const { logSecurityEvent } = require('../utils/logger');

class PointService {
  /**
   * Award points to user for specific activity
   * @param {number} userId - User ID
   * @param {string} activityCode - Activity code (e.g., 'EMAIL_VERIFY', 'DAILY_LOGIN')
   * @param {object} options - Additional options
   * @returns {object} Transaction result
   */
  async awardPoints(userId, activityCode, options = {}) {
    const transaction = await sequelize.transaction();

    try {
      console.log(`🎯 Attempting to award points for activity: ${activityCode} to user: ${userId}`);

      // Find the activity
      const activity = await PointActivity.findByCode(activityCode);
      
      if (!activity) {
        console.log(`❌ Activity not found: ${activityCode}`);
        await transaction.rollback();
        return {
          success: false,
          message: `Activity ${activityCode} not found`,
          awarded: false
        };
      }

      console.log(`📋 Activity found:`, {
        code: activity.activityCode,
        name: activity.activityName,
        points: activity.pointsReward,
        isActive: activity.isActive
      });

      // Check if activity is valid and active
      if (!activity.isValidNow()) {
        console.log(`❌ Activity is not currently active: ${activityCode}`);
        await transaction.rollback();
        return {
          success: false,
          message: `Activity ${activityCode} is not currently active`,
          awarded: false
        };
      }

      // Check if user can earn points for this activity
      const canEarnResult = await activity.canUserEarn(userId);
      
      if (!canEarnResult.canEarn) {
        console.log(`❌ User cannot earn points:`, canEarnResult.reason);
        await transaction.rollback();
        return {
          success: false,
          message: canEarnResult.reason,
          awarded: false
        };
      }

      // Get user
      const user = await User.findByPk(userId, { transaction });
      
      if (!user) {
        console.log(`❌ User not found: ${userId}`);
        await transaction.rollback();
        return {
          success: false,
          message: 'User not found',
          awarded: false
        };
      }

      // Check if user can earn points (active and verified)
      if (!user.canEarnPoints()) {
        console.log(`❌ User cannot earn points - not active or verified`);
        await transaction.rollback();
        return {
          success: false,
          message: 'User account must be active and verified to earn points',
          awarded: false
        };
      }

      const pointsToAward = activity.pointsReward;
      const balanceBefore = user.currentPoints;

      console.log(`💰 Awarding ${pointsToAward} points to user ${userId}`);
      console.log(`💰 Balance before: ${balanceBefore}`);

      // Create point transaction
      const pointTransaction = await PointTransaction.create({
        userId: userId,
        transactionType: 'credit',
        amount: pointsToAward,
        balanceBefore: balanceBefore,
        activityType: activityCode,
        activityDescription: activity.activityName,
        referenceId: options.referenceId || null,
        referenceType: options.referenceType || 'activity',
        processedBy: options.processedBy || null,
        status: 'completed',
        metadata: {
          activityId: activity.id,
          activityName: activity.activityName,
          ...options.metadata
        }
      }, { transaction });

      // Update user's current points
      await user.addPoints(pointsToAward, transaction);

      await transaction.commit();

      console.log(`✅ Points awarded successfully!`);
      console.log(`✅ Transaction ID: ${pointTransaction.id}`);
      console.log(`✅ New balance: ${balanceBefore + pointsToAward}`);

      // Log the point award
      logSecurityEvent('points_awarded', {
        userId: userId,
        activityCode: activityCode,
        pointsAwarded: pointsToAward,
        balanceBefore: balanceBefore,
        balanceAfter: balanceBefore + pointsToAward,
        transactionId: pointTransaction.id
      });

      return {
        success: true,
        message: `Congratulations! You earned ${pointsToAward} points for ${activity.activityName}`,
        awarded: true,
        points: pointsToAward,
        newBalance: balanceBefore + pointsToAward,
        transaction: {
          id: pointTransaction.id,
          activity: activity.activityName,
          amount: pointsToAward
        }
      };

    } catch (error) {
      await transaction.rollback();
      console.error(`❌ Error awarding points:`, error);
      
      logSecurityEvent('points_award_error', {
        userId: userId,
        activityCode: activityCode,
        error: error.message,
        stack: error.stack
      });

      return {
        success: false,
        message: 'Failed to award points',
        awarded: false,
        error: error.message
      };
    }
  }

  /**
   * Award points for email verification
   * @param {number} userId - User ID
   * @returns {object} Result
   */
  async awardEmailVerificationPoints(userId) {
    return this.awardPoints(userId, 'EMAIL_VERIFY', {
      referenceType: 'email_verification',
      metadata: {
        event: 'email_verified',
        timestamp: new Date().toISOString()
      }
    });
  }

  /**
   * Award points for profile completion
   * @param {number} userId - User ID
   * @returns {object} Result
   */
  async awardProfileCompletionPoints(userId) {
    return this.awardPoints(userId, 'PROFILE_COMPLETE', {
      referenceType: 'profile_completion',
      metadata: {
        event: 'profile_completed',
        timestamp: new Date().toISOString()
      }
    });
  }

  /**
   * Award points for daily login
   * @param {number} userId - User ID
   * @returns {object} Result
   */
  async awardDailyLoginPoints(userId) {
    return this.awardPoints(userId, 'DAILY_LOGIN', {
      referenceType: 'daily_login',
      metadata: {
        event: 'daily_login',
        timestamp: new Date().toISOString(),
        loginDate: new Date().toISOString().split('T')[0]
      }
    });
  }

  /**
   * Award points for sharing product
   * @param {number} userId - User ID
   * @param {number} productId - Product ID
   * @returns {object} Result
   */
  async awardProductSharePoints(userId, productId) {
    return this.awardPoints(userId, 'PRODUCT_SHARE', {
      referenceId: productId.toString(),
      referenceType: 'product_share',
      metadata: {
        event: 'product_shared',
        productId: productId,
        timestamp: new Date().toISOString()
      }
    });
  }

  /**
   * Award points for sharing campaign
   * @param {number} userId - User ID
   * @param {number} campaignId - Campaign ID
   * @returns {object} Result
   */
  async awardCampaignSharePoints(userId, campaignId) {
    return this.awardPoints(userId, 'CAMPAIGN_SHARE', {
      referenceId: campaignId.toString(),
      referenceType: 'campaign_share',
      metadata: {
        event: 'campaign_shared',
        campaignId: campaignId,
        timestamp: new Date().toISOString()
      }
    });
  }

  /**
   * Get user's point summary
   * @param {number} userId - User ID
   * @returns {object} Point summary
   */
  async getUserPointSummary(userId) {
    try {
      const user = await User.findByPk(userId);
      
      if (!user) {
        throw new Error('User not found');
      }

      // Get transaction summary
      const transactions = await PointTransaction.findAll({
        where: { userId },
        attributes: [
          'transactionType',
          [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
          [sequelize.fn('SUM', sequelize.col('amount')), 'total']
        ],
        group: ['transactionType']
      });

      const summary = {
        currentBalance: user.currentPoints,
        totalEarned: 0,
        totalSpent: 0,
        transactionCounts: {
          credit: 0,
          debit: 0
        }
      };

      transactions.forEach(tx => {
        const count = parseInt(tx.dataValues.count);
        const total = parseInt(tx.dataValues.total) || 0;
        
        if (tx.transactionType === 'credit') {
          summary.totalEarned = total;
          summary.transactionCounts.credit = count;
        } else {
          summary.totalSpent = total;
          summary.transactionCounts.debit = count;
        }
      });

      return summary;
    } catch (error) {
      console.error('Error getting user point summary:', error);
      throw error;
    }
  }

  /**
   * Check if user has completed specific activity today
   * @param {number} userId - User ID
   * @param {string} activityCode - Activity code
   * @returns {boolean} Has completed today
   */
  async hasCompletedActivityToday(userId, activityCode) {
    try {
      const today = new Date();
      const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

      const count = await PointTransaction.count({
        where: {
          userId,
          activityType: activityCode,
          status: 'completed',
          created_at: {
            [sequelize.Op.gte]: startOfDay,
            [sequelize.Op.lt]: endOfDay
          }
        }
      });

      return count > 0;
    } catch (error) {
      console.error('Error checking daily activity completion:', error);
      return false;
    }
  }

  /**
   * Get available activities for user
   * @param {number} userId - User ID
   * @returns {array} Available activities
   */
  async getAvailableActivitiesForUser(userId) {
    try {
      const activities = await PointActivity.findActiveActivities();
      const availableActivities = [];

      for (const activity of activities) {
        const canEarn = await activity.canUserEarn(userId);
        availableActivities.push({
          id: activity.id,
          code: activity.activityCode,
          name: activity.activityName,
          description: activity.description,
          points: activity.pointsReward,
          dailyLimit: activity.dailyLimit,
          totalLimit: activity.totalLimit,
          canEarn: canEarn.canEarn,
          reason: canEarn.reason
        });
      }

      return availableActivities;
    } catch (error) {
      console.error('Error getting available activities:', error);
      throw error;
    }
  }
}

module.exports = new PointService();


================================================
FILE: src/services/productService.js
================================================
const Product = require('../models/Product');
const Category = require('../models/Category');
const ProductImage = require('../models/ProductImage');
const { logUserAction } = require('../utils/logger');
const { deleteFile } = require('../middleware/upload');

class ProductService {
  /**
   * Get all products with pagination and filtering
   * @param {object} options - Query options
   * @returns {object} Products with pagination info
   */
  async getAllProducts(options = {}) {
    const {
      page = 1,
      limit = 10,
      search = '',
      categoryId,
      minPrice,
      maxPrice,
      minPoints,
      maxPoints,
      isActive,
      isFeatured,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = options;

    const offset = (page - 1) * limit;
    const whereClause = {};

    // Add search filter
    if (search) {
      whereClause[Product.sequelize.Sequelize.Op.or] = [
        { title: { [Product.sequelize.Sequelize.Op.like]: `%${search}%` } },
        { description: { [Product.sequelize.Sequelize.Op.like]: `%${search}%` } }
      ];
    }

    // Add category filter
    if (categoryId) {
      whereClause.categoryId = categoryId;
    }

    // Add price range filter
    if (minPrice !== undefined || maxPrice !== undefined) {
      whereClause.price = {};
      if (minPrice !== undefined) whereClause.price[Product.sequelize.Sequelize.Op.gte] = minPrice;
      if (maxPrice !== undefined) whereClause.price[Product.sequelize.Sequelize.Op.lte] = maxPrice;
    }

    // Add points range filter
    if (minPoints !== undefined || maxPoints !== undefined) {
      whereClause.points = {};
      if (minPoints !== undefined) whereClause.points[Product.sequelize.Sequelize.Op.gte] = minPoints;
      if (maxPoints !== undefined) whereClause.points[Product.sequelize.Sequelize.Op.lte] = maxPoints;
    }

    // Add active filter
    if (isActive !== undefined) {
      whereClause.isActive = isActive;
    }

    // Add featured filter
    if (isFeatured !== undefined) {
      whereClause.isFeatured = isFeatured;
    }

    // Map sortBy to actual database column names
    const sortByMapping = {
      'createdAt': 'created_at',
      'updatedAt': 'updated_at',
      'viewCount': 'view_count',
      'stockQuantity': 'stock_quantity',
      'sortOrder': 'sort_order',
      'categoryId': 'category_id',
      'isActive': 'is_active',
      'isFeatured': 'is_featured',
      'metaTitle': 'meta_title',
      'metaDescription': 'meta_description',
      'createdBy': 'created_by',
      'updatedBy': 'updated_by'
    };

    const actualSortBy = sortByMapping[sortBy] || sortBy;

    const { count, rows } = await Product.findAndCountAll({
      where: whereClause,
      include: [{
        model: Category,
        as: 'category',
        attributes: ['id', 'name', 'slug']
      }],
      order: [[actualSortBy, sortOrder.toUpperCase()]],
      limit: parseInt(limit),
      offset: parseInt(offset)
    });

    return {
      products: rows,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(count / limit),
        totalItems: count,
        itemsPerPage: parseInt(limit)
      }
    };
  }

  /**
   * Get active products for public view
   * @param {object} options - Query options
   * @returns {object} Active products with pagination
   */
  async getActiveProducts(options = {}) {
    return this.getAllProducts({
      ...options,
      isActive: true
    });
  }

  /**
   * Get featured products
   * @param {number} limit - Number of products to return
   * @returns {Array} Featured products
   */
  async getFeaturedProducts(limit = 10) {
    return Product.findFeaturedProducts(limit);
  }

  /**
   * Get product by ID
   * @param {number} productId - Product ID
   * @param {boolean} includeImages - Include product images
   * @returns {object} Product
   */
  async getProductById(productId, includeImages = false) {
    const includeOptions = [{
      model: Category,
      as: 'category',
      attributes: ['id', 'name', 'slug']
    }];

    if (includeImages) {
      includeOptions.push({
        model: ProductImage,
        as: 'images',
        order: [['isPrimary', 'DESC'], ['sortOrder', 'ASC']]
      });
    }

    const product = await Product.findByPk(productId, {
      include: includeOptions
    });

    if (!product) {
      throw new Error('Product not found');
    }

    return product;
  }

  /**
   * Get product by slug
   * @param {string} slug - Product slug
   * @param {boolean} incrementView - Increment view count
   * @returns {object} Product
   */
  async getProductBySlug(slug, incrementView = false) {
    const product = await Product.findBySlug(slug);

    if (!product) {
      throw new Error('Product not found');
    }

    // Increment view count if requested
    if (incrementView) {
      await product.incrementViewCount();
    }

    return product;
  }

  /**
   * Search products
   * @param {string} query - Search query
   * @param {object} options - Additional options
   * @returns {object} Search results with pagination
   */
  async searchProducts(query, options = {}) {
    return this.getAllProducts({
      ...options,
      search: query,
      isActive: true
    });
  }

  /**
   * Get products by category
   * @param {number} categoryId - Category ID
   * @param {object} options - Query options
   * @returns {object} Products in category
   */
  async getProductsByCategory(categoryId, options = {}) {
    return this.getAllProducts({
      ...options,
      categoryId,
      isActive: true
    });
  }

  /**
   * Create new product with optional image
   * @param {object} productData - Product data
   * @param {number} userId - User ID who creates the product
   * @param {string} imageFilename - Optional image filename
   * @returns {object} Created product
   */
  async createProduct(productData, userId, imageFilename = null) {
    const {
      title,
      slug,
      description,
      points,
      price,
      url,
      categoryId,
      isActive,
      isFeatured,
      stockQuantity,
      sortOrder,
      metaTitle,
      metaDescription
    } = productData;

    // Verify category exists
    const category = await Category.findByPk(categoryId);
    if (!category) {
      throw new Error('Category not found');
    }

    // Generate slug if not provided
    const finalSlug = slug || title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim('-');

    // Check if product with same slug exists
    const existingProduct = await Product.findOne({
      where: { slug: finalSlug }
    });

    if (existingProduct) {
      throw new Error('Product with this slug already exists');
    }

    const product = await Product.create({
      title,
      slug: finalSlug,
      description,
      points: parseInt(points),
      price: parseFloat(price),
      url,
      image: imageFilename, // Save image filename if provided
      categoryId: parseInt(categoryId),
      isActive: isActive !== undefined ? isActive : true,
      isFeatured: isFeatured || false,
      stockQuantity: stockQuantity || 0,
      sortOrder: sortOrder || 0,
      metaTitle,
      metaDescription,
      createdBy: userId
    });

    logUserAction('product_created', userId, {
      productId: product.id,
      productTitle: product.title,
      categoryId: product.categoryId,
      hasImage: !!imageFilename
    });

    return product;
  }

  /**
 * Update product
 * @param {number} productId - Product ID
 * @param {object} updateData - Update data
 * @param {number} userId - User ID who updates the product
 * @param {string} imageFilename - Optional new image filename
 * @returns {object} Updated product
 */
async updateProduct(productId, updateData, userId, imageFilename = null) {
  const product = await Product.findByPk(productId);

  if (!product) {
    throw new Error('Product not found');
  }

  // Verify category exists if categoryId is being updated
  if (updateData.categoryId) {
    const category = await Category.findByPk(updateData.categoryId);
    if (!category) {
      throw new Error('Category not found');
    }
  }

  // Check for duplicate slug if it's being updated
  if (updateData.slug && updateData.slug !== product.slug) {
    const existingProduct = await Product.findOne({
      where: {
        slug: updateData.slug,
        id: { [Product.sequelize.Sequelize.Op.ne]: productId }
      }
    });

    if (existingProduct) {
      throw new Error('Product with this slug already exists');
    }
  }

  // Convert numeric fields
  if (updateData.points) updateData.points = parseInt(updateData.points);
  if (updateData.price) updateData.price = parseFloat(updateData.price);
  if (updateData.categoryId) updateData.categoryId = parseInt(updateData.categoryId);
  if (updateData.stockQuantity !== undefined) updateData.stockQuantity = parseInt(updateData.stockQuantity);
  if (updateData.sortOrder !== undefined) updateData.sortOrder = parseInt(updateData.sortOrder);

  // Handle image update
  if (imageFilename) {
    // Delete old image if exists
    if (product.image) {
      deleteFile(`uploads/products/${product.image}`);
    }
    updateData.image = imageFilename;
  }

  // Update product
  await product.update({
    ...updateData,
    updatedBy: userId
  });

  // Reload product to get updated data
  await product.reload();

  logUserAction('product_updated', userId, {
    productId: product.id,
    productTitle: product.title,
    changes: Object.keys(updateData),
    hasNewImage: !!imageFilename
  });

  return product;
}

  /**
   * Delete product
   * @param {number} productId - Product ID
   * @param {number} userId - User ID who deletes the product
   * @returns {boolean} Success status
   */
  async deleteProduct(productId, userId) {
    const product = await Product.findByPk(productId, {
      include: [{
        model: ProductImage,
        as: 'images'
      }]
    });

    if (!product) {
      throw new Error('Product not found');
    }

    // Delete product images from filesystem
    if (product.images && product.images.length > 0) {
      product.images.forEach(image => {
        deleteFile(`uploads/products/${image.imagePath}`);
      });
    }

    // Delete main product image if exists
    if (product.image) {
      deleteFile(`uploads/products/${product.image}`);
    }

    await product.destroy();

    logUserAction('product_deleted', userId, {
      productId,
      productTitle: product.title
    });

    return true;
  }

  /**
   * Upload product image
   * @param {number} productId - Product ID
   * @param {string} filename - Image filename
   * @param {number} userId - User ID
   * @returns {object} Updated product
   */
  async uploadProductImage(productId, filename, userId) {
    const product = await Product.findByPk(productId);

    if (!product) {
      throw new Error('Product not found');
    }

    // Delete old image if exists
    if (product.image) {
      deleteFile(`uploads/products/${product.image}`);
    }

    // Update product with new image
    await product.update({
      image: filename,
      updatedBy: userId
    });

    logUserAction('product_image_uploaded', userId, {
      productId,
      filename
    });

    return product;
  }

  /**
   * Add multiple images to product
   * @param {number} productId - Product ID
   * @param {Array} files - Array of uploaded files
   * @param {number} userId - User ID
   * @returns {Array} Created product images
   */
  async addProductImages(productId, files, userId) {
    const product = await Product.findByPk(productId);

    if (!product) {
      throw new Error('Product not found');
    }

    const productImages = [];

    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const productImage = await ProductImage.create({
        productId,
        imagePath: file.filename,
        altText: `${product.title} - Image ${i + 1}`,
        isPrimary: i === 0, // First image is primary by default
        sortOrder: i
      });

      productImages.push(productImage);
    }

    logUserAction('product_images_added', userId, {
      productId,
      imageCount: files.length
    });

    return productImages;
  }

  /**
   * Get product images
   * @param {number} productId - Product ID
   * @returns {Array} Product images
   */
  async getProductImages(productId) {
    return ProductImage.findByProduct(productId);
  }

  /**
   * Delete product image
   * @param {number} imageId - Image ID
   * @param {number} userId - User ID
   * @returns {boolean} Success status
   */
  async deleteProductImage(imageId, userId) {
    const image = await ProductImage.findByPk(imageId);

    if (!image) {
      throw new Error('Image not found');
    }

    // Delete image file
    deleteFile(`uploads/products/${image.imagePath}`);

    await image.destroy();

    logUserAction('product_image_deleted', userId, {
      imageId,
      productId: image.productId
    });

    return true;
  }

  /**
   * Set primary product image
   * @param {number} imageId - Image ID
   * @param {number} productId - Product ID
   * @param {number} userId - User ID
   * @returns {boolean} Success status
   */
  async setPrimaryImage(imageId, productId, userId) {
    await ProductImage.setPrimaryImage(imageId, productId);

    logUserAction('product_primary_image_set', userId, {
      imageId,
      productId
    });

    return true;
  }

  /**
   * Toggle product status
   * @param {number} productId - Product ID
   * @param {number} userId - User ID
   * @returns {object} Updated product
   */
  async toggleProductStatus(productId, userId) {
    const product = await Product.findByPk(productId);

    if (!product) {
      throw new Error('Product not found');
    }

    await product.update({
      isActive: !product.isActive,
      updatedBy: userId
    });

    logUserAction('product_status_toggled', userId, {
      productId,
      newStatus: product.isActive
    });

    return product;
  }

  /**
   * Toggle product featured status
   * @param {number} productId - Product ID
   * @param {number} userId - User ID
   * @returns {object} Updated product
   */
  async toggleProductFeatured(productId, userId) {
    const product = await Product.findByPk(productId);

    if (!product) {
      throw new Error('Product not found');
    }

    await product.update({
      isFeatured: !product.isFeatured,
      updatedBy: userId
    });

    logUserAction('product_featured_toggled', userId, {
      productId,
      newStatus: product.isFeatured
    });

    return product;
  }

  /**
   * Update product stock
   * @param {number} productId - Product ID
   * @param {number} quantity - Quantity change (positive or negative)
   * @param {number} userId - User ID
   * @returns {object} Updated product
   */
  async updateProductStock(productId, quantity, userId) {
    const product = await Product.findByPk(productId);

    if (!product) {
      throw new Error('Product not found');
    }

    await product.updateStock(quantity);

    logUserAction('product_stock_updated', userId, {
      productId,
      quantityChange: quantity,
      newStock: product.stockQuantity + quantity
    });

    return product;
  }

  /**
   * Get product statistics
   * @returns {object} Product statistics
   */
  async getProductStatistics() {
    const totalProducts = await Product.count();
    const activeProducts = await Product.count({ where: { isActive: true } });
    const featuredProducts = await Product.count({ where: { isFeatured: true } });
    const outOfStockProducts = await Product.count({ where: { stockQuantity: 0 } });

    // Top viewed products
    const topViewedProducts = await Product.findAll({
      where: { isActive: true },
      order: [['view_count', 'DESC']],
      limit: 5,
      attributes: ['id', 'title', 'viewCount'],
      include: [{
        model: Category,
        as: 'category',
        attributes: ['name']
      }]
    });

    // Products by category
    const productsByCategory = await Category.findAll({
      attributes: [
        'id',
        'name',
        [Product.sequelize.fn('COUNT', Product.sequelize.col('products.id')), 'productCount']
      ],
      include: [{
        model: Product,
        as: 'products',
        attributes: [],
        where: { isActive: true },
        required: false
      }],
      group: ['Category.id'],
      order: [[Product.sequelize.fn('COUNT', Product.sequelize.col('products.id')), 'DESC']]
    });

    return {
      totalProducts,
      activeProducts,
      featuredProducts,
      outOfStockProducts,
      topViewedProducts,
      productsByCategory
    };
  }
}

module.exports = new ProductService();


================================================
FILE: src/services/userService.js
================================================
[Empty file]


================================================
FILE: src/utils/email.js
================================================
/**
 * Email utility functions
 */

/**
 * Normalize email address properly without removing dots
 * @param {string} email - Email address
 * @returns {string} Normalized email
 */
const normalizeEmail = (email) => {
  if (!email || typeof email !== 'string') {
    return email;
  }

  // Trim whitespace and convert to lowercase
  const trimmed = email.trim().toLowerCase();
  
  // Basic email validation regex
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(trimmed)) {
    throw new Error('Invalid email format');
  }

  return trimmed;
};

/**
 * Validate email format
 * @param {string} email - Email address
 * @returns {boolean} Is valid email
 */
const isValidEmail = (email) => {
  if (!email || typeof email !== 'string') {
    return false;
  }

  // More comprehensive email validation regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  
  return emailRegex.test(email.trim());
};

/**
 * Extract email domain
 * @param {string} email - Email address
 * @returns {string} Domain part of email
 */
const getEmailDomain = (email) => {
  if (!email || typeof email !== 'string') {
    return '';
  }

  const parts = email.split('@');
  return parts.length === 2 ? parts[1].toLowerCase() : '';
};

/**
 * Check if email is from a common email provider
 * @param {string} email - Email address
 * @returns {boolean} Is from common provider
 */
const isCommonEmailProvider = (email) => {
  const domain = getEmailDomain(email);
  const commonProviders = [
    'gmail.com',
    'yahoo.com',
    'hotmail.com',
    'outlook.com',
    'icloud.com',
    'live.com',
    'msn.com',
    'aol.com',
    'mail.com',
    'protonmail.com'
  ];

  return commonProviders.includes(domain);
};

/**
 * Mask email for privacy (show first 2 chars and domain)
 * @param {string} email - Email address
 * @returns {string} Masked email
 */
const maskEmail = (email) => {
  if (!email || typeof email !== 'string') {
    return email;
  }

  const [localPart, domain] = email.split('@');
  if (!localPart || !domain) {
    return email;
  }

  if (localPart.length <= 2) {
    return `${localPart}***@${domain}`;
  }

  const masked = localPart.substring(0, 2) + '*'.repeat(Math.min(localPart.length - 2, 3));
  return `${masked}@${domain}`;
};

/**
 * Generate email verification subject
 * @param {string} appName - Application name
 * @returns {string} Email subject
 */
const getVerificationEmailSubject = (appName = 'App') => {
  return `Verify your email address - ${appName}`;
};

/**
 * Generate welcome email subject
 * @param {string} appName - Application name
 * @returns {string} Email subject
 */
const getWelcomeEmailSubject = (appName = 'App') => {
  return `Welcome to ${appName}!`;
};

module.exports = {
  normalizeEmail,
  isValidEmail,
  getEmailDomain,
  isCommonEmailProvider,
  maskEmail,
  getVerificationEmailSubject,
  getWelcomeEmailSubject
};


================================================
FILE: src/utils/encryption.js
================================================
[Empty file]


================================================
FILE: src/utils/logger.js
================================================
const winston = require('winston');
const path = require('path');

// Custom log format
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.json(),
  winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
    let log = `${timestamp} [${level.toUpperCase()}]: ${message}`;
    
    if (stack) {
      log += `\nStack: ${stack}`;
    }
    
    if (Object.keys(meta).length > 0) {
      log += `\nMeta: ${JSON.stringify(meta, null, 2)}`;
    }
    
    return log;
  })
);

// Console format for better readability in development
const consoleFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.colorize(),
  winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
    let log = `${timestamp} [${level}]: ${message}`;
    
    if (stack) {
      log += `\n${stack}`;
    }
    
    if (Object.keys(meta).length > 0 && process.env.NODE_ENV === 'development') {
      log += `\nMeta: ${JSON.stringify(meta, null, 2)}`;
    }
    
    return log;
  })
);

// Create logs directory if it doesn't exist
const fs = require('fs');
const logsDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Winston logger configuration
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  defaultMeta: { 
    service: 'secure-nodejs-backend',
    environment: process.env.NODE_ENV || 'development'
  },
  transports: [
    // ALWAYS include console transport to fix "no transports" warning
    new winston.transports.Console({
      format: consoleFormat,
      level: process.env.NODE_ENV === 'production' ? 'error' : 'debug'
    }),
    
    // Error log file
    new winston.transports.File({
      filename: path.join(logsDir, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      )
    }),
    
    // Combined log file
    new winston.transports.File({
      filename: path.join(logsDir, 'combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5,
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      )
    }),
    
    // Security log file
    new winston.transports.File({
      filename: path.join(logsDir, 'security.log'),
      level: 'warn',
      maxsize: 5242880, // 5MB
      maxFiles: 10,
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      )
    })
  ],
  
  // Handle exceptions and rejections
  exceptionHandlers: [
    new winston.transports.Console({
      format: consoleFormat
    }),
    new winston.transports.File({
      filename: path.join(logsDir, 'exceptions.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ],
  
  rejectionHandlers: [
    new winston.transports.Console({
      format: consoleFormat
    }),
    new winston.transports.File({
      filename: path.join(logsDir, 'rejections.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

// Remove duplicate file transports for production (they're already added above)
// This was causing duplicate logs in the original code

// Security logging functions
const logSecurityEvent = (event, details = {}) => {
  logger.warn('Security Event', {
    event,
    ...details,
    timestamp: new Date().toISOString()
  });
};

const logAuthAttempt = (type, success, details = {}) => {
  const level = success ? 'info' : 'warn';
  logger.log(level, `Authentication ${type}`, {
    success,
    type,
    ...details,
    timestamp: new Date().toISOString()
  });
};

const logUserAction = (action, userId, details = {}) => {
  logger.info('User Action', {
    action,
    userId,
    ...details,
    timestamp: new Date().toISOString()
  });
};

const logSystemError = (error, context = {}) => {
  logger.error('System Error', {
    message: error.message,
    stack: error.stack,
    ...context,
    timestamp: new Date().toISOString()
  });
};

const logDatabaseOperation = (operation, success, details = {}) => {
  const level = success ? 'info' : 'error';
  logger.log(level, `Database ${operation}`, {
    success,
    operation,
    ...details,
    timestamp: new Date().toISOString()
  });
};

const logAPIRequest = (req, res, responseTime) => {
  const { method, url, ip, headers } = req;
  const userAgent = headers['user-agent'] || 'Unknown';
  const userId = req.user ? req.user.id : null;
  
  // Use different log levels based on status code
  let level = 'info';
  if (res.statusCode >= 500) {
    level = 'error';
  } else if (res.statusCode >= 400) {
    level = 'warn';
  }
  
  logger.log(level, 'API Request', {
    method,
    url,
    statusCode: res.statusCode,
    ip,
    userAgent,
    userId,
    responseTime: `${responseTime}ms`,
    timestamp: new Date().toISOString()
  });
};

// Express middleware for request logging
const requestLogger = (req, res, next) => {
  const start = Date.now();
  
  // Override res.end to capture response
  const originalEnd = res.end;
  res.end = function(...args) {
    const responseTime = Date.now() - start;
    logAPIRequest(req, res, responseTime);
    originalEnd.apply(this, args);
  };
  
  next();
};

// Error logging middleware
const errorLogger = (error, req, res, next) => {
  logSystemError(error, {
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    userId: req.user ? req.user.id : null
  });
  
  next(error);
};

// Graceful shutdown
const shutdownLogger = () => {
  logger.info('Logger shutting down...');
  logger.end();
};

// Handle process termination
process.on('SIGTERM', shutdownLogger);
process.on('SIGINT', shutdownLogger);

module.exports = {
  logger,
  logSecurityEvent,
  logAuthAttempt,
  logUserAction,
  logSystemError,
  logDatabaseOperation,
  logAPIRequest,
  requestLogger,
  errorLogger,
  shutdownLogger
};


================================================
FILE: src/utils/response.js
================================================
/**
 * Create standardized API response
 * @param {boolean} success - Success status
 * @param {string} message - Response message
 * @param {object} data - Response data
 * @param {string} code - Error/success code
 * @param {object} meta - Additional metadata (pagination, etc.)
 * @returns {object} Standardized response object
 */
const createResponse = (success = true, message = '', data = null, code = null, meta = null) => {
  const response = {
    success,
    message,
    timestamp: new Date().toISOString()
  };

  if (data !== null) {
    response.data = data;
  }

  if (code) {
    response.code = code;
  }

  if (meta) {
    response.meta = meta;
  }

  return response;
};

/**
 * Create success response
 * @param {string} message - Success message
 * @param {object} data - Response data
 * @param {object} meta - Additional metadata
 * @returns {object} Success response
 */
const successResponse = (message = 'Success', data = null, meta = null) => {
  return createResponse(true, message, data, 'SUCCESS', meta);
};

/**
 * Create error response
 * @param {string} message - Error message
 * @param {string} code - Error code
 * @param {object} data - Error data
 * @returns {object} Error response
 */
const errorResponse = (message = 'Error', code = 'ERROR', data = null) => {
  return createResponse(false, message, data, code);
};

/**
 * Create pagination metadata
 * @param {number} page - Current page
 * @param {number} limit - Items per page
 * @param {number} total - Total items
 * @param {number} totalPages - Total pages
 * @returns {object} Pagination metadata
 */
const createPaginationMeta = (page, limit, total, totalPages) => {
  return {
    pagination: {
      currentPage: parseInt(page),
      itemsPerPage: parseInt(limit),
      totalItems: parseInt(total),
      totalPages: parseInt(totalPages),
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1
    }
  };
};

/**
 * Handle async route errors
 * @param {function} fn - Async function
 * @returns {function} Express middleware
 */
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

/**
 * Common HTTP status codes with messages
 */
const HTTP_STATUS = {
  OK: { code: 200, message: 'OK' },
  CREATED: { code: 201, message: 'Created' },
  ACCEPTED: { code: 202, message: 'Accepted' },
  NO_CONTENT: { code: 204, message: 'No Content' },
  BAD_REQUEST: { code: 400, message: 'Bad Request' },
  UNAUTHORIZED: { code: 401, message: 'Unauthorized' },
  FORBIDDEN: { code: 403, message: 'Forbidden' },
  NOT_FOUND: { code: 404, message: 'Not Found' },
  METHOD_NOT_ALLOWED: { code: 405, message: 'Method Not Allow' },
  CONFLICT: { code: 409, message: 'Conflict' },
  UNPROCESSABLE_ENTITY: { code: 422, message: 'Unprocessable Entity' },
  TOO_MANY_REQUESTS: { code: 429, message: 'Too Many Requests' },
  INTERNAL_SERVER_ERROR: { code: 500, message: 'Internal Server Error' },
  BAD_GATEWAY: { code: 502, message: 'Bad Gateway' },
  SERVICE_UNAVAILABLE: { code: 503, message: 'Service Unavailable' }
};

/**
 * Common error codes
 */
const ERROR_CODES = {
  // Authentication errors
  INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',
  ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',
  ACCOUNT_DISABLED: 'ACCOUNT_DISABLED',
  EMAIL_NOT_VERIFIED: 'EMAIL_NOT_VERIFIED',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  MISSING_TOKEN: 'MISSING_TOKEN',
  
  // Authorization errors
  INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',
  ACCESS_DENIED: 'ACCESS_DENIED',
  
  // Validation errors
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',
  INVALID_INPUT: 'INVALID_INPUT',
  
  // Resource errors
  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',
  RESOURCE_ALREADY_EXISTS: 'RESOURCE_ALREADY_EXISTS',
  RESOURCE_CONFLICT: 'RESOURCE_CONFLICT',
  INSUFFICIENT_BALANCE: 'INSUFFICIENT_BALANCE',
  
  // Rate limiting
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  
  // Server errors
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR'
};

/**
 * Success codes
 */
const SUCCESS_CODES = {
  USER_CREATED: 'USER_CREATED',
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGOUT_SUCCESS: 'LOGOUT_SUCCESS',
  PASSWORD_CHANGED: 'PASSWORD_CHANGED',
  PROFILE_UPDATED: 'PROFILE_UPDATED',
  EMAIL_VERIFIED: 'EMAIL_VERIFIED',
  EMAIL_VERIFICATION_SENT: 'EMAIL_VERIFICATION_SENT',
  TOKEN_REFRESHED: 'TOKEN_REFRESHED',
  POINTS_AWARDED: 'POINTS_AWARDED',
  POINTS_REDEEMED: 'POINTS_REDEEMED',
  REDEMPTION_PROCESSED: 'REDEMPTION_PROCESSED',
  RESOURCE_CREATED: 'RESOURCE_CREATED',
  RESOURCE_UPDATED: 'RESOURCE_UPDATED',
  RESOURCE_DELETED: 'RESOURCE_DELETED',
  STATUS_UPDATED: 'STATUS_UPDATED',
  FILE_UPLOADED: 'FILE_UPLOADED'
};

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  createPaginationMeta,
  asyncHandler,
  HTTP_STATUS,
  ERROR_CODES,
  SUCCESS_CODES
};


================================================
FILE: src/utils/validation.js
================================================
[Empty file]

